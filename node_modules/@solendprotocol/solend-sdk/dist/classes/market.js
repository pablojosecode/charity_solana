"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolendMarket = exports.formatReserveConfig = void 0;
const web3_js_1 = require("@solana/web3.js");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const obligation_1 = require("./obligation");
const reserve_1 = require("./reserve");
const obligation_2 = require("../state/obligation");
const axios_1 = __importDefault(require("axios"));
const API_ENDPOINT = "https://api.solend.fi";
function formatReserveConfig(config, marketAddress) {
    var _a;
    const market = marketAddress
        ? config.markets.find((mar) => mar.address === marketAddress)
        : (_a = config.markets.find((mar) => mar.isPrimary)) !== null && _a !== void 0 ? _a : config.markets[0];
    if (!market) {
        throw Error("No markets found.");
    }
    const hydratedReserves = market.reserves.map((res) => {
        const assetData = config.assets.find((asset) => asset.symbol === res.asset);
        if (!assetData) {
            throw new Error(`Could not find asset ${res.asset} in config`);
        }
        const oracleData = config.oracles.assets.find((asset) => asset.asset === res.asset);
        if (!oracleData) {
            throw new Error(`Could not find oracle data for ${res.asset} in config`);
        }
        const { asset: _asset } = oracleData, trimmedoracleData = __rest(oracleData, ["asset"]);
        return Object.assign(Object.assign(Object.assign({}, res), assetData), trimmedoracleData);
    });
    return Object.assign(Object.assign({}, market), { pythProgramID: config.oracles.pythProgramID, switchboardProgramID: config.oracles.switchboardProgramID, programID: config.programID, reserves: hydratedReserves });
}
exports.formatReserveConfig = formatReserveConfig;
class SolendMarket {
    constructor(connection) {
        this.connection = connection;
        this.reserves = [];
        this.rewardsData = null;
        this.config = null;
    }
    static initialize(connection, environment = "production", marketAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const market = new SolendMarket(connection);
            const rawConfig = (yield (yield axios_1.default.get(`${API_ENDPOINT}/v1/config?deployment=${environment}`)).data);
            market.config = formatReserveConfig(rawConfig, marketAddress);
            market.reserves = market.config.reserves.map((res) => new reserve_1.SolendReserve(res, connection));
            return market;
        });
    }
    fetchObligationByWallet(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const { config, reserves } = this;
            if (!config) {
                throw Error("Market must be initialized to call initialize.");
            }
            const obligationAddress = yield web3_js_1.PublicKey.createWithSeed(publicKey, config.address.slice(0, 32), new web3_js_1.PublicKey(config === null || config === void 0 ? void 0 : config.programID));
            const rawObligationData = yield this.connection.getAccountInfo(obligationAddress);
            if (!rawObligationData) {
                return null;
            }
            const parsedObligation = (0, obligation_2.parseObligation)(web3_js_1.PublicKey.default, rawObligationData);
            if (!parsedObligation) {
                throw Error("Could not parse obligation.");
            }
            if (!reserves.every((reserve) => reserve.stats)) {
                yield this.loadReserves();
            }
            const obligationInfo = parsedObligation.info;
            return new obligation_1.SolendObligation(publicKey, obligationAddress, obligationInfo, reserves);
        });
    }
    loadAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = [this.loadReserves(), this.loadRewards()];
            yield Promise.all(promises);
        });
    }
    loadLMRewardData() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (yield axios_1.default.get(`${API_ENDPOINT}/liquidity-mining/reward-stats-v2`)).data;
            return data;
        });
    }
    loadExternalRewardData() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (yield axios_1.default.get(`${API_ENDPOINT}/liquidity-mining/external-reward-stats-v2?flat=true`)).data;
            return data;
        });
    }
    loadPriceData(symbols) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (yield (yield axios_1.default.get(`${API_ENDPOINT}/v1/prices/?symbols=${symbols.join(",")}`)).data);
            return data.results.reduce((acc, price) => (Object.assign(Object.assign({}, acc), { [price.identifier]: Number(price.price) })), {});
        });
    }
    getLatestRewardRate(rewardRates, slot) {
        return rewardRates
            .filter((rr) => slot >= rr.beginningSlot)
            .reduce((v1, v2) => (v1.beginningSlot > v2.beginningSlot ? v1 : v2), {
            beginningSlot: 0,
            rewardRate: "0",
        });
    }
    loadRewards() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config) {
                throw Error("Market must be initialized to call loadRewards.");
            }
            const promises = [
                this.loadLMRewardData(),
                this.loadExternalRewardData(),
                this.connection.getSlot("finalized"),
            ];
            const [lmRewards, externalRewards, currentSlot] = yield Promise.all(promises);
            const querySymbols = [
                ...new Set(externalRewards.map((reward) => reward.rewardSymbol)),
            ];
            const priceData = yield this.loadPriceData(querySymbols.concat("SLND"));
            this.rewardsData = this.reserves.reduce((acc, reserve) => {
                const { config: { mintAddress }, } = reserve;
                const lmReward = lmRewards[this.config.address][mintAddress];
                const supply = [
                    (lmReward === null || lmReward === void 0 ? void 0 : lmReward.supply)
                        ? {
                            rewardRate: this.getLatestRewardRate(lmReward.supply.rewardRates, currentSlot).rewardRate,
                            rewardMint: "SLNDpmoWTVADgEdndyvWzroNL7zSi1dF9PC3xHGtPwp",
                            rewardSymbol: "SLND",
                            price: new bignumber_js_1.default(priceData.SLND).toNumber(),
                        }
                        : null,
                    ...externalRewards
                        .filter((externalReward) => externalReward.reserveID === reserve.config.address &&
                        externalReward.side === "supply")
                        .map((externalReward) => ({
                        rewardRate: this.getLatestRewardRate(externalReward.rewardRates, currentSlot).rewardRate,
                        rewardMint: externalReward.rewardMint,
                        rewardSymbol: externalReward.rewardSymbol,
                        price: priceData[externalReward.rewardSymbol],
                    })),
                ].filter(Boolean);
                const borrow = [
                    (lmReward === null || lmReward === void 0 ? void 0 : lmReward.borrow)
                        ? {
                            rewardRate: this.getLatestRewardRate(lmReward.borrow.rewardRates, currentSlot).rewardRate,
                            rewardMint: "SLNDpmoWTVADgEdndyvWzroNL7zSi1dF9PC3xHGtPwp",
                            rewardSymbol: "SLND",
                            price: new bignumber_js_1.default(priceData.SLND).toNumber(),
                        }
                        : null,
                    ...externalRewards
                        .filter((externalReward) => externalReward.reserveID === reserve.config.address &&
                        externalReward.side === "borrow")
                        .map((externalReward) => ({
                        rewardRate: this.getLatestRewardRate(externalReward.rewardRates, currentSlot).rewardRate,
                        rewardMint: externalReward.rewardMint,
                        rewardSymbol: externalReward.rewardSymbol,
                        price: priceData[externalReward.rewardSymbol],
                    })),
                ].filter(Boolean);
                return Object.assign(Object.assign({}, acc), { [reserve.config.mintAddress]: {
                        supply,
                        borrow,
                    } });
            }, {});
            const refreshReserves = this.reserves.map((reserve) => {
                var _a;
                return reserve.load((_a = this.rewardsData) !== null && _a !== void 0 ? _a : undefined);
            });
            yield Promise.all(refreshReserves);
        });
    }
    loadReserves() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = this.reserves.map((reserve) => new web3_js_1.PublicKey(reserve.config.address));
            const reserveAccounts = yield this.connection.getMultipleAccountsInfo(addresses, "processed");
            const loadReserves = this.reserves.map((reserve, index) => {
                reserve.setBuffer(reserveAccounts[index]);
                return reserve.load();
            });
            yield Promise.all(loadReserves);
        });
    }
    refreshAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = [
                this.reserves.every((reserve) => reserve.stats)
                    ? this.loadReserves()
                    : null,
                this.rewardsData ? this.loadRewards() : null,
            ].filter((x) => x);
            yield Promise.all(promises);
        });
    }
}
exports.SolendMarket = SolendMarket;
