"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userPendingRewards = void 0;
const anchor_1 = require("@project-serum/anchor");
const math_1 = require("../../utils/math");
function userPendingRewards(userInfo, poolInfo) {
    const currentTime = new anchor_1.BN(Date.now()).divn(1000);
    const rewardsList = [];
    poolInfo.rewardsInfoArr.forEach((rewardsInfo, index) => {
        const token = 'FRC';
        const decimals = 6;
        let userBalance = new anchor_1.BN(0);
        let poolTotalBalance = new anchor_1.BN(0);
        if (rewardsInfo.rewardsRule.rewardsBasedOnShare) {
            userBalance = userInfo.stakeInfo.shareAmount;
            poolTotalBalance = poolInfo.stakeInfo.totalShares;
        }
        else if (rewardsInfo.rewardsRule.rewardsBasedOnWorkingBalance) {
            userBalance = userInfo.stakeInfo.workingBalance;
            poolTotalBalance = poolInfo.stakeInfo.totalWorkingBalance;
        }
        else {
            console.log("ERROR");
        }
        let pendingRewards = calcPendingRewards(userInfo.rewardsInfoArr[index].rewardsDebt, userBalance, poolTotalBalance, rewardsInfo.accumulatedRewardsPerShare, rewardsInfo.startTime, rewardsInfo.endTime, rewardsInfo.rewardsPerSecond, poolInfo.lastUpdateTime, currentTime);
        if (userInfo.rewardsInfoArr[index].accumulatedRewards) {
            pendingRewards = pendingRewards.add(userInfo.rewardsInfoArr[index].accumulatedRewards);
        }
        const amount = (0, math_1.getAmountByDecimals)(pendingRewards, decimals);
        rewardsList.push({
            amount,
            token
        });
    });
    return rewardsList;
}
exports.userPendingRewards = userPendingRewards;
function calcPendingRewards(userDebt, userBalance, poolTotalBalance, poolAccRewardsPerShare, startRewardsTime, endRewardsTime, rewardsPerSecond, lastUpdateTime, currentTime) {
    const REWARDS_PER_SHARE_MULTIPLIER = new anchor_1.BN(1000000000);
    let rewardsTimeLapse = new anchor_1.BN(0);
    if (lastUpdateTime.gt(endRewardsTime) || currentTime.lt(startRewardsTime)) {
        rewardsTimeLapse = new anchor_1.BN(0);
    }
    else {
        const end = Math.min(currentTime.toNumber(), endRewardsTime.toNumber());
        const start = Math.max(lastUpdateTime.toNumber(), startRewardsTime.toNumber());
        rewardsTimeLapse = new anchor_1.BN(end - start);
    }
    const rewardsInc = poolTotalBalance.gtn(0) ? rewardsTimeLapse.mul(rewardsPerSecond).mul(REWARDS_PER_SHARE_MULTIPLIER).div(poolTotalBalance) : new anchor_1.BN(0);
    poolAccRewardsPerShare = poolAccRewardsPerShare.add(rewardsInc);
    const newRewardsDebt = userBalance.mul(poolAccRewardsPerShare).div(REWARDS_PER_SHARE_MULTIPLIER);
    return newRewardsDebt.sub(userDebt);
}
