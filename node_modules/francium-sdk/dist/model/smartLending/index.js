"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FranciumSmartLending = void 0;
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const token_1 = require("../../utils/trx/token");
const idl_1 = require("../../constants/smartLending/idl");
const pools_1 = require("../../constants/smartLending/pools");
const tools_1 = require("../../utils/tools");
const layout_1 = require("../../constants/price/layout");
const spl_token_1 = require("@solana/spl-token");
const token_instructions_1 = require("@project-serum/serum/lib/token-instructions");
const pools_2 = require("../../constants/lend/pools");
const lodash_1 = require("lodash");
const math_1 = require("../../utils/math");
const getVeTokenBalance_1 = require("../../utils/getVeTokenBalance");
const bignumber_js_1 = require("bignumber.js");
const rewards_1 = require("./rewards");
const info_1 = require("./info");
const SMART_LENDING_PROGRAM_ID = new web3_js_1.PublicKey('FrcmhqyyRF7GragBtVfSW7HcKtZB4fkPorN1U4MGaQKr');
class FranciumSmartLending {
    constructor(config) {
        this.idl = idl_1.default;
        this.config = pools_1.smartLendingPools;
        this.connection = config.connection;
        const commitment = 'confirmed';
        this.program = new anchor_1.Program(this.idl, SMART_LENDING_PROGRAM_ID, new anchor_1.Provider(this.connection, null, {
            skipPreflight: true,
            commitment,
            preflightCommitment: commitment
        }));
    }
    getPoolStatus(poolName) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this.program.account.poolInfo.fetch(pools_1.smartLendingPools[poolName].smartPoolInfo.poolInfoAccount);
            return info;
        });
    }
    getAllPoolStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const accountList = pools_1.activeSmartLendingPools.map(i => i.poolInfoAccount);
            const infos = yield this.program.account.poolInfo.fetchMultiple(accountList);
            return pools_1.activeSmartLendingPools.map((i, index) => {
                var _a;
                const info = infos[index];
                const maxCapacityLimit = (0, math_1.getAmountByDecimals)(info.stakeInfo.maxCapacityLimit, (0, tools_1.getTokenDecimals)(i.pool));
                const currentAmount = (0, math_1.getAmountByDecimals)(info.stakeInfo.totalLiquidity, (0, tools_1.getTokenDecimals)(i.pool));
                const rewardInfo = (0, info_1.formatSmartPoolRewardsInfo)(info.rewardsInfoArr);
                const totalLiquidity = (0, math_1.getAmountByDecimals)(info.stakeInfo.totalLiquidity, (0, tools_1.getTokenDecimals)(i.pool));
                const maxLockupDuration = (0, math_1.getAmountByDecimals)(info.maxLockupDuration, (0, tools_1.getTokenDecimals)(i.pool));
                const totalWorkingBalance = (0, math_1.getAmountByDecimals)(info.stakeInfo.totalWorkingBalance, (0, tools_1.getTokenDecimals)(i.pool));
                const rewards_per_sencond = new bignumber_js_1.default(((_a = rewardInfo.find(item => item.token === 'FRC')) === null || _a === void 0 ? void 0 : _a.rewardsPerSecond) || 0);
                const secs_per_year = new bignumber_js_1.default(365 * 24 * 3600);
                const rewards_per_year = rewards_per_sencond.multipliedBy(secs_per_year);
                function getMaxAPR() {
                    return rewards_per_year.div(new bignumber_js_1.default(totalWorkingBalance)).toNumber();
                }
                return {
                    pool: i.pool,
                    poolInfoAccount: i.poolInfoAccount,
                    info,
                    formatData: {
                        maxAPR: getMaxAPR(),
                        rewards_per_year: rewards_per_year.toNumber(),
                        totalLiquidity,
                        maxLockupDuration,
                        totalWorkingBalance,
                        maxCapacityLimit,
                        currentAmount,
                        rewardInfo,
                    }
                };
            });
        });
    }
    getUserPositions(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let accountInfos = [];
            try {
                accountInfos = yield this.connection.getProgramAccounts(this.program.programId, {
                    filters: [
                        {
                            dataSize: 408
                        },
                        {
                            memcmp: {
                                offset: 8 + 8 + 1,
                                bytes: userPublicKey.toBase58()
                            }
                        },
                    ]
                });
            }
            catch (e) {
                console.log(e);
            }
            const res = accountInfos.map(e => {
                return {
                    publicKey: e.pubkey,
                    account: this.program.coder.accounts.decode('UserInfo', e.account.data)
                };
            });
            console.log(res);
            return res;
        });
    }
    getFormattedUserPositions(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const allPoolStatus = yield this.getAllPoolStatus();
            let user = [];
            if (!userPublicKey) {
            }
            else {
                const userPositions = yield this.getUserPositions(userPublicKey);
                const positions = userPositions.map(i => {
                    const userInfo = i.account;
                    const targetPoolStatus = (0, lodash_1.find)(allPoolStatus, poolInfo => {
                        var _a, _b, _c;
                        return ((_a = poolInfo.poolInfoAccount) === null || _a === void 0 ? void 0 : _a.toBase58()) === ((_c = (_b = i.account) === null || _b === void 0 ? void 0 : _b.poolInfo) === null || _c === void 0 ? void 0 : _c.toBase58());
                    });
                    if (targetPoolStatus) {
                        const poolInfo = targetPoolStatus.info;
                        const decimals = (0, tools_1.getTokenDecimals)(targetPoolStatus.pool);
                        const userShareAmount = (0, math_1.toBigNumber)(userInfo.stakeInfo.shareAmount);
                        const poolTotalLiquidity = (0, math_1.toBigNumber)(poolInfo.stakeInfo.totalLiquidity);
                        const poolTotalShares = (0, math_1.toBigNumber)(poolInfo.stakeInfo.totalShares);
                        const perSharesAmount = poolTotalLiquidity.dividedBy(poolTotalShares);
                        const userLiquidity = userShareAmount.multipliedBy(perSharesAmount);
                        const userLiquidityAmount = (0, math_1.getAmountByDecimals)(userLiquidity, decimals);
                        const pendingRewards = (0, rewards_1.userPendingRewards)(userInfo, poolInfo);
                        return {
                            pool: targetPoolStatus.pool,
                            poolInfo,
                            decimals,
                            perSharesAmount: perSharesAmount.toNumber(),
                            userShareAmount,
                            userLiquidityAmount,
                            workingBalance: (0, math_1.getAmountByDecimals)(userInfo.stakeInfo.workingBalance, decimals),
                            lockupExpiration: userInfo.stakeInfo.lockupExpiration.toNumber() * 1000,
                            veTokenBalance: (0, math_1.getAmountByDecimals)((0, getVeTokenBalance_1.default)(poolInfo, userInfo.stakeInfo.stakedAmount, userInfo.stakeInfo.lockupExpiration), decimals),
                            userStaked: (0, math_1.getAmountByDecimals)(userInfo.stakeInfo.stakedAmount, decimals),
                            userInfoAccount: i.publicKey,
                            pendingRewards,
                            info: userInfo
                        };
                    }
                });
                user = (0, lodash_1.sortBy)(positions.filter(i => !!i), [i => {
                        return i.pool;
                    }, i => {
                        return i.userInfoAccount.toBase58();
                    }]);
            }
            return {
                pool: allPoolStatus,
                user,
            };
        });
    }
    initUserInfo(userPublicKey, poolName) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetLendInfo = this.config[poolName];
            const userNonce = new anchor_1.BN(1);
            const userInfoSeed = 'user_info'.split('').map(e => e.charCodeAt(0));
            const [userInfoAccount, userBump] = yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from(userInfoSeed),
                targetLendInfo.smartPoolInfo.poolInfoAccount.toBuffer(),
                userPublicKey.toBuffer(),
                userNonce.toArrayLike(Buffer, 'le', 8)
            ], SMART_LENDING_PROGRAM_ID);
            const ix = yield this.program.instruction.initializeUser(userNonce, userBump, {
                accounts: {
                    userMainAccount: userPublicKey,
                    marketInfo: pools_1.smartPoolMarketInfo.marketInfoAccount,
                    liquidityTokenMint: pools_1.smartLendingPools[poolName].smartPoolInfo.liquidityTokenMint,
                    poolInfo: pools_1.smartLendingPools[poolName].smartPoolInfo.poolInfoAccount,
                    userInfo: userInfoAccount,
                    systemProgram: web3_js_1.SystemProgram.programId
                }
            });
            return [
                userInfoAccount,
                [ix]
            ];
        });
    }
    initUserAccount(userPublicKey, poolName, amount, trx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const targetLendInfo = this.config[poolName];
            const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(this.connection, userPublicKey);
            let userLiquidityTokenAccount = (_a = userParsedAccount[targetLendInfo.smartPoolInfo.liquidityTokenMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
            let newAccount;
            if ((0, tools_1.isNativeMint)(targetLendInfo.smartPoolInfo.liquidityTokenMint)) {
                const rentExemptLamports = yield this.connection.getMinimumBalanceForRentExemption(layout_1.ACCOUNT_LAYOUT.span);
                newAccount = web3_js_1.Keypair.generate();
                trx.add(web3_js_1.SystemProgram.createAccount({
                    fromPubkey: userPublicKey,
                    newAccountPubkey: newAccount.publicKey,
                    lamports: amount.toNumber() + rentExemptLamports,
                    space: layout_1.ACCOUNT_LAYOUT.span,
                    programId: spl_token_1.TOKEN_PROGRAM_ID
                }));
                trx.add((0, token_instructions_1.initializeAccount)({
                    account: newAccount.publicKey,
                    mint: spl_token_1.NATIVE_MINT,
                    owner: userPublicKey
                }));
                userLiquidityTokenAccount = newAccount.publicKey.toBase58();
            }
            if (!userLiquidityTokenAccount) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.smartPoolInfo.liquidityTokenMint, userPublicKey, trx);
                userLiquidityTokenAccount = pk.toBase58();
            }
            let userRewardsTokenAccount = (_b = userParsedAccount[targetLendInfo.smartPoolInfo.rewardsTokenMint.toBase58()]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
            if (!userRewardsTokenAccount) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.smartPoolInfo.rewardsTokenMint, userPublicKey, trx);
                userRewardsTokenAccount = pk.toBase58();
            }
            return [userLiquidityTokenAccount, userRewardsTokenAccount, newAccount];
        });
    }
    unStake(userPublicKey, poolName, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const vaultStakeAccounts = this.getWithdrawVaultStakeAccounts(poolName);
            const ix = yield this.program.instruction.unStake(configs.shareAmount, {
                accounts: {
                    userMainAccount: userPublicKey,
                    userInfo: configs.userInfoAccount,
                    poolInfo: pools_1.smartLendingPools[poolName].smartPoolInfo.poolInfoAccount,
                    poolAuthority: pools_1.smartLendingPools[poolName].smartPoolInfo.poolAuthority,
                    userLiquidityTokenAccount: configs.userLiquidityTokenAccount,
                    poolLiquidityTokenAccount: pools_1.smartLendingPools[poolName].smartPoolInfo.liquidityTokenAccount,
                    poolVaultManager: pools_1.smartLendingPools[poolName].smartPoolInfo.vaultManagerAccount,
                    tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
                },
                remainingAccounts: [
                    { pubkey: configs.userRewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: configs.userRewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                    ...vaultStakeAccounts
                ]
            });
            return ix;
        });
    }
    closeUserInfo(userPublicKey, poolInfo, userInfoAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            const ix = this.program.instruction.closeUserInfo({
                accounts: {
                    userMainAccount: userPublicKey,
                    poolInfo: poolInfo,
                    userInfo: userInfoAccount
                }
            });
            return ix;
        });
    }
    stakeWithLockupTime(userPublicKey, poolName, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const vaultStakeAccounts = this.getDepositVaultStakeAccounts(poolName);
            const ix = this.program.instruction.stakeWithLockupTime(configs.liquidityAmount, configs.lockupTime, {
                accounts: {
                    userMainAccount: userPublicKey,
                    userInfo: configs.userInfoAccount,
                    poolInfo: pools_1.smartLendingPools[poolName].smartPoolInfo.poolInfoAccount,
                    poolAuthority: pools_1.smartLendingPools[poolName].smartPoolInfo.poolAuthority,
                    userLiquidityTokenAccount: configs.userLiquidityTokenAccount,
                    poolLiquidityTokenAccount: pools_1.smartLendingPools[poolName].smartPoolInfo.liquidityTokenAccount,
                    poolVaultManager: pools_1.smartLendingPools[poolName].smartPoolInfo.vaultManagerAccount,
                    tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
                },
                remainingAccounts: [
                    { pubkey: configs.userRewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: configs.userRewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                    ...vaultStakeAccounts
                ]
            });
            return ix;
        });
    }
    getDepositVaultStakeAccounts(poolName) {
        return [
            { pubkey: pools_2.lendProgramId, isSigner: false, isWritable: false },
            { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
            { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.lendingShareAccount, isSigner: false, isWritable: true },
            {
                pubkey: pools_1.smartLendingPools[poolName].basedLendingPool.lendingPoolInfoAccount,
                isSigner: false,
                isWritable: true
            },
            { pubkey: pools_1.smartLendingPools[poolName].basedLendingPool.lendingPoolTknAccount, isSigner: false, isWritable: true },
            { pubkey: pools_1.smartLendingPools[poolName].basedLendingPool.lendingPoolShareMint, isSigner: false, isWritable: true },
            { pubkey: pools_1.lendingPoolMarketInfo.marketInfoAccount, isSigner: false, isWritable: true },
            { pubkey: pools_1.lendingPoolMarketInfo.marketAuthority, isSigner: false, isWritable: false },
            {
                pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.poolAuthority,
                isSigner: false,
                isWritable: false
            },
            { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        ];
    }
    getWithdrawVaultStakeAccounts(poolName) {
        return [
            { pubkey: pools_2.lendProgramId, isSigner: false, isWritable: false },
            { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.lendingShareAccount, isSigner: false, isWritable: true },
            { pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
            {
                pubkey: pools_1.smartLendingPools[poolName].basedLendingPool.lendingPoolInfoAccount,
                isSigner: false,
                isWritable: true
            },
            { pubkey: pools_1.smartLendingPools[poolName].basedLendingPool.lendingPoolShareMint, isSigner: false, isWritable: true },
            { pubkey: pools_1.smartLendingPools[poolName].basedLendingPool.lendingPoolTknAccount, isSigner: false, isWritable: true },
            { pubkey: pools_1.lendingPoolMarketInfo.marketInfoAccount, isSigner: false, isWritable: true },
            { pubkey: pools_1.lendingPoolMarketInfo.marketAuthority, isSigner: false, isWritable: false },
            {
                pubkey: pools_1.smartLendingPools[poolName].smartPoolInfo.poolAuthority,
                isSigner: false,
                isWritable: false
            },
            { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        ];
    }
    claimRewards(userPublicKey, poolName, userInfoAccount) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const trx = new web3_js_1.Transaction();
            const targetInfo = this.config[poolName];
            const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(this.connection, userPublicKey);
            let userRewardAccount = (_a = userParsedAccount[targetInfo.smartPoolInfo.rewardsTokenMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
            if (!userRewardAccount) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetInfo.smartPoolInfo.rewardsTokenMint, userPublicKey, trx);
                userRewardAccount = pk.toBase58();
            }
            const ix = this.program.instruction.harvest({
                accounts: {
                    userMainAccount: userPublicKey,
                    userInfo: userInfoAccount,
                    poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                    poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                    tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID
                },
                remainingAccounts: [
                    { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                ]
            });
            trx.add(ix);
            return trx;
        });
    }
}
exports.FranciumSmartLending = FranciumSmartLending;
