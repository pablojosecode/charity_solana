"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const raydium_1 = require("../../constants/auto/raydium");
const idl_1 = require("../../constants/auto/idl");
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@project-serum/anchor");
const spl_token_1 = require("@solana/spl-token");
const lodash_1 = require("lodash");
const bignumber_js_1 = require("bignumber.js");
const math_1 = require("../../utils/math");
const tools_1 = require("../../utils/tools");
const commitment = 'confirmed';
class FranciumAutoVaults {
    constructor(config) {
        this.configs = {};
        this.programs = {};
        this.allPoolList = [];
        const allPoolList = [];
        (0, lodash_1.forEach)(raydium_1.AUTO_RAYDIUM_FARM_CONFIG, (value, id) => {
            allPoolList.push({
                type: 'raydium',
                id,
                pair: value.pair,
                config: value,
                extra: raydium_1.AUTO_RAYDIUM_EXTRA_CONFIG[id]
            });
        });
        this.configs = {
            raydium: {
                idl: idl_1.default,
                programId: raydium_1.FRANCIUM_AUTO_VAULTS_PROGRAM_ID,
                config: raydium_1.AUTO_RAYDIUM_FARM_CONFIG,
            },
            orca: {
                idl: idl_1.default,
                programId: raydium_1.FRANCIUM_AUTO_VAULTS_PROGRAM_ID,
                config: {}
            }
        };
        this.allPoolList = allPoolList;
        this.connection = config.connection;
    }
    getProgram(type = 'raydium') {
        if (this.programs[type]) {
            return this.programs[type];
        }
        else {
            const { idl, programId } = this.configs[type];
            const program = new anchor_1.Program(idl, programId, new anchor_1.AnchorProvider(this.connection, {
                publicKey: spl_token_1.NATIVE_MINT,
                signAllTransactions: (trxs) => {
                    return Promise.resolve(trxs);
                },
                signTransaction: (trxs) => {
                    return Promise.resolve(trxs);
                },
            }, {
                skipPreflight: true,
                commitment,
                preflightCommitment: commitment
            }));
            this.programs[type] = program;
            return program;
        }
    }
    getConfig(pair, type = 'raydium') {
        const { config } = this.configs[type];
        return config[pair];
    }
    getUserPositionsAll(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let pubkey = userPublicKey;
            if ((0, lodash_1.isString)(userPublicKey)) {
                pubkey = new web3_js_1.PublicKey(userPublicKey);
            }
            const raydiumInfos = yield this.getUserPositionsByProgram('raydium', pubkey);
            return {
                orca: [],
                raydium: raydiumInfos
            };
        });
    }
    getFarmPoolsInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const pools = this.allPoolList;
            const poolAccounts = pools.map(i => {
                return new web3_js_1.PublicKey(i.config.poolInfoAccount);
            });
            const res = yield this.connection.getMultipleAccountsInfo(poolAccounts, 'confirmed');
            const decodeResult = res.map((i, index) => {
                const poolItem = pools[index];
                const program = this.getProgram(poolItem.type || 'raydium');
                const strategyInfo = program.coder.accounts.decode('PoolInfo', i.data);
                return Object.assign(Object.assign({}, poolItem), { poolInfo: strategyInfo });
            });
            return decodeResult;
        });
    }
    getUserFarmPosition(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const farmInfo = yield this.getFarmPoolsInfo();
            const formattedPoolInfo = farmInfo.map(i => {
                const { lpDecimals, depositToken } = i.extra;
                const [token1, token0] = i.pair.split('-');
                return Object.assign(Object.assign({}, i), { formatter: this.formatUserAutoPosition(i.poolInfo, null, {
                        token0,
                        token1,
                        lpDecimals,
                        depositToken
                    }) });
            });
            if (!userPublicKey) {
                return {
                    user: [],
                    pool: formattedPoolInfo
                };
            }
            const infos = yield this.getUserPositionsAll(userPublicKey);
            const raydiumInfos = infos.raydium;
            const orcaInfos = infos.orca;
            const formattedUserInfos = [...raydiumInfos, ...orcaInfos].map(i => {
                const poolInfoAccount = i.data.poolInfo;
                const targetPool = (0, lodash_1.find)(farmInfo, target => {
                    return target.config.poolInfoAccount === poolInfoAccount.toBase58();
                });
                const { lpDecimals, depositToken } = targetPool.extra;
                const [token1, token0] = targetPool.pair.split('-');
                const formatter = this.formatUserAutoPosition(targetPool === null || targetPool === void 0 ? void 0 : targetPool.poolInfo, i.data, {
                    token0,
                    token1,
                    lpDecimals,
                    depositToken
                });
                return Object.assign(Object.assign({}, (targetPool || {})), { userInfo: i.data, userInfoPublicKey: i.publicKey, formatter });
            });
            return {
                pool: formattedPoolInfo,
                user: formattedUserInfos
            };
        });
    }
    formatUserAutoPosition(poolInfo, userInfo, config) {
        let pool = {};
        let user = {};
        if (poolInfo) {
            const decimals0 = (0, tools_1.getTokenDecimals)(config.token0);
            const decimals1 = (0, tools_1.getTokenDecimals)(config.token1);
            const totalLP = (0, math_1.getAmountByDecimals)(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.lpAmount, config.lpDecimals);
            const totalShares = new bignumber_js_1.default(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.totalShares.toString());
            const totalBorrow0 = (0, math_1.getAmountByDecimals)(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.borrowed0.add(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.pendingRepay0), decimals0);
            const totalBorrow1 = (0, math_1.getAmountByDecimals)(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.borrowed1.add(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.pendingRepay1), decimals1);
            const totalToken0 = (0, math_1.getAmountByDecimals)(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.tknAmount0, decimals0);
            const totalToken1 = (0, math_1.getAmountByDecimals)(poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.tknAmount1, decimals1);
            pool = {
                totalLP,
                totalShares: poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.totalShares,
                totalBorrow0,
                totalBorrow1,
                totalToken0,
                totalToken1
            };
            if (userInfo) {
                const userShares = new bignumber_js_1.default(userInfo === null || userInfo === void 0 ? void 0 : userInfo.shareAmount.toString());
                const userPercent = userShares.dividedBy(totalShares).toNumber();
                const userDeposit0 = (0, math_1.getAmountByDecimals)(userInfo === null || userInfo === void 0 ? void 0 : userInfo.principal0, decimals0);
                const userDeposit1 = (0, math_1.getAmountByDecimals)(userInfo === null || userInfo === void 0 ? void 0 : userInfo.principal1, decimals1);
                const userLPAmount = totalLP * userPercent;
                const userBorrow0 = totalBorrow0 * userPercent;
                const userBorrow1 = totalBorrow1 * userPercent;
                const positionState = userInfo.positionAdjustState;
                let state = '';
                let stateInfo = {};
                if (positionState.adjustType.idle !== undefined) {
                    state = 'idle';
                }
                else if (positionState.adjustType.deposit !== undefined) {
                    state = 'deposit';
                    const depositInfo = {
                        tkn0: positionState.state.data[0],
                        tkn1: positionState.state.data[1]
                    };
                    stateInfo = depositInfo;
                }
                else if (positionState.adjustType.withdraw !== undefined) {
                    state = 'withdraw';
                    const withdrawInfo = {
                        lpAmount: positionState.state.data[0],
                    };
                    stateInfo = withdrawInfo;
                }
                user = {
                    userShares: userInfo === null || userInfo === void 0 ? void 0 : userInfo.shareAmount,
                    userPercent,
                    userLPAmount,
                    userBorrow0,
                    userBorrow1,
                    userDeposit0,
                    userDeposit1,
                    userToken0: totalToken0 * userPercent,
                    userToken1: totalToken1 * userPercent,
                    state,
                    stateInfo
                };
            }
        }
        return {
            pool,
            user
        };
    }
    getUserPositionsByProgram(programType, userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const program = this.getProgram(programType || 'raydium');
            if (!program) {
                return [];
            }
            const decodeResult = [];
            const infos = yield this.connection.getProgramAccounts(program.programId, {
                filters: [
                    { dataSize: 236 },
                    {
                        memcmp: {
                            offset: 8 + 1 + 8 + 1,
                            bytes: userPublicKey.toBase58()
                        }
                    }
                ]
            });
            infos.forEach((item, index) => {
                try {
                    const userInfo = program.coder.accounts.decode('UserPositionInfo', item.account.data);
                    decodeResult.push({
                        publicKey: item.pubkey,
                        data: userInfo,
                    });
                }
                catch (err) {
                }
            });
            return (0, lodash_1.sortBy)(decodeResult, i => -i.data.nonce.toNumber());
        });
    }
}
exports.default = FranciumAutoVaults;
