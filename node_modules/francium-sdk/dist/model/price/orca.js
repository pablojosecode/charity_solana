"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrcaLPPrice = exports.updatePrice = void 0;
const anchor_1 = require("@project-serum/anchor");
const lodash_1 = require("lodash");
const info_1 = require("../../constants/farm/orca/info");
const tools_1 = require("../../utils/tools");
const math_1 = require("../../utils/math");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const bignumber_js_1 = require("bignumber.js");
function updatePrice(tokenName, priceList, LPInfo, config) {
    const calcPrice = (config === null || config === void 0 ? void 0 : config.pcPrice) || 1;
    const calcDecimals = (config === null || config === void 0 ? void 0 : config.pcDecimals) || 6;
    const lpName = (config === null || config === void 0 ? void 0 : config.LPName) || `${tokenName}-USDC`;
    const info = LPInfo[lpName];
    let price = 0;
    if (info) {
        const tokenAmount = (0, math_1.getAmountByDecimals)(info.coinAmount, (0, tools_1.getTokenDecimals)(tokenName));
        const pcAmount = (0, math_1.getAmountByDecimals)(info.pcAmount, calcDecimals);
        price = pcAmount / tokenAmount * calcPrice;
    }
    priceList[tokenName] = price;
    return price;
}
exports.updatePrice = updatePrice;
function getOrcaLPPrice(connection, priceList) {
    return __awaiter(this, void 0, void 0, function* () {
        const keysList = [];
        const LPInfo = {};
        const info = {};
        const ORCA_EXTRA_CONFIG = {
            'stSOL-wLDO': {
                alias: null,
                orcaPoolId: '',
                ammInfo: {
                    swapTknVault0: new web3_js_1.PublicKey('GDprNAcXeR5GVGnCtkS5UqyPGMm2Sy5Lk15qqN36faMT'),
                    swapTknVault1: new web3_js_1.PublicKey('VCgdcsExfmxUDQwusLP2xqZ3ap7VuYyQMMHDPSva2hx'),
                    lpMint: new web3_js_1.PublicKey('74B9aMS7SA832xKngt5VLKmWAP3pa3qkUzWncTmQSsGF')
                }
            }
        };
        const TOTAL_CONFIG = Object.assign(Object.assign({}, info_1.ORCA_FARM_CONFIG), ORCA_EXTRA_CONFIG);
        const formattedConfig = (0, lodash_1.map)(TOTAL_CONFIG, (value, key) => {
            var _a, _b, _c, _d, _e, _f;
            const [token1, token0] = key.split('-');
            const poolKey = (value === null || value === void 0 ? void 0 : value.alias) || key;
            keysList.push((_a = value === null || value === void 0 ? void 0 : value.ammInfo) === null || _a === void 0 ? void 0 : _a.swapTknVault0, (_b = value === null || value === void 0 ? void 0 : value.ammInfo) === null || _b === void 0 ? void 0 : _b.swapTknVault1, (_c = value === null || value === void 0 ? void 0 : value.ammInfo) === null || _c === void 0 ? void 0 : _c.lpMint);
            LPInfo[poolKey] = {
                pcToken: token0,
                pcAmount: new anchor_1.BN(0),
                coinToken: token1,
                coinAmount: new anchor_1.BN(0),
                lpTotalSupply: new anchor_1.BN(0),
                lpDecimals: 6
            };
            return {
                key: (value === null || value === void 0 ? void 0 : value.alias) || key,
                token0Account: (_d = value === null || value === void 0 ? void 0 : value.ammInfo) === null || _d === void 0 ? void 0 : _d.swapTknVault0,
                token1Account: (_e = value === null || value === void 0 ? void 0 : value.ammInfo) === null || _e === void 0 ? void 0 : _e.swapTknVault1,
                lpMint: (_f = value === null || value === void 0 ? void 0 : value.ammInfo) === null || _f === void 0 ? void 0 : _f.lpMint
            };
        });
        const multipleInfo = yield (0, tools_1.splitMultipleAccountsInfo)(connection, keysList);
        multipleInfo.forEach((value, index) => {
            const configIndex = Math.floor(index / 3);
            const poolKey = formattedConfig[configIndex].key;
            if (index % 3 === 2) {
                const info = spl_token_1.MintLayout.decode(value.data);
                LPInfo[poolKey].lpTotalSupply = new anchor_1.BN(spl_token_1.u64.fromBuffer(info.supply).toString());
            }
            else if (index % 3 === 0) {
                const accountInfo = spl_token_1.AccountLayout.decode(value.data);
                const amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
                LPInfo[poolKey].pcAmount = new anchor_1.BN(amount.toString());
            }
            else if (index % 3 === 1) {
                const accountInfo = spl_token_1.AccountLayout.decode(value.data);
                const amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
                LPInfo[poolKey].coinAmount = new anchor_1.BN(amount.toString());
            }
        });
        if (!priceList.SOL) {
            updatePrice('SOL', priceList, LPInfo);
        }
        if (!priceList.mSOL) {
            updatePrice('mSOL', priceList, LPInfo);
        }
        if (!priceList.whETH) {
            updatePrice('whETH', priceList, LPInfo);
        }
        if (!priceList.wLDO) {
            updatePrice('wLDO', priceList, LPInfo, {
                LPName: 'stSOL-wLDO',
                pcPrice: priceList.mSOL,
                pcDecimals: 9
            });
        }
        (0, lodash_1.forEach)(LPInfo, (value, key) => {
            if (value.pcToken === 'USDC' || value.pcToken === 'USDT') {
                updatePrice(value.coinToken, priceList, LPInfo, {
                    LPName: key
                });
            }
        });
        (0, lodash_1.forEach)(TOTAL_CONFIG, (value, key) => {
            var _a;
            const poolKey = ((_a = value) === null || _a === void 0 ? void 0 : _a.alias) || key;
            const targetPoolInfo = LPInfo[poolKey];
            const pcPrice = priceList[targetPoolInfo.pcToken];
            const coinPrice = priceList[targetPoolInfo.coinToken];
            const pcDecimals = (0, tools_1.getTokenDecimals)(targetPoolInfo.pcToken);
            const coinDecimals = (0, tools_1.getTokenDecimals)(targetPoolInfo.coinToken);
            const pcAmount = (0, math_1.getAmountByDecimals)(targetPoolInfo.pcAmount, pcDecimals);
            const coinAmount = (0, math_1.getAmountByDecimals)(targetPoolInfo.coinAmount, coinDecimals);
            const lpA = new bignumber_js_1.default(targetPoolInfo.lpTotalSupply.toString());
            const lpAmount = lpA.div(new bignumber_js_1.default(Math.pow(10, targetPoolInfo.lpDecimals))).toNumber();
            const pcPerLP = pcAmount / lpAmount;
            const coinPerLP = coinAmount / lpAmount;
            let price = pcPerLP * pcPrice + coinPerLP * coinPrice;
            let priceAmm = 2 * pcPerLP * pcPrice;
            let coinRelativePrice = pcPerLP / coinPerLP * pcPrice;
            const tvl = (0, math_1.getAmountByDecimals)(targetPoolInfo.lpTotalSupply, targetPoolInfo.lpDecimals) * priceAmm;
            if (value.orcaPoolId.includes('[stable]')) {
                coinRelativePrice = coinPrice;
                priceAmm = price;
            }
            if (!price) {
                price = priceAmm;
            }
            info[poolKey] = Object.assign({ type: 'orca', price,
                priceAmm,
                coinRelativePrice,
                pcPerLP,
                coinPerLP,
                tvl }, targetPoolInfo);
        });
        return info;
    });
}
exports.getOrcaLPPrice = getOrcaLPPrice;
