"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRaydiumLPPrice = exports.getRaydiumLPInfo = void 0;
const BN = require("bn.js");
const lodash_1 = require("lodash");
const serum_1 = require("@project-serum/serum");
const layout_1 = require("../../constants/price/layout");
const info_1 = require("../../constants/farm/raydium/info");
const tools_1 = require("../../utils/tools");
const math_1 = require("../../utils/math");
const legacy_1 = require("../../constants/farm/raydium/legacy");
const bignumber_js_1 = require("bignumber.js");
const orca_1 = require("./orca");
const list = Object.assign(Object.assign({}, info_1.RAYDIUM_FARM_CONFIG), legacy_1.legacyInfoList);
function getRaydiumLPInfo(connection) {
    return __awaiter(this, void 0, void 0, function* () {
        const publicKeys = [];
        const poolInfo = {};
        (0, lodash_1.map)(list, (value, poolKey) => {
            var _a;
            const raydiumInfo = value.raydiumInfo;
            const key = ((_a = value) === null || _a === void 0 ? void 0 : _a.alias) || poolKey;
            const { ammOpenOrders, ammId, lpDecimals } = raydiumInfo;
            const ammPcAccount = raydiumInfo.ammUsdcAccount || raydiumInfo.ammPcAccount;
            const ammCoinAccount = raydiumInfo.ammTknAccount || raydiumInfo.ammCoinAccount;
            const lpMintAccount = value.lpMint;
            publicKeys.push({
                key: 'ammTknAccount',
                pool: key,
                value: ammCoinAccount
            }, {
                key: 'ammUsdcAccount',
                pool: key,
                value: ammPcAccount
            }, {
                key: 'ammOpenOrders',
                pool: key,
                value: ammOpenOrders
            }, {
                key: 'ammId',
                pool: key,
                value: ammId
            }, {
                key: 'lpMintAccount',
                pool: key,
                value: lpMintAccount
            });
            const [token1, token0] = poolKey.split('-');
            poolInfo[key] = {
                pcToken: token0,
                pcAmount: new BN(0),
                coinToken: token1,
                coinAmount: new BN(0),
                lpTotalSupply: new BN(0),
                lpDecimals: lpDecimals || 6
            };
        });
        const keysList = publicKeys.map(i => i.value);
        const multipleInfo = yield (0, tools_1.splitMultipleAccountsInfo)(connection, keysList);
        multipleInfo.forEach((info, index) => {
            if (info) {
                const address = keysList[index].toBase58();
                const data = Buffer.from(info.data);
                const targetKeys = (0, lodash_1.find)(publicKeys, i => i.value.toBase58() === address);
                if (targetKeys) {
                    switch (targetKeys.key) {
                        case 'ammTknAccount': {
                            const parsed = layout_1.ACCOUNT_LAYOUT.decode(data);
                            poolInfo[targetKeys.pool].coinAmount =
                                poolInfo[targetKeys.pool].coinAmount.add(new BN(parsed.amount.toString()));
                            break;
                        }
                        case 'ammUsdcAccount': {
                            const parsed = layout_1.ACCOUNT_LAYOUT.decode(data);
                            poolInfo[targetKeys.pool].pcAmount =
                                poolInfo[targetKeys.pool].pcAmount.add(new BN(parsed.amount.toString()));
                            break;
                        }
                        case 'ammOpenOrders': {
                            const OPEN_ORDERS_LAYOUT = serum_1.OpenOrders.getLayout(info_1.SERUM_PROGRAM_ID_V3);
                            const parsed = OPEN_ORDERS_LAYOUT.decode(data);
                            const { baseTokenTotal, quoteTokenTotal } = parsed;
                            poolInfo[targetKeys.pool].coinAmount =
                                poolInfo[targetKeys.pool].coinAmount.add(new BN(baseTokenTotal.toString()));
                            poolInfo[targetKeys.pool].pcAmount =
                                poolInfo[targetKeys.pool].pcAmount.add(new BN(quoteTokenTotal.toString()));
                            break;
                        }
                        case 'ammId': {
                            const parsed = layout_1.AMM_INFO_LAYOUT_V4.decode(data);
                            const { needTakePnlCoin, needTakePnlPc } = parsed;
                            poolInfo[targetKeys.pool].coinAmount =
                                poolInfo[targetKeys.pool].coinAmount.sub(new BN(needTakePnlCoin.toString()));
                            poolInfo[targetKeys.pool].pcAmount =
                                poolInfo[targetKeys.pool].pcAmount.sub(new BN(needTakePnlPc.toString()));
                            break;
                        }
                        case 'lpMintAccount': {
                            const parsed = layout_1.MINT_LAYOUT.decode(data);
                            poolInfo[targetKeys.pool].lpTotalSupply =
                                poolInfo[targetKeys.pool].lpTotalSupply.add(new BN(parsed.supply.toString()));
                            break;
                        }
                        default:
                    }
                }
            }
        });
        return poolInfo;
    });
}
exports.getRaydiumLPInfo = getRaydiumLPInfo;
function getRaydiumLPPrice(connection, priceList) {
    return __awaiter(this, void 0, void 0, function* () {
        const info = {};
        const raydiumLPInfo = yield getRaydiumLPInfo(connection);
        if (!priceList.RAY) {
            (0, orca_1.updatePrice)('RAY', priceList, raydiumLPInfo);
        }
        (0, lodash_1.forEach)(raydiumLPInfo, (value, key) => {
            if (value.pcToken === 'USDC' || value.pcToken === 'USDT') {
                if (!priceList[value.coinToken]) {
                    (0, orca_1.updatePrice)(value.coinToken, priceList, raydiumLPInfo, {
                        LPName: key
                    });
                }
            }
            if (value.pcToken === 'stSOL' && value.coinToken === 'BTC') {
                (0, orca_1.updatePrice)(value.coinToken, priceList, raydiumLPInfo, {
                    LPName: key,
                    pcPrice: priceList === null || priceList === void 0 ? void 0 : priceList.mSOL,
                    pcDecimals: 9
                });
            }
        });
        (0, lodash_1.forEach)(list, (value, poolKey) => {
            var _a;
            const key = ((_a = value) === null || _a === void 0 ? void 0 : _a.alias) || poolKey;
            const targetPoolInfo = raydiumLPInfo[key];
            if (targetPoolInfo) {
                const pcPrice = priceList[targetPoolInfo.pcToken];
                const coinPrice = priceList[targetPoolInfo.coinToken];
                const pcDecimals = (0, tools_1.getTokenDecimals)(targetPoolInfo.pcToken);
                const coinDecimals = (0, tools_1.getTokenDecimals)(targetPoolInfo.coinToken);
                const pcAmount = (0, math_1.getAmountByDecimals)(targetPoolInfo.pcAmount, pcDecimals);
                const coinAmount = (0, math_1.getAmountByDecimals)(targetPoolInfo.coinAmount, coinDecimals);
                const lpA = new bignumber_js_1.default(targetPoolInfo.lpTotalSupply.toString());
                const lpAmount = lpA.div(new bignumber_js_1.default(Math.pow(10, targetPoolInfo.lpDecimals))).toNumber();
                const pcPerLP = pcAmount / lpAmount;
                const coinPerLP = coinAmount / lpAmount;
                let price = pcPerLP * pcPrice + coinPerLP * coinPrice;
                const priceAmm = 2 * pcPerLP * pcPrice;
                const coinRelativePrice = pcPerLP / coinPerLP * pcPrice;
                const tvl = (0, math_1.getAmountByDecimals)(targetPoolInfo.lpTotalSupply, targetPoolInfo.lpDecimals) * priceAmm;
                if (!price) {
                    price = priceAmm;
                }
                info[key] = Object.assign({ type: 'raydium', price,
                    priceAmm,
                    coinRelativePrice,
                    pcPerLP,
                    coinPerLP,
                    tvl }, targetPoolInfo);
            }
        });
        return info;
    });
}
exports.getRaydiumLPPrice = getRaydiumLPPrice;
