"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unstakeReward = exports.withdraw = void 0;
const web3_js_1 = require("@solana/web3.js");
const pools_1 = require("../../constants/lend/pools");
const rewards_1 = require("../../constants/lend/rewards");
const BufferLayout = require("buffer-layout");
const spl_token_1 = require("@solana/spl-token");
const tools_1 = require("../../utils/tools");
const token_1 = require("../../utils/trx/token");
const token_instructions_1 = require("@project-serum/serum/lib/token-instructions");
const layout_1 = require("../../constants/price/layout");
const utils_1 = require("./utils");
function withdraw(connection, rewardAmount, tokenAmount, pool, userPublicKey, configs) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const targetLendInfo = pools_1.lendingPools[pool];
        if (!targetLendInfo) {
            throw new Error(`no LEND info for ${pool}`);
        }
        const hasRewards = !(configs === null || configs === void 0 ? void 0 : configs.noRewards);
        const collateraTokenMint = targetLendInfo.lendingPoolShareMint;
        const trx = new web3_js_1.Transaction();
        const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(connection, userPublicKey);
        let userTokenAccount = (_a = userParsedAccount[targetLendInfo.tokenMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
        let newAccount;
        const updateLendingIx0 = new web3_js_1.TransactionInstruction({
            keys: [
                {
                    pubkey: targetLendInfo.marketInfoAccount,
                    isWritable: true,
                    isSigner: false
                },
                {
                    pubkey: targetLendInfo.lendingPoolInfoAccount,
                    isWritable: true,
                    isSigner: false
                },
                {
                    pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                    isWritable: false,
                    isSigner: false
                }
            ],
            programId: targetLendInfo.programId,
            data: Buffer.alloc(1, 12)
        });
        trx.add(updateLendingIx0);
        if ((0, tools_1.isNativeMint)(targetLendInfo.tokenMint)) {
            const rentExemptLamports = yield connection.getMinimumBalanceForRentExemption(layout_1.ACCOUNT_LAYOUT.span);
            newAccount = web3_js_1.Keypair.generate();
            trx.add(web3_js_1.SystemProgram.createAccount({
                fromPubkey: userPublicKey,
                newAccountPubkey: newAccount.publicKey,
                lamports: rentExemptLamports,
                space: layout_1.ACCOUNT_LAYOUT.span,
                programId: spl_token_1.TOKEN_PROGRAM_ID
            }));
            trx.add((0, token_instructions_1.initializeAccount)({
                account: newAccount.publicKey,
                mint: spl_token_1.NATIVE_MINT,
                owner: userPublicKey
            }));
            userTokenAccount = newAccount.publicKey.toBase58();
        }
        if (!userTokenAccount) {
            const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.tokenMint, userPublicKey, trx);
            userTokenAccount = pk.toBase58();
        }
        let userCollateralTokenAccount = (_b = userParsedAccount[collateraTokenMint.toBase58()]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
        if (!userCollateralTokenAccount) {
            const pk = yield (0, token_1.createAssociatedTokenAccount)(collateraTokenMint, userPublicKey, trx);
            userCollateralTokenAccount = pk.toBase58();
        }
        if (hasRewards) {
            yield unstakeReward(connection, rewardAmount, pool, userPublicKey, trx, {
                userCollateralTokenAccount
            });
        }
        const keys = [
            { pubkey: new web3_js_1.PublicKey(userCollateralTokenAccount), isSigner: false, isWritable: true },
            { pubkey: new web3_js_1.PublicKey(userTokenAccount), isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.lendingPoolInfoAccount, isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.lendingPoolShareMint, isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.lendingPoolTknAccount, isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.marketInfoAccount, isSigner: false, isWritable: false },
            { pubkey: targetLendInfo.lendingMarketAuthority, isSigner: false, isWritable: false },
            { pubkey: userPublicKey, isSigner: true, isWritable: false },
            { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
        ];
        const commandDataLayout = BufferLayout.struct([
            BufferLayout.u8('instruction'),
            BufferLayout.nu64('tkn_amount')
        ]);
        let data = Buffer.alloc(1024);
        const encodeLength = commandDataLayout.encode({
            instruction: 5,
            tkn_amount: rewardAmount + tokenAmount
        }, data);
        data = data.slice(0, encodeLength);
        trx.add(new web3_js_1.TransactionInstruction({
            keys,
            programId: targetLendInfo.programId,
            data
        }));
        if ((0, tools_1.isNativeMint)(targetLendInfo.tokenMint)) {
            trx.add((0, token_instructions_1.closeAccount)({
                source: newAccount.publicKey,
                destination: userPublicKey,
                owner: userPublicKey
            }));
        }
        const signers = newAccount ? [newAccount] : null;
        return {
            trx,
            signers
        };
    });
}
exports.withdraw = withdraw;
function unstakeReward(connection, amount, pool, userPublicKey, trx, configs) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const targetLendInfo = rewards_1.lendRewardInfo[pool];
        if (!targetLendInfo) {
            throw new Error(`no LEND Reward info for ${pool}`);
        }
        const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(connection, userPublicKey);
        let userStakeTokenAccount;
        if (configs === null || configs === void 0 ? void 0 : configs.userCollateralTokenAccount) {
            userStakeTokenAccount = configs === null || configs === void 0 ? void 0 : configs.userCollateralTokenAccount;
        }
        else {
            let userStakeTokenAccount = (_a = userParsedAccount[targetLendInfo.farmingPoolStakeTknMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
            if (!userStakeTokenAccount) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.farmingPoolStakeTknMint, userPublicKey, trx);
                userStakeTokenAccount = pk.toBase58();
            }
        }
        let userRewardsAccount = (_b = userParsedAccount[targetLendInfo.farmingPoolRewardsTknMint.toBase58()]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
        if (!userRewardsAccount) {
            const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.farmingPoolRewardsTknMint, userPublicKey, trx);
            userRewardsAccount = pk.toBase58();
        }
        const userRewardsAccountB = userRewardsAccount;
        const [userFarmInfoPublicKey, nonce] = yield web3_js_1.PublicKey.findProgramAddress([
            userPublicKey.toBuffer(),
            targetLendInfo.farmingPoolAccount.toBuffer(),
            new web3_js_1.PublicKey(userStakeTokenAccount).toBuffer()
        ], targetLendInfo.programId);
        const userInfo = yield (0, utils_1.loadLendRewardUserInfo)(connection, userFarmInfoPublicKey, targetLendInfo.programId);
        let realAmount = amount;
        if (amount > (userInfo === null || userInfo === void 0 ? void 0 : userInfo.staked_amount)) {
            realAmount = ((userInfo === null || userInfo === void 0 ? void 0 : userInfo.staked_amount) || 0);
        }
        const keys = [
            { pubkey: userPublicKey, isWritable: true, isSigner: true },
            { pubkey: userFarmInfoPublicKey, isWritable: true, isSigner: false },
            { pubkey: new web3_js_1.PublicKey(userStakeTokenAccount), isWritable: true, isSigner: false },
            { pubkey: new web3_js_1.PublicKey(userRewardsAccount), isWritable: true, isSigner: false },
            { pubkey: new web3_js_1.PublicKey(userRewardsAccountB), isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolAccount, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolAuthority, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolStakeTknAccount, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolRewardsTknAccount, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolRewardsTknAccountB, isWritable: true, isSigner: false },
            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
            { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isWritable: false, isSigner: false }
        ];
        const commandDataLayout = BufferLayout.struct([
            BufferLayout.u8('instruction'),
            BufferLayout.nu64('amount')
        ]);
        let data = Buffer.alloc(1024);
        const encodeLength = commandDataLayout.encode({
            instruction: 4,
            amount: realAmount
        }, data);
        data = data.slice(0, encodeLength);
        trx.add(new web3_js_1.TransactionInstruction({
            keys,
            programId: targetLendInfo.programId,
            data
        }));
        return trx;
    });
}
exports.unstakeReward = unstakeReward;
