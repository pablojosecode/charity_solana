"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lendWithReward = exports.deposit = void 0;
const web3_js_1 = require("@solana/web3.js");
const BufferLayout = require("buffer-layout");
const token_instructions_1 = require("@project-serum/serum/lib/token-instructions");
const token_1 = require("../../utils/trx/token");
const spl_token_1 = require("@solana/spl-token");
const tools_1 = require("../../utils/tools");
const pools_1 = require("../../constants/lend/pools");
const rewards_1 = require("../../constants/lend/rewards");
const utils_1 = require("./utils");
const layout_1 = require("../../constants/price/layout");
const mintStSol_1 = require("./mintStSol");
const bn_js_1 = require("bn.js");
const SYSTEM_PROGRAM_ID = web3_js_1.SystemProgram.programId;
function deposit(connection, amount, pool, userPublicKey, configs) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const targetLendInfo = pools_1.lendingPools[pool];
        if (!targetLendInfo) {
            throw new Error(`no LEND info for ${pool}`);
        }
        const hasRewards = !(configs === null || configs === void 0 ? void 0 : configs.noRewards);
        const collateraTokenMint = targetLendInfo.lendingPoolShareMint;
        const trx = new web3_js_1.Transaction();
        const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(connection, userPublicKey);
        let userTokenAccount = (_a = userParsedAccount[targetLendInfo.tokenMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
        let newAccount;
        const updateLendingIx0 = new web3_js_1.TransactionInstruction({
            keys: [
                {
                    pubkey: targetLendInfo.marketInfoAccount,
                    isWritable: true,
                    isSigner: false
                },
                {
                    pubkey: targetLendInfo.lendingPoolInfoAccount,
                    isWritable: true,
                    isSigner: false
                },
                {
                    pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                    isWritable: false,
                    isSigner: false
                }
            ],
            programId: targetLendInfo.programId,
            data: Buffer.alloc(1, 12)
        });
        trx.add(updateLendingIx0);
        if ((0, tools_1.isNativeMint)(targetLendInfo.tokenMint)) {
            const rentExemptLamports = yield connection.getMinimumBalanceForRentExemption(layout_1.ACCOUNT_LAYOUT.span);
            newAccount = web3_js_1.Keypair.generate();
            trx.add(web3_js_1.SystemProgram.createAccount({
                fromPubkey: userPublicKey,
                newAccountPubkey: newAccount.publicKey,
                lamports: amount + rentExemptLamports,
                space: layout_1.ACCOUNT_LAYOUT.span,
                programId: spl_token_1.TOKEN_PROGRAM_ID
            }));
            trx.add((0, token_instructions_1.initializeAccount)({
                account: newAccount.publicKey,
                mint: spl_token_1.NATIVE_MINT,
                owner: userPublicKey
            }));
            userTokenAccount = newAccount.publicKey.toBase58();
        }
        let userCollateralTokenAccount = (_b = userParsedAccount[collateraTokenMint.toBase58()]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
        if (!userCollateralTokenAccount) {
            const pk = yield (0, token_1.createAssociatedTokenAccount)(collateraTokenMint, userPublicKey, trx);
            userCollateralTokenAccount = pk.toBase58();
        }
        let exchangeRate = 1;
        if (configs === null || configs === void 0 ? void 0 : configs.mintStSol) {
            if (!userTokenAccount) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.tokenMint, userPublicKey, trx);
                userTokenAccount = pk.toBase58();
            }
            const mintIx = (0, mintStSol_1.default)(userPublicKey, new web3_js_1.PublicKey(userTokenAccount), new bn_js_1.BN(amount));
            const addIx = (0, mintStSol_1.addReferral)(userPublicKey);
            trx.add(mintIx, addIx);
            exchangeRate = yield (0, mintStSol_1.getStSolExchangeRate)(connection);
        }
        const keys = [
            { pubkey: new web3_js_1.PublicKey(userTokenAccount), isSigner: false, isWritable: true },
            { pubkey: new web3_js_1.PublicKey(userCollateralTokenAccount), isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.lendingPoolInfoAccount, isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.lendingPoolTknAccount, isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.lendingPoolShareMint, isSigner: false, isWritable: true },
            { pubkey: targetLendInfo.marketInfoAccount, isSigner: false, isWritable: false },
            { pubkey: targetLendInfo.lendingMarketAuthority, isSigner: false, isWritable: false },
            { pubkey: userPublicKey, isSigner: true, isWritable: false },
            { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
        ];
        const commandDataLayout = BufferLayout.struct([
            BufferLayout.u8("instruction"),
            BufferLayout.nu64('tkn_amount')
        ]);
        let data = Buffer.alloc(1024);
        console.log(Math.trunc(amount * exchangeRate));
        const encodeLength = commandDataLayout.encode({
            instruction: 4,
            tkn_amount: (configs === null || configs === void 0 ? void 0 : configs.mintStSol) ? new bn_js_1.BN(Math.trunc(amount * exchangeRate)) : amount
        }, data);
        data = data.slice(0, encodeLength);
        trx.add(new web3_js_1.TransactionInstruction({
            keys,
            programId: targetLendInfo.programId,
            data
        }));
        if ((0, tools_1.isNativeMint)(targetLendInfo.tokenMint)) {
            trx.add((0, token_instructions_1.closeAccount)({
                source: newAccount.publicKey,
                destination: userPublicKey,
                owner: userPublicKey
            }));
        }
        if (hasRewards) {
            yield lendWithReward(connection, 0, pool, userPublicKey, trx, configs === null || configs === void 0 ? void 0 : configs.mintStSol);
        }
        const signers = newAccount ? [newAccount] : null;
        return {
            trx,
            signers
        };
    });
}
exports.deposit = deposit;
function lendWithReward(connection, amount, pool, userPublicKey, trx, mintStSol) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const targetLendInfo = rewards_1.lendRewardInfo[pool];
        if (!targetLendInfo) {
            throw new Error(`no LEND info for ${pool}`);
        }
        const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(connection, userPublicKey);
        let userStakeTokenAccount = (_a = userParsedAccount[targetLendInfo.farmingPoolStakeTknMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
        if (!userStakeTokenAccount) {
            const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.farmingPoolStakeTknMint, userPublicKey);
            userStakeTokenAccount = pk.toBase58();
        }
        let userRewardsAccount = (_b = userParsedAccount[targetLendInfo.farmingPoolRewardsTknMint.toBase58()]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
        if (!userRewardsAccount) {
            const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.farmingPoolRewardsTknMint, userPublicKey, trx);
            userRewardsAccount = pk.toBase58();
        }
        let userRewardsAccountB = userRewardsAccount;
        if (mintStSol) {
        }
        else {
            if (targetLendInfo.farmingPoolRewardsTknMintB.toBase58() !== targetLendInfo.farmingPoolRewardsTknMint.toBase58()) {
                userRewardsAccountB = (_c = userParsedAccount[targetLendInfo.farmingPoolRewardsTknMintB.toBase58()]) === null || _c === void 0 ? void 0 : _c.tokenAccountAddress;
                if (!userRewardsAccountB) {
                    const pk = yield (0, token_1.createAssociatedTokenAccount)(targetLendInfo.farmingPoolRewardsTknMintB, userPublicKey, trx);
                    userRewardsAccountB = pk.toBase58();
                }
            }
        }
        const userFarmInfoPublicKey = yield (0, utils_1.findUserLendRewardAddress)(userPublicKey, new web3_js_1.PublicKey(userStakeTokenAccount), targetLendInfo.farmingPoolAccount, targetLendInfo.programId);
        try {
            yield (0, utils_1.loadLendRewardUserInfo)(connection, userFarmInfoPublicKey, targetLendInfo.programId);
        }
        catch (err) {
            const infokeys = [
                { pubkey: userPublicKey, isWritable: true, isSigner: true },
                { pubkey: userFarmInfoPublicKey, isWritable: true, isSigner: false },
                { pubkey: targetLendInfo.farmingPoolAccount, isWritable: true, isSigner: false },
                { pubkey: new web3_js_1.PublicKey(userStakeTokenAccount), isWritable: true, isSigner: false },
                { pubkey: new web3_js_1.PublicKey(userRewardsAccount), isWritable: true, isSigner: false },
                { pubkey: new web3_js_1.PublicKey(userRewardsAccountB), isWritable: true, isSigner: false },
                { pubkey: SYSTEM_PROGRAM_ID, isWritable: false, isSigner: false },
                { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isWritable: false, isSigner: false }
            ];
            const infoCommandDataLayout = BufferLayout.struct([
                BufferLayout.u8('instruction')
            ]);
            let infodata = Buffer.alloc(1024);
            const encodeLength = infoCommandDataLayout.encode({
                instruction: 1
            }, infodata);
            infodata = infodata.slice(0, encodeLength);
            trx.add(new web3_js_1.TransactionInstruction({
                keys: infokeys,
                programId: targetLendInfo.programId,
                data: infodata
            }));
        }
        const keys = [
            { pubkey: userPublicKey, isWritable: true, isSigner: true },
            { pubkey: userFarmInfoPublicKey, isWritable: true, isSigner: false },
            { pubkey: new web3_js_1.PublicKey(userStakeTokenAccount), isWritable: true, isSigner: false },
            { pubkey: new web3_js_1.PublicKey(userRewardsAccount), isWritable: true, isSigner: false },
            { pubkey: new web3_js_1.PublicKey(userRewardsAccountB), isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolAccount, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolAuthority, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolStakeTknAccount, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolRewardsTknAccount, isWritable: true, isSigner: false },
            { pubkey: targetLendInfo.farmingPoolRewardsTknAccountB, isWritable: true, isSigner: false },
            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
            { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isWritable: false, isSigner: false }
        ];
        const commandDataLayout = BufferLayout.struct([
            BufferLayout.u8('instruction'),
            BufferLayout.nu64('amount')
        ]);
        let data = Buffer.alloc(1024);
        const encodeLength = commandDataLayout.encode({
            instruction: 3,
            amount
        }, data);
        data = data.slice(0, encodeLength);
        trx.add(new web3_js_1.TransactionInstruction({
            keys,
            programId: targetLendInfo.programId,
            data
        }));
        return trx;
    });
}
exports.lendWithReward = lendWithReward;
