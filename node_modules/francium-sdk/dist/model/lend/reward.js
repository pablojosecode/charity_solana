"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserRewardPosition = exports.getRewardPoolInfo = exports.SLOTS_PER_DAY = void 0;
const web3_js_1 = require("@solana/web3.js");
const tools_1 = require("../../utils/tools");
const pools_1 = require("../../constants/lend/pools");
const rewards_1 = require("../../constants/lend/rewards");
exports.SLOTS_PER_DAY = 24 * 60 * 60;
const poolsWithReward = pools_1.lendingPoolList.filter(i => {
    const info = rewards_1.lendRewardInfo[i.pool];
    return !!info;
});
function getRewardPoolInfo(connection) {
    return __awaiter(this, void 0, void 0, function* () {
        const accounts = poolsWithReward.map(i => {
            const info = rewards_1.lendRewardInfo[i.pool];
            return info === null || info === void 0 ? void 0 : info.farmingPoolAccount;
        });
        const accountInfos = yield connection.getMultipleAccountsInfo(accounts, 'confirmed');
        return accountInfos.map(i => {
            const buf = Buffer.from(i.data);
            const decodeData = rewards_1.RewardPoolLayout.decode(buf);
            return decodeData;
        });
    });
}
exports.getRewardPoolInfo = getRewardPoolInfo;
function getUserRewardPosition(connection, userPublicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const infoAccounts = yield Promise.all(poolsWithReward.map((i) => __awaiter(this, void 0, void 0, function* () {
            const info = rewards_1.lendRewardInfo[i.pool];
            const associatedAccount = yield (0, tools_1.findAssociatedTokenAddress)(userPublicKey, info.farmingPoolStakeTknMint);
            const [rewardInfoAccount] = yield web3_js_1.PublicKey.findProgramAddress([
                userPublicKey.toBuffer(),
                info.farmingPoolAccount.toBuffer(),
                associatedAccount.toBuffer()
            ], rewards_1.lendRewardProgramId);
            return rewardInfoAccount;
        })));
        const accountInfos = yield connection.getMultipleAccountsInfo(infoAccounts, 'confirmed');
        const result = {};
        accountInfos.forEach((i, index) => {
            if (!i) {
                const targetPool = poolsWithReward[index];
                result[targetPool.pool] = {
                    scale: targetPool.scale,
                    amount: 0
                };
            }
            else {
                const buf = Buffer.from(i.data);
                const decodeData = rewards_1.RewardUserLayout.decode(buf);
                const targetPool = poolsWithReward[index];
                result[targetPool.pool] = {
                    scale: targetPool.scale,
                    amount: (decodeData === null || decodeData === void 0 ? void 0 : decodeData.staked_amount) || 0
                };
            }
        });
        return result;
    });
}
exports.getUserRewardPosition = getUserRewardPosition;
