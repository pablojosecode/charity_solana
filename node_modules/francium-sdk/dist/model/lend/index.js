"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLendingPoolInfo = void 0;
const BN = require("bn.js");
const bignumber_js_1 = require("bignumber.js");
const math_1 = require("../../utils/math");
const pools_1 = require("../../constants/lend/pools");
function getLendingPoolInfo(connection, pools = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const lendingPoolPublicKeyList = pools.map(i => {
            const info = pools_1.lendingPools[i.pool];
            return info === null || info === void 0 ? void 0 : info.lendingPoolInfoAccount;
        });
        const accountInfos = yield connection.getMultipleAccountsInfo(lendingPoolPublicKeyList);
        const formatResults = accountInfos.map((accountInfo, index) => {
            const buf = Buffer.from(accountInfo.data);
            const decodeData = pools_1.LendingPoolLayout.decode(buf);
            const avaliableAmount = new BN(String(decodeData.liquidity_available_amount));
            const borrowedAmount = new BN(decodeData.liquidity_borrowed_amount_wads, 'le').div(new BN(10).pow(new BN(18)));
            const totalShareMintSupply = new BN(decodeData.share_mint_total_supply, 'le');
            const totalAmount = avaliableAmount.add(borrowedAmount);
            const utilization = totalAmount.gtn(0) ?
                new bignumber_js_1.default(borrowedAmount.toString()).dividedBy(totalAmount.toString()).toNumber() : 0;
            const aprData = {
                threshold1: decodeData.threshold_1,
                threshold2: decodeData.threshold_2,
                base1: decodeData.base_1,
                factor1: decodeData.factor_1,
                base2: decodeData.base_2,
                factor2: decodeData.factor_2,
                base3: decodeData.base_3,
                factor3: decodeData.factor_3,
            };
            const { borrowInterest, apr, apy } = (0, math_1.getAprInfo)(utilization, aprData);
            return {
                pool: pools[index].pool,
                scale: pools[index].scale || 6,
                avaliableAmount,
                borrowedAmount,
                totalAmount,
                utilization,
                totalShareMintSupply,
                borrowInterest,
                apr,
                apy,
                aprData
            };
        });
        return formatResults;
    });
}
exports.getLendingPoolInfo = getLendingPoolInfo;
