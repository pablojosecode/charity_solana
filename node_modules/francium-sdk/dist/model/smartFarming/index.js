"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FranciumSmartFarming = void 0;
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const pools_1 = require("../../constants/smartLending/pools");
const pools_2 = require("../../constants/smartFarming/raydium/pools");
const idl_1 = require("../../constants/smartLending/idl");
const token_1 = require("../../utils/trx/token");
const spl_token_1 = require("@solana/spl-token");
const pools_3 = require("../../constants/lend/pools");
const lodash_1 = require("lodash");
const math_1 = require("../../utils/math");
const pools_4 = require("../../constants/smartFarming/orca/pools");
const tools_1 = require("../../utils/tools");
const rewards_1 = require("../smartLending/rewards");
const info_1 = require("../smartLending/info");
const SMART_FARMING_PROGRAM_ID = new web3_js_1.PublicKey('FrcmhqyyRF7GragBtVfSW7HcKtZB4fkPorN1U4MGaQKr');
class FranciumSmartFarming {
    constructor(config) {
        this.idl = idl_1.default;
        this.config = {
            raydium: pools_2.raydiumSmartFarmingPools,
            orca: pools_4.orcaSmartFarmingPools
        };
        this.connection = config.connection;
        const commitment = 'confirmed';
        this.program = new anchor_1.Program(this.idl, SMART_FARMING_PROGRAM_ID, new anchor_1.Provider(this.connection, null, {
            skipPreflight: true,
            commitment,
            preflightCommitment: commitment
        }));
    }
    getAllPoolStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const accountList = [...pools_2.activeSmartFarmingRaydiumPools, ...pools_4.activeSmartFarmingOrcaPools].map(i => i.poolInfoAccount);
            const info = yield this.program.account.poolInfo.fetchMultiple(accountList);
            return [...pools_2.activeSmartFarmingRaydiumPools, ...pools_4.activeSmartFarmingOrcaPools].map((i, index) => {
                const poolInfo = info[index];
                const maxCapacityLimit = (0, math_1.getAmountByDecimals)(poolInfo.stakeInfo.maxCapacityLimit, i.lpDecimals);
                const currentAmount = (0, math_1.getAmountByDecimals)(poolInfo.stakeInfo.totalLiquidity, i.lpDecimals);
                const rewardInfo = (0, info_1.formatSmartPoolRewardsInfo)(poolInfo.rewardsInfoArr);
                return {
                    pool: i.pool,
                    poolInfoAccount: i.poolInfoAccount,
                    decimals: i.lpDecimals,
                    platform: i.platform,
                    alias: i.alias,
                    info: poolInfo,
                    maxCapacityLimit,
                    currentAmount,
                    rewardInfo
                };
            });
        });
    }
    getUserPositions(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let accountInfos = [];
            try {
                accountInfos = yield this.connection.getProgramAccounts(this.program.programId, {
                    filters: [
                        {
                            dataSize: 408
                        },
                        {
                            memcmp: {
                                offset: 8 + 8 + 1,
                                bytes: userPublicKey.toBase58()
                            }
                        },
                    ]
                });
            }
            catch (e) {
                console.log(e);
            }
            const res = accountInfos.map(e => {
                return {
                    publicKey: e.pubkey,
                    account: this.program.coder.accounts.decode('UserInfo', e.account.data)
                };
            });
            return res;
        });
    }
    getFormattedUserPositions(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const allPoolStatus = yield this.getAllPoolStatus();
            let user = [];
            if (!userPublicKey) {
            }
            else {
                const userPositions = yield this.getUserPositions(userPublicKey);
                const positions = userPositions.map(i => {
                    var _a, _b, _c, _d, _e, _f, _g, _h;
                    const targetPoolStatus = (0, lodash_1.find)(allPoolStatus, poolInfo => {
                        var _a, _b, _c;
                        return ((_a = poolInfo.poolInfoAccount) === null || _a === void 0 ? void 0 : _a.toBase58()) === ((_c = (_b = i.account) === null || _b === void 0 ? void 0 : _b.poolInfo) === null || _c === void 0 ? void 0 : _c.toBase58());
                    });
                    if (targetPoolStatus) {
                        const [token1, token0] = targetPoolStatus.pool.split('-');
                        const token0Decimals = (0, tools_1.getTokenDecimals)(token0);
                        const token1Decimals = (0, tools_1.getTokenDecimals)(token1);
                        const poolPerShare = (0, math_1.toBigNumber)((_b = (_a = targetPoolStatus.info) === null || _a === void 0 ? void 0 : _a.stakeInfo) === null || _b === void 0 ? void 0 : _b.totalShares).gt(0) ?
                            (0, math_1.toBigNumber)((_d = (_c = targetPoolStatus.info) === null || _c === void 0 ? void 0 : _c.stakeInfo) === null || _d === void 0 ? void 0 : _d.totalLiquidity).dividedBy((0, math_1.toBigNumber)((_f = (_e = targetPoolStatus.info) === null || _e === void 0 ? void 0 : _e.stakeInfo) === null || _f === void 0 ? void 0 : _f.totalShares)).toNumber()
                            : 0;
                        const userLP = (0, math_1.getAmountByDecimals)(i.account.stakeInfo.shareAmount, targetPoolStatus.decimals) * poolPerShare +
                            (0, math_1.getAmountByDecimals)(i.account.farmInfo.pendingWithdrawLp, targetPoolStatus.decimals);
                        const poolBorrowRate0 = (0, math_1.toBigNumber)((_g = targetPoolStatus === null || targetPoolStatus === void 0 ? void 0 : targetPoolStatus.info) === null || _g === void 0 ? void 0 : _g.farmInfo.accumulatedBorrowRate0);
                        const userBorrowRate0 = (0, math_1.toBigNumber)(i.account.farmInfo.accumulatedBorrowRate0);
                        const poolBorrowRate1 = (0, math_1.toBigNumber)((_h = targetPoolStatus === null || targetPoolStatus === void 0 ? void 0 : targetPoolStatus.info) === null || _h === void 0 ? void 0 : _h.farmInfo.accumulatedBorrowRate1);
                        const userBorrowRate1 = (0, math_1.toBigNumber)(i.account.farmInfo.accumulatedBorrowRate1);
                        const userPendingRepay0 = (0, math_1.toBigNumber)(i.account.farmInfo.pendingRepay0);
                        const userPendingRepay1 = (0, math_1.toBigNumber)(i.account.farmInfo.pendingRepay1);
                        const userBorrowed0 = (0, math_1.getAmountByDecimals)((0, math_1.toBigNumber)(i.account.farmInfo.borrowed0).plus(userPendingRepay0).multipliedBy(poolBorrowRate0).dividedBy(userBorrowRate0), token0Decimals);
                        const userBorrowed1 = (0, math_1.getAmountByDecimals)((0, math_1.toBigNumber)(i.account.farmInfo.borrowed1).plus(userPendingRepay1).multipliedBy(poolBorrowRate1).dividedBy(userBorrowRate1), token1Decimals);
                        const userBaseToken0 = (0, math_1.getAmountByDecimals)(i.account.farmInfo.principle0, token0Decimals);
                        const userBaseToken1 = (0, math_1.getAmountByDecimals)(i.account.farmInfo.principle1, token1Decimals);
                        const userToken0Count = (0, math_1.getAmountByDecimals)(i.account.farmInfo.tokenAmount0, token0Decimals);
                        const userToken1Count = (0, math_1.getAmountByDecimals)(i.account.farmInfo.tokenAmount1, token1Decimals);
                        const userPrinciple0 = (0, math_1.getAmountByDecimals)(i.account.farmInfo.principle0, token0Decimals);
                        const userPrinciple1 = (0, math_1.getAmountByDecimals)(i.account.farmInfo.principle1, token1Decimals);
                        const pendingRewards = (0, rewards_1.userPendingRewards)(i.account, targetPoolStatus.info);
                        return Object.assign(Object.assign({}, targetPoolStatus), { userInfoPublicKey: i.publicKey, info: i.account, token0,
                            token1, formatData: {
                                pendingRewards,
                                userLPShares: i.account.stakeInfo.shareAmount,
                                userLP,
                                userBorrowed0,
                                userBorrowed1,
                                userBaseToken0,
                                userBaseToken1,
                                userToken0Count,
                                userToken1Count,
                                userPrinciple0,
                                userPrinciple1
                            } });
                    }
                });
                user = (0, lodash_1.sortBy)(positions.filter(i => !!i), [i => {
                        return i.pool;
                    }, i => {
                        return i.userInfoPublicKey.toBase58();
                    }]);
            }
            return {
                pool: allPoolStatus,
                user,
            };
        });
    }
    withdraw(userPublicKey, poolName, platform, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetInfo = this.config[platform || 'raydium'][poolName];
            const userInfoAccount = configs.userInfoAccount;
            const trx1 = new web3_js_1.Transaction();
            const trx2 = new web3_js_1.Transaction();
            const trx3 = new web3_js_1.Transaction();
            const trx4 = new web3_js_1.Transaction();
            const [userToken0Account, userToken1Account, userRewardAccount] = yield this.initUserAccount(userPublicKey, targetInfo, trx1);
            if (platform === 'raydium') {
                const ixList = this.unStakeFarmPosition(userPublicKey, userInfoAccount, targetInfo, userRewardAccount, configs.shareAmount, configs.withdrawType);
                trx2.add(...ixList);
                const unpackIx = this.unpackLpToTokens(userPublicKey, userInfoAccount, targetInfo);
                const withdrawIx = this.swapAndWithdraw(userPublicKey, userInfoAccount, targetInfo, userToken0Account, userToken1Account);
                trx3.add(unpackIx, withdrawIx);
            }
            else if (platform === 'orca') {
                const ixList = this.unStakeFarmPositionOrca(userPublicKey, userInfoAccount, targetInfo, userRewardAccount, configs.shareAmount, configs.withdrawType);
                trx2.add(...ixList);
                const unpackIx = this.unpackLpToTokensOrca(userPublicKey, userInfoAccount, targetInfo);
                const withdrawIx = this.swapAndWithdrawOrca(userPublicKey, userInfoAccount, targetInfo, userToken0Account, userToken1Account);
                trx3.add(unpackIx, withdrawIx);
            }
            const closeIx = this.closeUserInfo(userPublicKey, targetInfo.smartPoolInfo.poolInfoAccount, userInfoAccount);
            trx3.add(closeIx);
            const repayIxList = this.repay(userPublicKey, userInfoAccount, targetInfo);
            trx4.add(...repayIxList);
            if (trx1.instructions.length) {
                return [trx1, trx2, trx3, trx4];
            }
            else {
                return [trx2, trx3, trx4];
            }
        });
    }
    deposit(userPublicKey, poolName, platform, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetInfo = this.config[platform || 'raydium'][poolName];
            const trx1 = new web3_js_1.Transaction();
            const trx2 = new web3_js_1.Transaction();
            const trx3 = new web3_js_1.Transaction();
            const trx4 = new web3_js_1.Transaction();
            let userInfoAccount = configs.userInfoAccount;
            if (userInfoAccount) {
            }
            else {
                const [initUserInfoAccount, ix1] = yield this.initUserInfo(userPublicKey, targetInfo);
                userInfoAccount = initUserInfoAccount;
                trx1.add(ix1);
            }
            const [userToken0Account, userToken1Account, userRewardAccount] = yield this.initUserAccount(userPublicKey, targetInfo, trx1);
            const transferIx = yield this.transfer(userPublicKey, userInfoAccount, targetInfo, {
                amount0: configs.amount0,
                amount1: configs.amount1,
                userToken0Account,
                userToken1Account
            });
            trx2.add(...transferIx);
            const borrowIxList = yield this.borrow(userPublicKey, userInfoAccount, targetInfo, platform, {
                borrow0: configs.borrow0,
                borrow1: configs.borrow1
            });
            trx2.add(...borrowIxList);
            if (platform === 'raydium') {
                const swapIx = this.swapForBalance(userPublicKey, userInfoAccount, targetInfo);
                trx3.add(swapIx);
                const addLiquidityIx = this.addLiquidity(userPublicKey, userInfoAccount, targetInfo, userRewardAccount);
                trx3.add(addLiquidityIx);
                const stakeVaultIx = this.stakeToVault(userPublicKey, userInfoAccount, targetInfo);
                trx4.add(stakeVaultIx);
            }
            else if (platform === 'orca') {
                const swapIx = this.swapForBalanceOrca(userPublicKey, userInfoAccount, targetInfo);
                trx3.add(swapIx);
                const addLiquidityIx = this.addLiquidityOrca(userPublicKey, userInfoAccount, targetInfo, userRewardAccount);
                trx3.add(addLiquidityIx);
                const stakeVaultIxList = this.stakeToVaultOrca(userPublicKey, userInfoAccount, targetInfo);
                trx4.add(...stakeVaultIxList);
            }
            if (trx1.instructions.length) {
                return [trx1, trx2, trx3, trx4];
            }
            else {
                return [trx2, trx3, trx4];
            }
        });
    }
    initUserInfo(userPublicKey, targetLendInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTime = Date.now();
            const userNonce = new anchor_1.BN(currentTime);
            const userInfoSeed = 'user_info'.split('').map(e => e.charCodeAt(0));
            const [userInfoAccount, userBump] = yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from(userInfoSeed),
                targetLendInfo.smartPoolInfo.poolInfoAccount.toBuffer(),
                userPublicKey.toBuffer(),
                userNonce.toArrayLike(Buffer, 'le', 8)
            ], SMART_FARMING_PROGRAM_ID);
            const ix = yield this.program.instruction.initializeUser(userNonce, userBump, {
                accounts: {
                    userMainAccount: userPublicKey,
                    marketInfo: pools_1.smartPoolMarketInfo.marketInfoAccount,
                    liquidityTokenMint: targetLendInfo.smartPoolInfo.liquidityTokenMint,
                    poolInfo: targetLendInfo.smartPoolInfo.poolInfoAccount,
                    userInfo: userInfoAccount,
                    systemProgram: web3_js_1.SystemProgram.programId
                }
            });
            return [
                userInfoAccount,
                ix
            ];
        });
    }
    initUserAccount(userPublicKey, targetFarmInfo, trx) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(this.connection, userPublicKey);
            let userToken0Account = (_a = userParsedAccount[targetFarmInfo.basedLendingInfo[0].tknMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
            let userToken1Account = (_b = userParsedAccount[targetFarmInfo.basedLendingInfo[1].tknMint.toBase58()]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
            let userRewardAccount = (_c = userParsedAccount[targetFarmInfo.smartPoolInfo.rewardsTokenMint.toBase58()]) === null || _c === void 0 ? void 0 : _c.tokenAccountAddress;
            if ((0, tools_1.isNativeMint)(targetFarmInfo.smartPoolInfo.tokenMint0)) {
                userToken0Account = (_d = userParsedAccount[spl_token_1.NATIVE_MINT.toBase58()]) === null || _d === void 0 ? void 0 : _d.tokenAccountAddress;
            }
            else if ((0, tools_1.isNativeMint)(targetFarmInfo.smartPoolInfo.tokenMint1)) {
                userToken1Account = (_e = userParsedAccount[spl_token_1.NATIVE_MINT.toBase58()]) === null || _e === void 0 ? void 0 : _e.tokenAccountAddress;
            }
            else {
            }
            if (!userToken0Account) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetFarmInfo.basedLendingInfo[0].tknMint, userPublicKey, trx);
                userToken0Account = pk.toBase58();
                if (targetFarmInfo.smartPoolInfo.rewardsTokenMint.toBase58() !== targetFarmInfo.basedLendingInfo[0].tknMint.toBase58()) {
                    userRewardAccount = userToken0Account;
                }
            }
            if (!userToken1Account) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetFarmInfo.basedLendingInfo[1].tknMint, userPublicKey, trx);
                userToken1Account = pk.toBase58();
                if (targetFarmInfo.smartPoolInfo.rewardsTokenMint.toBase58() !== targetFarmInfo.basedLendingInfo[1].tknMint.toBase58()) {
                    userRewardAccount = userToken1Account;
                }
            }
            if (!userRewardAccount &&
                targetFarmInfo.smartPoolInfo.rewardsTokenMint.toBase58() !== targetFarmInfo.basedLendingInfo[0].tknMint.toBase58() &&
                targetFarmInfo.smartPoolInfo.rewardsTokenMint.toBase58() !== targetFarmInfo.basedLendingInfo[1].tknMint.toBase58()) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetFarmInfo.smartPoolInfo.rewardsTokenMint, userPublicKey, trx);
                userRewardAccount = pk.toBase58();
            }
            return [userToken0Account, userToken1Account, userRewardAccount];
        });
    }
    transfer(userPublicKey, userInfoAccount, targetInfo, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const { amount0, amount1, userToken0Account, userToken1Account } = configs;
            const ixList = [];
            if ((0, tools_1.isNativeMint)(targetInfo.smartPoolInfo.tokenMint0)) {
                if (amount0.gtn(0)) {
                    const instructions = this.transferToWSOL(amount0, new web3_js_1.PublicKey(userToken0Account), userPublicKey);
                    ixList.push(...instructions);
                }
            }
            else if ((0, tools_1.isNativeMint)(targetInfo.smartPoolInfo.tokenMint1)) {
                if (amount1.gtn(0)) {
                    const instructions = this.transferToWSOL(amount1, new web3_js_1.PublicKey(userToken1Account), userPublicKey);
                    ixList.push(...instructions);
                }
            }
            else {
            }
            const ix = this.program.instruction.transferTokensToFarm(amount0, amount1, {
                accounts: {
                    userMainAccount: userPublicKey,
                    userInfo: userInfoAccount,
                    poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                    poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                    userTokenAccount0: userToken0Account,
                    poolTokenAccount0: targetInfo.smartPoolInfo.tokenAccount0,
                    userTokenAccount1: userToken1Account,
                    poolTokenAccount1: targetInfo.smartPoolInfo.tokenAccount1,
                    poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                    tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
                }
            });
            ixList.push(ix);
            return ixList;
        });
    }
    transferToWSOL(amount, WSOLAccount, userPublicKey) {
        const ins1 = web3_js_1.SystemProgram.transfer({
            fromPubkey: userPublicKey,
            toPubkey: WSOLAccount,
            lamports: Number(amount.toString())
        });
        const ins2 = new web3_js_1.TransactionInstruction({
            keys: [
                { pubkey: WSOLAccount, isSigner: false, isWritable: true }
            ],
            programId: spl_token_1.TOKEN_PROGRAM_ID,
            data: Buffer.from([17]),
        });
        return [ins1, ins2];
    }
    borrow(userPublicKey, userInfoAccount, targetInfo, platform, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const { borrow0, borrow1 } = configs;
            const ix0 = this.program.instruction.updateLendingPool(0, {
                accounts: {
                    poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                    poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                    lendingProgramId: pools_3.lendProgramId,
                    lendingPoolId0: targetInfo.basedLendingInfo['0'].lendingPoolInfoAccount,
                    lendingPoolId1: targetInfo.basedLendingInfo['1'].lendingPoolInfoAccount,
                }
            });
            const ix1 = yield this.program.instruction.updateLendingPool(1, {
                accounts: {
                    poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                    poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                    lendingProgramId: pools_3.lendProgramId,
                    lendingPoolId0: targetInfo.basedLendingInfo['0'].lendingPoolInfoAccount,
                    lendingPoolId1: targetInfo.basedLendingInfo['1'].lendingPoolInfoAccount,
                }
            });
            const ixList = [ix0, ix1];
            if (borrow0.gt(new anchor_1.BN(0))) {
                if (platform === 'raydium') {
                    const ixb0 = this.buildBorrowIx(userPublicKey, userInfoAccount, targetInfo, 0, borrow0);
                    ixList.push(ixb0);
                }
                else if (platform === 'orca') {
                    const ixb0 = this.buildBorrowIxOrca(userPublicKey, userInfoAccount, targetInfo, 0, borrow0);
                    ixList.push(ixb0);
                }
            }
            if (borrow1.gt(new anchor_1.BN(0))) {
                if (platform === 'raydium') {
                    const ixb1 = this.buildBorrowIx(userPublicKey, userInfoAccount, targetInfo, 1, borrow1);
                    ixList.push(ixb1);
                }
                else if (platform === 'orca') {
                    const ixb1 = this.buildBorrowIxOrca(userPublicKey, userInfoAccount, targetInfo, 1, borrow1);
                    ixList.push(ixb1);
                }
            }
            return ixList;
        });
    }
    swapForBalance(userPublicKey, userInfoAccount, targetInfo) {
        const ix = this.program.instruction.swapForBalance({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetInfo.smartPoolInfo.tokenAccount1,
                ammId: targetInfo.basedFarmInfo.ammInfo.ammId,
                ammOpenOrders: targetInfo.basedFarmInfo.ammInfo.ammOpenOrders,
                ammTknAccount0: targetInfo.basedFarmInfo.ammInfo.ammPcAccount,
                ammTknAccount1: targetInfo.basedFarmInfo.ammInfo.ammCoinAccount,
                lpMintAccount: targetInfo.smartPoolInfo.liquidityTokenMint,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: targetInfo.basedFarmInfo.ammInfo.raydiumProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammOpenOrders, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammTargetOrders, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammCoinAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammPcAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumMarketId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumBids, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumAsks, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumEventQueue, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumCoinVault, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumPCVault, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumVaultSigner, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
            ]
        });
        return ix;
    }
    swapForBalanceOrca(userPublicKey, userInfoAccount, targetInfo) {
        const ix = this.program.instruction.swapForBalance({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetInfo.smartPoolInfo.tokenAccount1,
                ammId: targetInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammOpenOrders: targetInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammTknAccount0: targetInfo.basedFarmInfo.ammInfo.swapTknVault0,
                ammTknAccount1: targetInfo.basedFarmInfo.ammInfo.swapTknVault1,
                lpMintAccount: targetInfo.smartPoolInfo.liquidityTokenMint,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapProgramId, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapPoolId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapPoolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapTknVault0, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapTknVault1, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenMint, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapFeeAccount, isSigner: false, isWritable: true },
            ]
        });
        return ix;
    }
    addLiquidity(userPublicKey, userInfoAccount, targetInfo, userRewardAccount) {
        const ix = this.program.instruction.addTokensToLiquidity({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetInfo.smartPoolInfo.liquidityTokenAccount,
                ammId: targetInfo.basedFarmInfo.ammInfo.ammId,
                ammOpenOrders: targetInfo.basedFarmInfo.ammInfo.ammOpenOrders,
                ammTknAccount0: targetInfo.basedFarmInfo.ammInfo.ammPcAccount,
                ammTknAccount1: targetInfo.basedFarmInfo.ammInfo.ammCoinAccount,
                lpMintAccount: targetInfo.smartPoolInfo.liquidityTokenMint,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.raydiumProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammOpenOrders, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammTargetOrders, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenMint, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammCoinAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.ammPcAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.serumMarketId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
            ]
        });
        return ix;
    }
    addLiquidityOrca(userPublicKey, userInfoAccount, targetInfo, userRewardAccount) {
        const ix = this.program.instruction.addTokensToLiquidity({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetInfo.smartPoolInfo.liquidityTokenAccount,
                ammId: targetInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammOpenOrders: targetInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammTknAccount0: targetInfo.basedFarmInfo.ammInfo.swapTknVault0,
                ammTknAccount1: targetInfo.basedFarmInfo.ammInfo.swapTknVault1,
                lpMintAccount: targetInfo.smartPoolInfo.liquidityTokenMint,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapProgramId, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapPoolId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapPoolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapTknVault0, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.swapTknVault1, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenMint, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
            ]
        });
        return ix;
    }
    stakeToVault(userPublicKey, userInfoAccount, targetInfo) {
        const ix = this.program.instruction.vaultStake({
            accounts: {
                invoker: userPublicKey,
                marketInfo: pools_1.smartPoolMarketInfo.marketInfoAccount,
                liquidityTokenMint: targetInfo.smartPoolInfo.liquidityTokenMint,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolLiquidityTokenAccount: targetInfo.smartPoolInfo.liquidityTokenAccount
            },
            remainingAccounts: [
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.farmInfoAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolLpAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.basedRewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolRewardAccount, isSigner: false, isWritable: true },
                { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.basedRewardsTokenAccountB, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolRewardAccountB, isSigner: false, isWritable: true },
            ]
        });
        return ix;
    }
    stakeToVaultOrca(userPublicKey, userInfoAccount, targetInfo) {
        const ixList = [];
        const ix1 = this.program.instruction.vaultStake({
            accounts: {
                invoker: userPublicKey,
                marketInfo: pools_1.smartPoolMarketInfo.marketInfoAccount,
                liquidityTokenMint: targetInfo.smartPoolInfo.liquidityTokenMint,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolLiquidityTokenAccount: targetInfo.smartPoolInfo.liquidityTokenAccount
            },
            remainingAccounts: [
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakeProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolBaseTokenVault, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolFarmTknMint, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.farmTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolFarmInfo, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.farmInfoAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolRewardsTknVault, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.basedRewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolAuthority, isSigner: false, isWritable: true },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ]
        });
        ixList.push(ix1);
        if (targetInfo.basedFarmInfo.rewardsAmmInfoB) {
            const ix2 = this.program.instruction.vaultStake({
                accounts: {
                    invoker: userPublicKey,
                    marketInfo: pools_1.smartPoolMarketInfo.marketInfoAccount,
                    liquidityTokenMint: targetInfo.smartPoolInfo.liquidityTokenMint,
                    poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                    poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                    poolLiquidityTokenAccount: targetInfo.smartPoolInfo.farmTokenAccount
                },
                remainingAccounts: [
                    { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfoB.stakeProgramId, isSigner: false, isWritable: false },
                    { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.farmTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfoB.stakePoolBaseTokenVault, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfoB.stakePoolFarmTknMint, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.farmTokenAccountB, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfoB.stakePoolFarmInfo, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.farmInfoAccountB, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfoB.stakePoolRewardsTknVault, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.basedRewardsTokenAccountB, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfoB.stakePoolAuthority, isSigner: false, isWritable: true },
                    { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ]
            });
            ixList.push(ix2);
        }
        return ixList;
    }
    buildBorrowIx(userPublicKey, userInfoAccount, targetInfo, index, amount) {
        const remainingAccounts = this.getBorrowRemainingAccounts(targetInfo, index);
        const ix = this.program.instruction.borrowTokensFromLendingPool(index, amount, {
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                ammId: targetInfo.basedFarmInfo.ammInfo.ammId,
                ammOpenOrders: targetInfo.basedFarmInfo.ammInfo.ammOpenOrders,
                ammTknAccount0: targetInfo.basedFarmInfo.ammInfo.ammPcAccount,
                ammTknAccount1: targetInfo.basedFarmInfo.ammInfo.ammCoinAccount,
                lpMintAccount: targetInfo.smartPoolInfo.liquidityTokenMint,
                lendingProgramId: pools_3.lendProgramId,
                lendingMarket: pools_1.lendingPoolMarketInfo.marketInfoAccount,
                lendingPoolId0: targetInfo.basedLendingInfo['0'].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo['1'].lendingPoolInfoAccount,
                sysClock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                ...remainingAccounts
            ]
        });
        return ix;
    }
    buildBorrowIxOrca(userPublicKey, userInfoAccount, targetInfo, index, amount) {
        const ix = this.program.instruction.borrowTokensFromLendingPool(index, amount, {
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                ammId: targetInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammOpenOrders: targetInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammTknAccount0: targetInfo.basedFarmInfo.ammInfo.swapTknVault0,
                ammTknAccount1: targetInfo.basedFarmInfo.ammInfo.swapTknVault1,
                lpMintAccount: targetInfo.smartPoolInfo.liquidityTokenMint,
                lendingProgramId: pools_3.lendProgramId,
                lendingMarket: pools_1.lendingPoolMarketInfo.marketInfoAccount,
                lendingPoolId0: targetInfo.basedLendingInfo["0"].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo["1"].lendingPoolInfoAccount,
                sysClock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: pools_3.lendProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedLendingInfo[index].lendingPoolTknAccount, isSigner: false, isWritable: true },
                {
                    pubkey: index === 0 ? targetInfo.smartPoolInfo.tokenAccount0 : targetInfo.smartPoolInfo.tokenAccount1,
                    isSigner: false, isWritable: true
                },
                {
                    pubkey: index === 0 ? targetInfo.smartPoolInfo.borrowCreditTokenAccount0 : targetInfo.smartPoolInfo.borrowCreditTokenAccount1,
                    isSigner: false, isWritable: true
                },
                { pubkey: targetInfo.basedLendingInfo[index].lendingPoolCreditAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedLendingInfo[index].lendingPoolInfoAccount, isSigner: false, isWritable: true },
                { pubkey: pools_1.lendingPoolMarketInfo.marketInfoAccount, isSigner: false, isWritable: true },
                { pubkey: pools_1.lendingPoolMarketInfo.marketAuthority, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ]
        });
        return ix;
    }
    getBorrowRemainingAccounts(targetInfo, index) {
        switch (index) {
            case 0: {
                return [
                    { pubkey: pools_3.lendProgramId, isSigner: false, isWritable: false },
                    { pubkey: targetInfo.basedLendingInfo['0'].lendingPoolTknAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.borrowCreditTokenAccount0, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedLendingInfo['0'].lendingPoolCreditAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedLendingInfo['0'].lendingPoolInfoAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.lendingPoolMarketInfo.marketInfoAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.lendingPoolMarketInfo.marketAuthority, isSigner: false, isWritable: false },
                    { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                    { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                    { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ];
            }
            case 1: {
                return [
                    { pubkey: pools_3.lendProgramId, isSigner: false, isWritable: false },
                    { pubkey: targetInfo.basedLendingInfo['1'].lendingPoolTknAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.borrowCreditTokenAccount1, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedLendingInfo['1'].lendingPoolCreditAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.basedLendingInfo['1'].lendingPoolInfoAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.lendingPoolMarketInfo.marketInfoAccount, isSigner: false, isWritable: true },
                    { pubkey: pools_1.lendingPoolMarketInfo.marketAuthority, isSigner: false, isWritable: false },
                    { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                    { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                    { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ];
            }
        }
    }
    unStakeFarmPosition(userPublicKey, userInfoAccount, targetInfo, userRewardAccount, shareAmount, withdrawType) {
        const ix0 = this.program.instruction.updateLendingPool(0, {
            accounts: {
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                lendingProgramId: pools_3.lendProgramId,
                lendingPoolId0: targetInfo.basedLendingInfo['0'].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo['1'].lendingPoolInfoAccount,
            }
        });
        const ix1 = this.program.instruction.updateLendingPool(1, {
            accounts: {
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                lendingProgramId: pools_3.lendProgramId,
                lendingPoolId0: targetInfo.basedLendingInfo['0'].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo['1'].lendingPoolInfoAccount,
            }
        });
        const ix2 = this.program.instruction.unStakeFarmPositionWithType(shareAmount, withdrawType, {
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolLpAccount: targetInfo.smartPoolInfo.liquidityTokenAccount,
                lendingPoolId0: targetInfo.basedLendingInfo['0'].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo['1'].lendingPoolInfoAccount,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolId, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.farmInfoAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolLpAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.basedRewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolRewardAccount, isSigner: false, isWritable: true },
                { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.basedRewardsTokenAccountB, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.ammInfo.stakePoolRewardAccountB, isSigner: false, isWritable: true },
            ]
        });
        return [ix0, ix1, ix2];
    }
    unStakeFarmPositionOrca(userPublicKey, userInfoAccount, targetInfo, userRewardAccount, shareAmount, withdrawType) {
        const ix0 = this.program.instruction.updateLendingPool(0, {
            accounts: {
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                lendingProgramId: pools_3.lendProgramId,
                lendingPoolId0: targetInfo.basedLendingInfo["0"].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo["1"].lendingPoolInfoAccount,
            }
        });
        const ix1 = this.program.instruction.updateLendingPool(1, {
            accounts: {
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                lendingProgramId: pools_3.lendProgramId,
                lendingPoolId0: targetInfo.basedLendingInfo["0"].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo["1"].lendingPoolInfoAccount,
            }
        });
        const ix2 = this.program.instruction.unStakeFarmPositionWithType(shareAmount, withdrawType, {
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetInfo.smartPoolInfo.vaultManagerAccount,
                poolLpAccount: targetInfo.smartPoolInfo.liquidityTokenAccount,
                lendingPoolId0: targetInfo.basedLendingInfo["0"].lendingPoolInfoAccount,
                lendingPoolId1: targetInfo.basedLendingInfo["1"].lendingPoolInfoAccount,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakeProgramId, isSigner: false, isWritable: false },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolBaseTokenVault, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolFarmTknMint, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.farmTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolFarmInfo, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.farmInfoAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolRewardsTknVault, isSigner: false, isWritable: true },
                { pubkey: targetInfo.smartPoolInfo.basedRewardsTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetInfo.basedFarmInfo.rewardsAmmInfo.stakePoolAuthority, isSigner: false, isWritable: true },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ]
        });
        return [ix0, ix1, ix2];
    }
    unpackLpToTokens(userPublicKey, userInfoAccount, targetFarmInfo) {
        const ix = this.program.instruction.unpackLpToTokens({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetFarmInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetFarmInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetFarmInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetFarmInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetFarmInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetFarmInfo.smartPoolInfo.liquidityTokenAccount,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.raydiumProgramId, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammId, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammAuthority, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammOpenOrders, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammTargetOrders, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.liquidityTokenMint, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammCoinAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammPcAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.poolWithdrawQueue, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.poolTempLpTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumProgramId, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumMarketId, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumCoinVault, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumPCVault, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumVaultSigner, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumEventQueue, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumBids, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumAsks, isSigner: false, isWritable: true },
            ]
        });
        return ix;
    }
    unpackLpToTokensOrca(userPublicKey, userInfoAccount, targetFarmInfo) {
        const ix = this.program.instruction.unpackLpToTokens({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetFarmInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetFarmInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetFarmInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetFarmInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetFarmInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetFarmInfo.smartPoolInfo.liquidityTokenAccount,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapProgramId, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapPoolId, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapPoolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapTknVault0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapTknVault1, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.liquidityTokenMint, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.liquidityTokenAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapFeeAccount, isSigner: false, isWritable: true },
            ]
        });
        return ix;
    }
    swapAndWithdraw(userPublicKey, userInfoAccount, targetFarmInfo, userTokenAccount0, userTokenAccount1) {
        const ix = this.program.instruction.swapAndWithdraw({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetFarmInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetFarmInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetFarmInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetFarmInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetFarmInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetFarmInfo.smartPoolInfo.liquidityTokenAccount,
                userTokenAccount0: userTokenAccount0,
                userTokenAccount1: userTokenAccount1,
                ammId: targetFarmInfo.basedFarmInfo.ammInfo.ammId,
                ammOpenOrders: targetFarmInfo.basedFarmInfo.ammInfo.ammOpenOrders,
                ammTknAccount0: targetFarmInfo.basedFarmInfo.ammInfo.ammPcAccount,
                ammTknAccount1: targetFarmInfo.basedFarmInfo.ammInfo.ammCoinAccount,
                lpMintAccount: targetFarmInfo.smartPoolInfo.liquidityTokenMint,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.raydiumProgramId, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammId, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammAuthority, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammOpenOrders, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammTargetOrders, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammCoinAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.ammPcAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumProgramId, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumMarketId, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumBids, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumAsks, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumEventQueue, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumCoinVault, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumPCVault, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.serumVaultSigner, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
            ]
        });
        return ix;
    }
    swapAndWithdrawOrca(userPublicKey, userInfoAccount, targetFarmInfo, userTokenAccount0, userTokenAccount1) {
        const ix = this.program.instruction.swapAndWithdraw({
            accounts: {
                userMainAccount: userPublicKey,
                userInfo: userInfoAccount,
                poolInfo: targetFarmInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetFarmInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetFarmInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetFarmInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetFarmInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetFarmInfo.smartPoolInfo.liquidityTokenAccount,
                userTokenAccount0: userTokenAccount0,
                userTokenAccount1: userTokenAccount1,
                ammId: targetFarmInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammOpenOrders: targetFarmInfo.basedFarmInfo.ammInfo.swapPoolId,
                ammTknAccount0: targetFarmInfo.basedFarmInfo.ammInfo.swapTknVault0,
                ammTknAccount1: targetFarmInfo.basedFarmInfo.ammInfo.swapTknVault1,
                lpMintAccount: targetFarmInfo.smartPoolInfo.liquidityTokenMint,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapProgramId, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapPoolId, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapPoolAuthority, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapTknVault0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapTknVault1, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.liquidityTokenMint, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedFarmInfo.ammInfo.swapFeeAccount, isSigner: false, isWritable: true },
            ]
        });
        return ix;
    }
    repay(userPublicKey, userInfoAccount, targetFarmInfo) {
        const ix0 = this.program.instruction.repayTokensToLendingPool(0, {
            accounts: {
                userMainAccount: userPublicKey,
                poolInfo: targetFarmInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetFarmInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetFarmInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetFarmInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetFarmInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetFarmInfo.smartPoolInfo.liquidityTokenAccount,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: pools_3.lendProgramId, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['0'].lendingPoolTknAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.borrowCreditTokenAccount0, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['0'].lendingPoolCreditMint, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['0'].lendingPoolCreditAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['0'].lendingPoolInfoAccount, isSigner: false, isWritable: true },
                { pubkey: pools_1.lendingPoolMarketInfo.marketInfoAccount, isSigner: false, isWritable: true },
                { pubkey: pools_1.lendingPoolMarketInfo.marketAuthority, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ]
        });
        const ix1 = this.program.instruction.repayTokensToLendingPool(1, {
            accounts: {
                userMainAccount: userPublicKey,
                poolInfo: targetFarmInfo.smartPoolInfo.poolInfoAccount,
                poolAuthority: targetFarmInfo.smartPoolInfo.poolAuthority,
                poolVaultManager: targetFarmInfo.smartPoolInfo.vaultManagerAccount,
                poolTokenAccount0: targetFarmInfo.smartPoolInfo.tokenAccount0,
                poolTokenAccount1: targetFarmInfo.smartPoolInfo.tokenAccount1,
                poolLpAccount: targetFarmInfo.smartPoolInfo.liquidityTokenAccount,
                tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: [
                { pubkey: pools_3.lendProgramId, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.tokenAccount1, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['1'].lendingPoolTknAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.smartPoolInfo.borrowCreditTokenAccount1, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['1'].lendingPoolCreditMint, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['1'].lendingPoolCreditAccount, isSigner: false, isWritable: true },
                { pubkey: targetFarmInfo.basedLendingInfo['1'].lendingPoolInfoAccount, isSigner: false, isWritable: true },
                { pubkey: pools_1.lendingPoolMarketInfo.marketInfoAccount, isSigner: false, isWritable: true },
                { pubkey: pools_1.lendingPoolMarketInfo.marketAuthority, isSigner: false, isWritable: false },
                { pubkey: targetFarmInfo.smartPoolInfo.poolAuthority, isSigner: false, isWritable: false },
                { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ]
        });
        return [ix0, ix1];
    }
    closeUserInfo(userPublicKey, poolInfo, userInfoAccount) {
        const ix = this.program.instruction.closeUserInfo({
            accounts: {
                userMainAccount: userPublicKey,
                poolInfo: poolInfo,
                userInfo: userInfoAccount
            }
        });
        return ix;
    }
    claimRewards(userPublicKey, platform, poolName, userInfoAccount) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const trx = new web3_js_1.Transaction();
            const targetInfo = this.config[platform || 'raydium'][poolName];
            const userParsedAccount = yield (0, token_1.getParsedTokenAccounts)(this.connection, userPublicKey);
            let userRewardAccount = (_a = userParsedAccount[targetInfo.smartPoolInfo.rewardsTokenMint.toBase58()]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
            if (!userRewardAccount) {
                const pk = yield (0, token_1.createAssociatedTokenAccount)(targetInfo.smartPoolInfo.rewardsTokenMint, userPublicKey, trx);
                userRewardAccount = pk.toBase58();
            }
            const ix = this.program.instruction.harvest({
                accounts: {
                    userMainAccount: userPublicKey,
                    userInfo: userInfoAccount,
                    poolInfo: targetInfo.smartPoolInfo.poolInfoAccount,
                    poolAuthority: targetInfo.smartPoolInfo.poolAuthority,
                    tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID
                },
                remainingAccounts: [
                    { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: userRewardAccount, isSigner: false, isWritable: true },
                    { pubkey: targetInfo.smartPoolInfo.rewardsTokenAccount, isSigner: false, isWritable: true },
                ]
            });
            trx.add(ix);
            return trx;
        });
    }
}
exports.FranciumSmartFarming = FranciumSmartFarming;
