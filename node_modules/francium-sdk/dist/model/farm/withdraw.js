"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const anchor_1 = require("@project-serum/anchor");
const token_1 = require("../../utils/trx/token");
const token_instructions_1 = require("@project-serum/serum/lib/token-instructions");
const tools_1 = require("../../utils/tools");
const setUnit_1 = require("../../utils/trx/setUnit");
function buildWithdrawTransactions(connection, pair, lyfType, userPublicKey, farm, configs) {
    return __awaiter(this, void 0, void 0, function* () {
        return withdrawLP(connection, pair, lyfType, userPublicKey, configs.lpShares, {
            withdrawType: configs.withdrawType,
            currentUserInfoAccount: configs.currentUserInfoAccount
        });
        function unstakeLP(connection, pair, lyfType, userPublicKey, lpShares, withdrawType, configs) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const trx = new web3_js_1.Transaction();
                trx.add(setUnit_1.default);
                const targetFarmInfo = farm.getConfig(pair, lyfType);
                if (!targetFarmInfo) {
                    throw new Error(`no farm info for ${pair}`);
                }
                const program = farm.getProgram(lyfType);
                let userInfoAccount = configs.currentUserInfoAccount;
                const updateLendingIx0 = new web3_js_1.TransactionInstruction({
                    keys: [
                        {
                            pubkey: targetFarmInfo.lendingPoolConfig.marketInfoAccount,
                            isWritable: true,
                            isSigner: false
                        },
                        {
                            pubkey: targetFarmInfo.lendingPoolConfig["0"].lendingPoolInfoAccount,
                            isWritable: true,
                            isSigner: false
                        },
                        {
                            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                            isWritable: false,
                            isSigner: false
                        }
                    ],
                    programId: targetFarmInfo.lendingPoolConfig.programId,
                    data: Buffer.alloc(1, 12)
                });
                const updateLendingIx1 = new web3_js_1.TransactionInstruction({
                    keys: [
                        {
                            pubkey: targetFarmInfo.lendingPoolConfig.marketInfoAccount,
                            isWritable: true,
                            isSigner: false
                        },
                        {
                            pubkey: targetFarmInfo.lendingPoolConfig["1"].lendingPoolInfoAccount,
                            isWritable: true,
                            isSigner: false
                        },
                        {
                            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                            isWritable: false,
                            isSigner: false
                        }
                    ],
                    programId: targetFarmInfo.lendingPoolConfig.programId,
                    data: Buffer.alloc(1, 12)
                });
                trx.add(updateLendingIx0, updateLendingIx1);
                if (!userInfoAccount) {
                    userInfoAccount = yield program.account.userInfo.associatedAddress(userPublicKey, targetFarmInfo.strategyAccount);
                }
                if ((_a = targetFarmInfo === null || targetFarmInfo === void 0 ? void 0 : targetFarmInfo.ammInfo) === null || _a === void 0 ? void 0 : _a.doubleDipPool) {
                    const doubleDipParams = farm.getOrcaDoubleDipUnstakeParams(targetFarmInfo);
                    const doubleDipInstruction = program.instruction.doubleDipUnstakeFarmTkn(new anchor_1.BN(lpShares.toFixed(0)), doubleDipParams[0]);
                    trx.add(doubleDipInstruction);
                }
                const upstakeLpParams = farm.getUnstakeLpParams(targetFarmInfo, userPublicKey, userInfoAccount, lyfType);
                const unstakeInstruction = program.instruction.unstakeLpWithType({
                    withdrawType,
                    sharesAmount: new anchor_1.BN(lpShares.toFixed(0))
                }, upstakeLpParams[0]);
                trx.add(unstakeInstruction);
                return trx;
            });
        }
        function swapAndWithdraw(connection, pair, lyfType, userPublicKey, withdrawType, configs) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                const trxPre = new web3_js_1.Transaction();
                const trx = new web3_js_1.Transaction();
                trx.add(setUnit_1.default);
                const targetFarmInfo = farm.getConfig(pair, lyfType);
                if (!targetFarmInfo) {
                    throw new Error(`no farm info for ${pair}`);
                }
                const program = farm.getProgram(lyfType);
                let userInfoAccount = configs.currentUserInfoAccount;
                if (!userInfoAccount) {
                    userInfoAccount = yield program.account.userInfo.associatedAddress(userPublicKey, targetFarmInfo.strategyAccount);
                }
                const parsedTokenAccounts = yield (0, token_1.getParsedTokenAccounts)(connection, userPublicKey);
                let userTknAccount0 = (_a = parsedTokenAccounts[targetFarmInfo.tknMint0]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
                let userTknAccount1 = (_b = parsedTokenAccounts[targetFarmInfo.tknMint1]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
                if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint0)) {
                    userTknAccount0 = (_c = parsedTokenAccounts[spl_token_1.NATIVE_MINT.toBase58()]) === null || _c === void 0 ? void 0 : _c.tokenAccountAddress;
                }
                else if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint1)) {
                    userTknAccount1 = (_d = parsedTokenAccounts[spl_token_1.NATIVE_MINT.toBase58()]) === null || _d === void 0 ? void 0 : _d.tokenAccountAddress;
                }
                else {
                }
                if (!userTknAccount0) {
                    userTknAccount0 = (yield (0, token_1.createAssociatedTokenAccount)(targetFarmInfo.tknMint0, userPublicKey, trxPre)).toBase58();
                }
                if (!userTknAccount1) {
                    userTknAccount1 = (yield (0, token_1.createAssociatedTokenAccount)(targetFarmInfo.tknMint1, userPublicKey, trxPre)).toBase58();
                }
                const removeLiquidityParams = farm.getRemoveLiquidityParams(targetFarmInfo, userPublicKey, userInfoAccount, lyfType);
                const removeLiquidityInstruction = program.instruction.removeLiquidity(removeLiquidityParams[0]);
                trx.add(removeLiquidityInstruction);
                if (lyfType === 'orca' && targetFarmInfo.protocolSubVersion === 2) {
                    const ix1 = yield program.instruction.beforeStableWithdraw({
                        withdrawType
                    }, {
                        accounts: {
                            userMainAccount: userPublicKey,
                            userInfoAccount: userInfoAccount,
                            strategyState: targetFarmInfo.strategyAccount,
                            tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
                            ammProgramId: targetFarmInfo.ammInfo.swapProgramId,
                            swapPoolId: targetFarmInfo.ammInfo.swapPoolId,
                            swapPoolAuthority: targetFarmInfo.ammInfo.swapPoolAuthority,
                            swapPoolTkn0: targetFarmInfo.ammInfo.swapTknVault0,
                            swapPoolTkn1: targetFarmInfo.ammInfo.swapTknVault1,
                            swapPoolFeeTkn: targetFarmInfo.ammInfo.swapFeeAccount,
                            lpMint: targetFarmInfo.ammInfo.lpMint
                        }
                    });
                    const swapAndWithdrawParams = farm.getSwapAndWithdrawParams(targetFarmInfo, userPublicKey, userInfoAccount, new web3_js_1.PublicKey(userTknAccount0), new web3_js_1.PublicKey(userTknAccount1), lyfType);
                    const ix2 = yield program.instruction.stableSwap({
                        withdrawType
                    }, ...swapAndWithdrawParams);
                    const ix3 = yield program.instruction.stableWithdraw({
                        accounts: {
                            userMainAccount: userPublicKey,
                            userInfo: userInfoAccount,
                            userTknAccount0: userTknAccount0,
                            userTknAccount1: userTknAccount1,
                            strategyState: targetFarmInfo.strategyAccount,
                            strategyAuthority: targetFarmInfo.strategyAuthority,
                            strategyTknAccount0: targetFarmInfo.strategyTknAccount0,
                            strategyTknAccount1: targetFarmInfo.strategyTknAccount1,
                            strategyLpTknAccount: targetFarmInfo.strategyLpTknAccount,
                            tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
                        }
                    });
                    trx.add(ix1, ix2, ix3);
                    if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint0)) {
                        trx.add((0, token_instructions_1.closeAccount)({
                            source: new web3_js_1.PublicKey(userTknAccount0),
                            destination: userPublicKey,
                            owner: userPublicKey
                        }));
                    }
                    else if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint1)) {
                        trx.add((0, token_instructions_1.closeAccount)({
                            source: new web3_js_1.PublicKey(userTknAccount1),
                            destination: userPublicKey,
                            owner: userPublicKey
                        }));
                    }
                }
                else {
                    const swapAndWithdrawParams = farm.getSwapAndWithdrawParams(targetFarmInfo, userPublicKey, userInfoAccount, new web3_js_1.PublicKey(userTknAccount0), new web3_js_1.PublicKey(userTknAccount1), lyfType);
                    const swapAndWithdrawInstruction = yield program.instruction.swapAndWithdraw({
                        withdrawType
                    }, ...swapAndWithdrawParams);
                    const closeEmptyInstruction = yield program.instruction.closeEmptyAccount({
                        accounts: {
                            userMainAccount: userPublicKey,
                            userInfoAccount: userInfoAccount
                        }
                    });
                    trx.add(swapAndWithdrawInstruction);
                    trx.add(closeEmptyInstruction);
                    if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint0)) {
                        trx.add((0, token_instructions_1.closeAccount)({
                            source: new web3_js_1.PublicKey(userTknAccount0),
                            destination: userPublicKey,
                            owner: userPublicKey
                        }));
                    }
                    else if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint1)) {
                        trx.add((0, token_instructions_1.closeAccount)({
                            source: new web3_js_1.PublicKey(userTknAccount1),
                            destination: userPublicKey,
                            owner: userPublicKey
                        }));
                    }
                }
                return {
                    closedAccount: (0, tools_1.isNativeMint)(targetFarmInfo.tknMint0) ? userTknAccount0 :
                        (0, tools_1.isNativeMint)(targetFarmInfo.tknMint1) ? userTknAccount1 : '',
                    trx,
                    trxPre
                };
            });
        }
        function autoRepay(connection, pair, lyfType, userPublicKey) {
            return __awaiter(this, void 0, void 0, function* () {
                const trx = new web3_js_1.Transaction();
                const targetFarmInfo = farm.getConfig(pair, lyfType);
                if (!targetFarmInfo) {
                    throw new Error(`no farm info for ${pair}`);
                }
                const program = farm.getProgram(lyfType);
                const repayParams = farm.getRepayParams(targetFarmInfo, userPublicKey, lyfType);
                const repayBorrowedCoinInstruction = program.instruction.repayBorrowedCoin(repayParams[0]);
                const repayBorrowedPcInstruction = program.instruction.repayBorrowedPc(repayParams[0]);
                trx.add(repayBorrowedCoinInstruction, repayBorrowedPcInstruction);
                return trx;
            });
        }
        function withdrawLP(connection, pair, lyfType, userPublicKey, lpShares, configs) {
            return __awaiter(this, void 0, void 0, function* () {
                const trx1 = yield unstakeLP(connection, pair, lyfType, userPublicKey, lpShares, configs.withdrawType, {
                    currentUserInfoAccount: configs.currentUserInfoAccount
                });
                const { closedAccount, trx: trx2, trxPre } = yield swapAndWithdraw(connection, pair, lyfType, userPublicKey, configs.withdrawType, {
                    currentUserInfoAccount: configs.currentUserInfoAccount
                });
                const trx3 = yield autoRepay(connection, pair, lyfType, userPublicKey);
                if (trxPre.instructions.length) {
                    return {
                        closedAccount,
                        trxs: [trxPre, trx1, trx2, trx3]
                    };
                }
                return {
                    closedAccount,
                    trxs: [trx1, trx2, trx3]
                };
            });
        }
    });
}
exports.default = buildWithdrawTransactions;
