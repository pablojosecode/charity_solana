"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const token_1 = require("../../utils/trx/token");
const spl_token_1 = require("@solana/spl-token");
const BN = require("bn.js");
const tools_1 = require("../../utils/tools");
const setUnit_1 = require("../../utils/trx/setUnit");
const SYSTEM_PROGRAM_ID = web3_js_1.SystemProgram.programId;
function buildFarmTransactions(connection, pair, lyfType, userPublicKey, farm, configs) {
    return __awaiter(this, void 0, void 0, function* () {
        return stakeWithLeverage(connection, pair, lyfType, userPublicKey, configs);
        function stakeWithLeverage(connection, pair, lyfType, userPublicKey, configs) {
            return __awaiter(this, void 0, void 0, function* () {
                const { amount0, amount1, borrow0, borrow1, stopLoss, currentUserInfoAccount } = configs;
                const { trxPre, trx: trx1, currentUserInfoAccount: preUserInfoAccount } = yield investAndBorrow(connection, pair, lyfType || 'raydium', userPublicKey, {
                    tokenAmount0: amount0,
                    tokenAmount1: amount1,
                    borrow0,
                    borrow1,
                    stopLoss,
                    currentUserInfoAccount
                });
                const trx2 = yield swapAndAddLiquidity(connection, pair, lyfType || 'raydium', userPublicKey, {
                    currentUserInfoAccount: preUserInfoAccount
                });
                const trx3 = yield stakeLP(connection, pair, lyfType || 'raydium');
                if (trxPre.instructions.length) {
                    return [trxPre, trx1, trx2, trx3];
                }
                else {
                    return [trx1, trx2, trx3];
                }
            });
        }
        function investAndBorrow(connection, pair, lyfType, userPublicKey, configs) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                const { stopLoss, borrow0, borrow1, tokenAmount0, tokenAmount1, currentUserInfoAccount, noNonce } = configs;
                const trxPre = new web3_js_1.Transaction();
                const trx = new web3_js_1.Transaction();
                trx.add(setUnit_1.default);
                const targetFarmInfo = farm.getConfig(pair, lyfType);
                if (!targetFarmInfo) {
                    throw new Error(`no farm info for ${pair}`);
                }
                const parsedTokenAccounts = yield (0, token_1.getParsedTokenAccounts)(connection, userPublicKey);
                let userTknAccount0 = (_a = parsedTokenAccounts[targetFarmInfo.tknMint0]) === null || _a === void 0 ? void 0 : _a.tokenAccountAddress;
                let userTknAccount1 = (_b = parsedTokenAccounts[targetFarmInfo.tknMint1]) === null || _b === void 0 ? void 0 : _b.tokenAccountAddress;
                if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint0)) {
                    userTknAccount0 = (_c = parsedTokenAccounts[spl_token_1.NATIVE_MINT.toBase58()]) === null || _c === void 0 ? void 0 : _c.tokenAccountAddress;
                }
                else if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint1)) {
                    userTknAccount1 = (_d = parsedTokenAccounts[spl_token_1.NATIVE_MINT.toBase58()]) === null || _d === void 0 ? void 0 : _d.tokenAccountAddress;
                }
                else {
                }
                if (!userTknAccount0) {
                    userTknAccount0 = (yield (0, token_1.createAssociatedTokenAccount)(targetFarmInfo.tknMint0, userPublicKey, trxPre)).toBase58();
                }
                if (!userTknAccount1) {
                    userTknAccount1 = (yield (0, token_1.createAssociatedTokenAccount)(targetFarmInfo.tknMint1, userPublicKey, trxPre)).toBase58();
                }
                const program = farm.getProgram(lyfType);
                const strategyAccount = targetFarmInfo.strategyAccount;
                let userInfoAccount = currentUserInfoAccount;
                function initUserInfoByNonce(nonce) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const nonceLeBytes = Buffer.from([0, 0, 0, 0]);
                        nonceLeBytes.writeUInt32LE(nonce);
                        userInfoAccount = yield program.account.userInfo.associatedAddress(userPublicKey, strategyAccount, nonceLeBytes);
                        const [pda, bump] = yield web3_js_1.PublicKey.findProgramAddress([
                            Buffer.from([97, 110, 99, 104, 111, 114]),
                            userPublicKey.toBuffer(),
                            targetFarmInfo.strategyAccount.toBuffer(),
                            nonceLeBytes
                        ], program.programId);
                        const initInstruction = yield program.instruction.initializeUserWithNonce(nonce, bump, {
                            accounts: {
                                userMainAccount: userPublicKey,
                                userInfoAccount: userInfoAccount,
                                strategyState: targetFarmInfo.strategyAccount,
                                systemProgram: SYSTEM_PROGRAM_ID,
                                clock: web3_js_1.SYSVAR_CLOCK_PUBKEY
                            }
                        });
                        return initInstruction;
                    });
                }
                function initUserInfoWithoutNonce() {
                    return __awaiter(this, void 0, void 0, function* () {
                        userInfoAccount = yield program.account.userInfo.associated(userPublicKey, strategyAccount);
                        const initInstruction = yield program.instruction.initializeUser({
                            accounts: {
                                userMainAccount: userPublicKey,
                                userInfoAccount: userInfoAccount,
                                strategyState: targetFarmInfo.strategyAccount,
                                systemProgram: SYSTEM_PROGRAM_ID,
                                clock: web3_js_1.SYSVAR_CLOCK_PUBKEY
                            }
                        });
                        return initInstruction;
                    });
                }
                if (!currentUserInfoAccount) {
                    if (noNonce) {
                        const initInstruction = yield initUserInfoWithoutNonce();
                        trxPre.add(initInstruction);
                    }
                    else {
                        const initInstruction = yield initUserInfoByNonce(Math.trunc(Date.now() / 1000));
                        trxPre.add(initInstruction);
                    }
                }
                function transferToWSOL(amount, WSOLAccount, userPublicKey) {
                    const ins1 = web3_js_1.SystemProgram.transfer({
                        fromPubkey: userPublicKey,
                        toPubkey: WSOLAccount,
                        lamports: Number(amount.toString())
                    });
                    const ins2 = new web3_js_1.TransactionInstruction({
                        keys: [
                            { pubkey: WSOLAccount, isSigner: false, isWritable: true }
                        ],
                        programId: spl_token_1.TOKEN_PROGRAM_ID,
                        data: Buffer.from([17]),
                    });
                    return [ins1, ins2];
                }
                if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint0)) {
                    if (tokenAmount0.gtn(0)) {
                        const instructions = transferToWSOL(tokenAmount0, new web3_js_1.PublicKey(userTknAccount0), userPublicKey);
                        trx.add(...instructions);
                    }
                }
                else if ((0, tools_1.isNativeMint)(targetFarmInfo.tknMint1)) {
                    if (tokenAmount1.gtn(0)) {
                        const instructions = transferToWSOL(tokenAmount1, new web3_js_1.PublicKey(userTknAccount1), userPublicKey);
                        trx.add(...instructions);
                    }
                }
                else {
                }
                const transferInstruction = yield program.instruction.transfer({
                    stopLoss,
                    amount0: new BN(tokenAmount0),
                    amount1: new BN(tokenAmount1)
                }, {
                    accounts: {
                        userMainAccount: userPublicKey,
                        userInfoAccount: userInfoAccount,
                        userTknAccount0: userTknAccount0,
                        userTknAccount1: userTknAccount1,
                        strategyState: targetFarmInfo.strategyAccount,
                        strategyAuthority: targetFarmInfo.strategyAuthority,
                        strategyTknAccount0: targetFarmInfo.strategyTknAccount0,
                        strategyTknAccount1: targetFarmInfo.strategyTknAccount1,
                        tokenProgramId: spl_token_1.TOKEN_PROGRAM_ID,
                        clock: web3_js_1.SYSVAR_CLOCK_PUBKEY
                    }
                });
                const borrowAccounts = farm.getBorrowParams(targetFarmInfo, userPublicKey, userInfoAccount, lyfType);
                const borrowInsList = [];
                if (borrow0.gtn(0)) {
                    const borrowInstruction0 = yield program.instruction.borrow({
                        borrow0: new BN(borrow0),
                        borrow1: new BN(0)
                    }, ...borrowAccounts);
                    borrowInsList.push(borrowInstruction0);
                }
                if (borrow1.gtn(0)) {
                    const borrowInstruction1 = yield program.instruction.borrow({
                        borrow0: new BN(0),
                        borrow1: new BN(borrow1)
                    }, ...borrowAccounts);
                    borrowInsList.push(borrowInstruction1);
                }
                trx.add(transferInstruction);
                if (borrowInsList.length) {
                    trx.add(...borrowInsList);
                }
                return {
                    trxPre,
                    trx,
                    currentUserInfoAccount: userInfoAccount
                };
            });
        }
        function swapAndAddLiquidity(connection, pair, lyfType, userPublicKey, configs) {
            return __awaiter(this, void 0, void 0, function* () {
                const trx = new web3_js_1.Transaction();
                trx.add(setUnit_1.default);
                const targetFarmInfo = farm.getConfig(pair, lyfType);
                if (!targetFarmInfo) {
                    throw new Error(`no farm info for ${pair}`);
                }
                if (lyfType === 'orca' && targetFarmInfo.protocolSubVersion === 2) {
                    const program = farm.getProgram(lyfType);
                    const userInfoAccount = configs.currentUserInfoAccount;
                    const liquidityParams = farm.getLiquidityParams(targetFarmInfo, userPublicKey, userInfoAccount, lyfType);
                    const addLiquidityInstruction = yield program.instruction.addLiquidity(...liquidityParams);
                    const singleSideInstruction = yield program.instruction.addLiquiditySigleSide(...liquidityParams);
                    trx.add(addLiquidityInstruction, singleSideInstruction);
                }
                else {
                    const program = farm.getProgram(lyfType);
                    const userInfoAccount = configs.currentUserInfoAccount;
                    const swapParams = farm.getSwapParams(targetFarmInfo, userPublicKey, userInfoAccount, lyfType);
                    const swapInstruction = yield program.instruction.swap(...swapParams);
                    const liquidityParams = farm.getLiquidityParams(targetFarmInfo, userPublicKey, userInfoAccount, lyfType);
                    const addLiquidityInstruction = yield program.instruction.addLiquidity(...liquidityParams);
                    trx.add(swapInstruction, addLiquidityInstruction);
                }
                return trx;
            });
        }
        function stakeLP(connection, pair, lyfType) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const trx = new web3_js_1.Transaction();
                trx.add(setUnit_1.default);
                const targetFarmInfo = farm.getConfig(pair, lyfType);
                if (!targetFarmInfo) {
                    throw new Error(`no farm info for ${pair}`);
                }
                const program = farm.getProgram(lyfType);
                const stakeLpParams = farm.getStakeLpParams(targetFarmInfo, lyfType);
                const stakeLPInstruction = yield program.instruction.stakeLp(...stakeLpParams);
                trx.add(stakeLPInstruction);
                if ((_a = targetFarmInfo === null || targetFarmInfo === void 0 ? void 0 : targetFarmInfo.ammInfo) === null || _a === void 0 ? void 0 : _a.doubleDipPool) {
                    const doubleDipParams = farm.getOrcaDoubleDipStakeParams(targetFarmInfo);
                    const doubleDipInstruction = program.instruction.doubleDipStakeFarmTkn(...doubleDipParams);
                    trx.add(doubleDipInstruction);
                }
                return trx;
            });
        }
    });
}
exports.default = buildFarmTransactions;
