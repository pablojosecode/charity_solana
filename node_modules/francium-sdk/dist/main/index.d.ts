import { Connection, Keypair, PublicKey, Transaction } from '@solana/web3.js';
import { FranciumFarm } from '../model';
import BigNumber from 'bignumber.js';
import * as BN from 'bn.js';
export declare class FranciumSDK {
    connection: Connection;
    farmHub: FranciumFarm;
    private farmPools;
    private getTokenPrice;
    tokenPrice: any;
    tokenPriceOnChain: {
        [token: string]: number;
    };
    constructor(config: {
        connection: Connection;
        getTokenPrice?: () => Promise<{
            [token: string]: number;
        }>;
    });
    updateConnection(connection: Connection): void;
    getLendingDepositTransaction(pool: string, amount: BN, userPublicKey: PublicKey, configs: {
        noRewards?: boolean;
        mintStSol?: boolean;
    }): Promise<{
        trx: Transaction;
        signers: Keypair[];
    }>;
    getLendWithdrawTransaction(pool: string, rewardAmount: number, tokenAmount: number, userPublicKey: PublicKey, configs: {
        noRewards?: boolean;
    }): Promise<{
        trx: Transaction;
        signers: Keypair[];
    }>;
    getRepayTransactions(pair: string, lyfType: string, userPublicKey: PublicKey, configs: {
        amount0: BN;
        amount1: BN;
        currentUserInfoAccount: PublicKey;
    }): Promise<Transaction>;
    getFarmTransactions(pair: string, lyfType: string, userPublicKey: PublicKey, configs: {
        depositPcAmount: BN;
        depositCoinAmount: BN;
        borrowPcAmount: BN;
        borrowCoinAmount: BN;
        stopLoss?: number;
        currentUserInfoAccount?: PublicKey;
    }): Promise<Transaction[]>;
    getFarmSwapPoolId(pair: string, platform: string): any;
    getClosePositionTransactions(pair: string, lyfType: string, userPublicKey: PublicKey, configs: {
        lpShares: BN;
        withdrawType: number;
        currentUserInfoAccount: PublicKey;
    }): Promise<Transaction[]>;
    sendSingleTransaction(trx: Transaction, wallet: any, signers?: Keypair[]): Promise<{
        txid: string;
        response: import("@solana/web3.js").RpcResponseAndContext<import("@solana/web3.js").SignatureResult>;
    }>;
    sendMultipleTransactions(trxs: Transaction[], wallet: any, onTrxSended?: (index: number, txid: string) => void, onTrxConfirmed?: (index: number, txid: string, stateInfo?: {
        state: string;
        msg: string;
        total?: number;
        signature?: string;
    }) => void): Promise<{
        state: string;
        msg: string;
        total: number;
    }[]>;
    getTokenPriceInfo(): Promise<{
        tokenPrice: any;
    }>;
    getOnchainPriceList(): Promise<{
        [token: string]: number;
    }>;
    getFarmLPPriceInfo(): Promise<{
        [x: string]: import("../model/price/types").FormatLPInfo;
    }>;
    getLendingPoolInfo(): Promise<{
        pool: string;
        scale: number;
        avaliableAmount: BN;
        borrowedAmount: BN;
        totalAmount: BN;
        utilization: number;
        totalShareMintSupply: BN;
        borrowInterest: number;
        apr: number;
        apy: number;
        aprData: {
            threshold1: any;
            threshold2: any;
            base1: any;
            factor1: any;
            base2: any;
            factor2: any;
            base3: any;
            factor3: any;
        };
    }[]>;
    getFarmPoolInfo(): Promise<any[]>;
    getUserFarmPositionByProgram(userPublicKey: PublicKey): Promise<{
        orca: {
            publicKey: PublicKey;
            data: any;
        }[];
        raydium: {
            publicKey: PublicKey;
            data: any;
        }[];
    }>;
    getUserFarmPosition(userPublicKey: PublicKey): Promise<{
        id: any;
        lpAmount: BN;
        lpShares: any;
        priceKey: any;
        lpDecimals: any;
        userInfoPublicKey: PublicKey;
        pcMint: any;
        coinMint: any;
        borrowed: {
            symbol: any;
            amount: BN;
            mint: any;
        }[];
        type: any;
    }[]>;
    getUserFormattedFarmPosition(userPublicKey: PublicKey): Promise<{
        id: any;
        lpAmount: BN;
        lpShares: BN;
        priceKey: any;
        lpDecimals: any;
        userInfo: any;
        userInfoPublicKey: PublicKey;
        pcMint: any;
        coinMint: any;
        borrowed: {
            symbol: any;
            amount: BN;
            mint: any;
        }[];
        totalPositionValue: number;
        debtValue: number;
        equityValue: number;
        type: any;
    }[]>;
    getUserLendingPosition(userPublicKey: PublicKey): Promise<{
        pool: string;
        scale: number;
        rewardPosition: any;
        balancePosition: any;
        totalPosition: any;
        totalAmount: number;
    }[]>;
    getFarmPoolTVL(): Promise<{
        id: any;
        lpAmount: number;
        liquidityLocked: number;
    }[]>;
    getLendingPoolTVL(): Promise<{
        id: string;
        apy: number;
        borrowApr: number;
        liquidityLocked: number;
        available: number;
        price: any;
        totalAmount: number;
        availableAmount: number;
    }[]>;
    getRebalanceInfo(userPublicKey: PublicKey, positionPublicKey: string, leverage?: number): Promise<{
        poolInfo: {
            token0: string;
            token1: string;
            lyfType: string;
        };
        rebalanceOptions: {
            option1: {
                depositPcAmount: number;
                depositCoinAmount: number;
                borrowPcAmount: number;
                borrowCoinAmount: number;
                stopLoss: number;
            };
            option2: {
                lpSharesToWithdraw: BigNumber;
                borrowPcAmountAfterWithdraw?: number;
                borrowCoinAmountAfterWithdraw?: number;
                stopLoss: number;
            };
        };
    }>;
    getRebalanceTransactions(userPublicKey: PublicKey, positionPublicKey: string): Promise<Transaction[]>;
    sendRebalanceTransactions(userPublicKey: PublicKey, positionPublicKey: string, wallet: any, onTrxSended?: (index: number, txid: string) => void, onTrxConfirmed?: (index: number, txid: string, stateInfo?: {
        state: string;
        msg: string;
        total?: number;
        signature?: string;
    }) => void): Promise<void | {
        state: string;
        msg: string;
        total: number;
    }[]>;
}
