"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FranciumSDK = void 0;
const web3_js_1 = require("@solana/web3.js");
const pools_1 = require("../constants/lend/pools");
const farm_1 = require("../constants/farm");
const model_1 = require("../model");
const bignumber_js_1 = require("bignumber.js");
const farm_2 = require("../utils/formatters/farm");
const math_1 = require("../utils/math");
const lodash_1 = require("lodash");
const BN = require("bn.js");
const farm_3 = require("../model/farm/farm");
const withdraw_1 = require("../model/farm/withdraw");
const sign_1 = require("../utils/sign");
const rebalance_1 = require("../utils/rebalance");
const tools_1 = require("../utils/tools");
const deposit_1 = require("../model/lend/deposit");
const withdraw_2 = require("../model/lend/withdraw");
const repay_1 = require("../model/farm/repay");
const index_1 = require("../index");
class FranciumSDK {
    constructor(config) {
        this.tokenPriceOnChain = {
            USDT: 1,
            USDC: 1
        };
        this.connection = config.connection;
        this.farmHub = new model_1.FranciumFarm({ connection: this.connection });
        this.farmPools = farm_1.farmPools.filter(i => i.version > 2);
        this.getTokenPrice = config.getTokenPrice;
    }
    updateConnection(connection) {
        this.connection = connection;
        this.farmHub.connection = connection;
    }
    getLendingDepositTransaction(pool, amount, userPublicKey, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const { trx, signers } = yield (0, deposit_1.deposit)(this.connection, new bignumber_js_1.default(amount.toString()).toNumber(), pool, userPublicKey, configs);
            return {
                trx,
                signers
            };
        });
    }
    getLendWithdrawTransaction(pool, rewardAmount, tokenAmount, userPublicKey, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const { trx, signers } = yield (0, withdraw_2.withdraw)(this.connection, rewardAmount, tokenAmount, pool, userPublicKey, configs);
            return {
                trx,
                signers
            };
        });
    }
    getRepayTransactions(pair, lyfType, userPublicKey, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, repay_1.buildRepayTransactions)(this.connection, pair, lyfType, userPublicKey, this.farmHub, configs);
        });
    }
    getFarmTransactions(pair, lyfType, userPublicKey, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, farm_3.default)(this.connection, pair, lyfType, userPublicKey, this.farmHub, {
                amount0: configs.depositPcAmount,
                amount1: configs.depositCoinAmount,
                borrow0: configs.borrowPcAmount,
                borrow1: configs.borrowCoinAmount,
                stopLoss: configs.stopLoss || 80,
                currentUserInfoAccount: configs.currentUserInfoAccount
            });
        });
    }
    getFarmSwapPoolId(pair, platform) {
        return this.farmHub.getSwapPoolId(pair, platform);
    }
    getClosePositionTransactions(pair, lyfType, userPublicKey, configs) {
        return __awaiter(this, void 0, void 0, function* () {
            const { trxs } = yield (0, withdraw_1.default)(this.connection, pair, lyfType, userPublicKey, this.farmHub, {
                lpShares: new bignumber_js_1.default(configs.lpShares.toString()),
                withdrawType: configs.withdrawType,
                currentUserInfoAccount: configs.currentUserInfoAccount
            });
            return trxs;
        });
    }
    sendSingleTransaction(trx, wallet, signers) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, sign_1.sendWalletTransaction)(trx, this.connection, wallet, signers);
        });
    }
    sendMultipleTransactions(trxs, wallet, onTrxSended, onTrxConfirmed) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, sign_1.send2TransactionsListOneByOneWithErrorCatch)(trxs, this.connection, wallet, onTrxSended, onTrxConfirmed);
        });
    }
    getTokenPriceInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenPriceFunc = this.getTokenPrice || model_1.getTokenPrice;
            let tokenPrice = {
                USDT: 1,
                USDC: 1
            };
            try {
                tokenPrice = yield tokenPriceFunc();
                this.tokenPrice = tokenPrice;
            }
            catch (err) {
            }
            this.tokenPrice = tokenPrice;
            return {
                tokenPrice
            };
        });
    }
    getOnchainPriceList() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getFarmLPPriceInfo();
            return this.tokenPriceOnChain;
        });
    }
    getFarmLPPriceInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const priceList = {
                USDT: 1,
                USDC: 1
            };
            const orcaLPPriceInfo = yield (0, model_1.getOrcaLPPrice)(this.connection, priceList);
            const raydiumLPPriceInfo = yield (0, model_1.getRaydiumLPPrice)(this.connection, priceList);
            this.tokenPriceOnChain = priceList;
            return Object.assign(Object.assign({}, orcaLPPriceInfo), raydiumLPPriceInfo);
        });
    }
    getLendingPoolInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const lendingPoolInfos = yield (0, model_1.getLendingPoolInfo)(this.connection, pools_1.lendingPoolList);
            return lendingPoolInfos;
        });
    }
    getFarmPoolInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const farmPoolInfos = yield this.farmHub.getFarmPoolsInfo(this.farmPools);
            return farmPoolInfos;
        });
    }
    getUserFarmPositionByProgram(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const infos = yield this.farmHub.getUserPositionsAll(userPublicKey);
            return infos;
        });
    }
    getUserFarmPosition(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const farmInfo = yield this.getFarmPoolInfo();
            const infos = yield this.farmHub.getUserPositionsAll(userPublicKey);
            const raydiumInfos = infos.raydium;
            const orcaInfos = infos.orca;
            const strategyAccountPools = this.farmPools.map(i => {
                const targetFarmInfo = this.farmHub.getConfig(i.pair, i.lyfType || 'raydium');
                return {
                    strategyAccount: targetFarmInfo.strategyAccount,
                    pool: i
                };
            });
            const formattedUserInfos = [...raydiumInfos, ...orcaInfos].map(i => {
                const poolStrategyInfoAccount = i.data.strategyStateAccount;
                const targetPool = (0, lodash_1.find)(strategyAccountPools, target => {
                    return target.strategyAccount.toBase58() === poolStrategyInfoAccount.toBase58();
                });
                const targetPoolInfo = (0, lodash_1.find)(farmInfo, target => {
                    return target.strategyAccount.toBase58() === poolStrategyInfoAccount.toBase58();
                });
                return Object.assign(Object.assign({}, ((targetPool === null || targetPool === void 0 ? void 0 : targetPool.pool) || {})), { userinfo: i.data, userInfoPublicKey: i.publicKey, strategyInfo: targetPoolInfo });
            });
            const userPositions = formattedUserInfos.filter(i => i.strategyInfo).map((info) => {
                if (info) {
                    const type = info.lyfType || 'raydium';
                    return Object.assign({ type }, (0, farm_2.formatFarmUserPosition)(info.strategyInfo, info.userinfo, info.userInfoPublicKey));
                }
                return null;
            });
            return userPositions;
        });
    }
    getUserFormattedFarmPosition(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const LPPriceList = yield this.getFarmLPPriceInfo();
            const farmInfo = yield this.getFarmPoolInfo();
            const infos = yield this.farmHub.getUserPositionsAll(userPublicKey);
            const raydiumInfos = infos.raydium;
            const orcaInfos = infos.orca;
            const strategyAccountPools = this.farmPools.map(i => {
                const targetFarmInfo = this.farmHub.getConfig(i.pair, i.lyfType || 'raydium');
                return {
                    strategyAccount: targetFarmInfo.strategyAccount,
                    pool: i
                };
            });
            const formattedUserInfos = [...raydiumInfos, ...orcaInfos].map(i => {
                const poolStrategyInfoAccount = i.data.strategyStateAccount;
                const targetPool = (0, lodash_1.find)(strategyAccountPools, target => {
                    return target.strategyAccount.toBase58() === poolStrategyInfoAccount.toBase58();
                });
                const targetPoolInfo = (0, lodash_1.find)(farmInfo, target => {
                    return target.strategyAccount.toBase58() === poolStrategyInfoAccount.toBase58();
                });
                return Object.assign(Object.assign({}, ((targetPool === null || targetPool === void 0 ? void 0 : targetPool.pool) || {})), { userinfo: i.data, userInfoPublicKey: i.publicKey, strategyInfo: targetPoolInfo });
            });
            const userPositions = formattedUserInfos.filter(i => i.strategyInfo).map((info) => {
                if (info) {
                    const type = info.lyfType || 'raydium';
                    return Object.assign({ type }, (0, farm_2.formatFarmUserPositionByPrice)(info.strategyInfo, info.userinfo, info.userInfoPublicKey, {
                        priceList: this.tokenPriceOnChain,
                        LPPriceList
                    }));
                }
                return null;
            });
            return userPositions;
        });
    }
    getUserLendingPosition(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const lendingPoolInfos = yield this.getLendingPoolInfo();
            const rewardsList = yield (0, model_1.getUserRewardPosition)(this.connection, userPublicKey);
            const balanceList = yield (0, model_1.getLendingPoolBalance)(this.connection, userPublicKey);
            return lendingPoolInfos.map(info => {
                var _a, _b;
                const rewardPosition = ((_a = rewardsList[info.pool]) === null || _a === void 0 ? void 0 : _a.amount) || 0;
                const balancePosition = ((_b = balanceList[info.pool]) === null || _b === void 0 ? void 0 : _b.amount) || 0;
                const totalPosition = rewardPosition + balancePosition;
                const sharePrice = new bignumber_js_1.default(info.totalAmount.toString()).dividedBy(new bignumber_js_1.default(info.totalShareMintSupply.toString())).toNumber();
                return {
                    pool: info.pool,
                    scale: info.scale,
                    rewardPosition,
                    balancePosition,
                    totalPosition,
                    totalAmount: (sharePrice * totalPosition) / Math.pow(10, info.scale)
                };
            });
        });
    }
    getFarmPoolTVL() {
        return __awaiter(this, void 0, void 0, function* () {
            const farmLPPrice = yield this.getFarmLPPriceInfo();
            const farmPoolInfos = yield this.getFarmPoolInfo();
            const pools = farmPoolInfos.map(info => {
                const totalLP = (0, math_1.getAmountByDecimals)(info.totalLp, info.lpDecimals);
                const price = farmLPPrice[info.priceKey].priceAmm || 0;
                return {
                    id: info.id,
                    lpAmount: totalLP,
                    liquidityLocked: totalLP * price
                };
            });
            return pools;
        });
    }
    getLendingPoolTVL() {
        return __awaiter(this, void 0, void 0, function* () {
            const { tokenPrice } = yield this.getTokenPriceInfo();
            const lendingPoolInfos = yield this.getLendingPoolInfo();
            const info = lendingPoolInfos.map(info => {
                const availableAmountBN = info.avaliableAmount;
                const totalAmountBN = info.totalAmount;
                const price = tokenPrice[info.pool];
                const totalAmount = (0, math_1.getAmountByDecimals)(totalAmountBN, info.scale);
                const availableAmount = (0, math_1.getAmountByDecimals)(availableAmountBN, info.scale);
                const liquidityLocked = totalAmount * price;
                const available = availableAmount * price;
                return {
                    id: info.pool,
                    apy: info.apy,
                    borrowApr: info.borrowInterest,
                    liquidityLocked,
                    available,
                    price,
                    totalAmount,
                    availableAmount
                };
            });
            return info;
        });
    }
    getRebalanceInfo(userPublicKey, positionPublicKey, leverage = 3) {
        return __awaiter(this, void 0, void 0, function* () {
            const LPPriceList = yield this.getFarmLPPriceInfo();
            const getUserFormattedFarmPosition = () => __awaiter(this, void 0, void 0, function* () {
                const farmInfo = yield this.getFarmPoolInfo();
                const infos = yield this.farmHub.getUserPositionsAll(userPublicKey);
                const raydiumInfos = infos.raydium;
                const orcaInfos = infos.orca;
                const strategyAccountPools = this.farmPools.map(i => {
                    const targetFarmInfo = this.farmHub.getConfig(i.pair, i.lyfType || 'raydium');
                    return {
                        strategyAccount: targetFarmInfo.strategyAccount,
                        pool: i
                    };
                });
                const formattedUserInfos = [...raydiumInfos, ...orcaInfos].map(i => {
                    const poolStrategyInfoAccount = i.data.strategyStateAccount;
                    const targetPool = (0, lodash_1.find)(strategyAccountPools, target => {
                        return target.strategyAccount.toBase58() === poolStrategyInfoAccount.toBase58();
                    });
                    const targetPoolInfo = (0, lodash_1.find)(farmInfo, target => {
                        return target.strategyAccount.toBase58() === poolStrategyInfoAccount.toBase58();
                    });
                    return Object.assign(Object.assign({}, ((targetPool === null || targetPool === void 0 ? void 0 : targetPool.pool) || {})), { userinfo: i.data, userInfoPublicKey: i.publicKey, strategyInfo: targetPoolInfo });
                });
                const userPositions = formattedUserInfos.filter(i => i.strategyInfo).map((info) => {
                    if (info) {
                        return (0, farm_2.formatFarmUserPositionByPrice)(info.strategyInfo, info.userinfo, info.userInfoPublicKey, {
                            priceList: this.tokenPriceOnChain,
                            LPPriceList
                        });
                    }
                    return null;
                });
                return userPositions;
            });
            const positions = yield getUserFormattedFarmPosition();
            const positionInfo = positions.find(item => item.userInfoPublicKey.toBase58() === positionPublicKey)
                || positions[0];
            const { lpShares, lpAmount, equityValue: userEquity, borrowed, priceKey, userInfo, } = positionInfo;
            const lpInfo = LPPriceList[priceKey];
            const { coinToken: token1, pcToken: token0, } = lpInfo;
            const token1Price = lpInfo.coinRelativePrice;
            const userBorrowed0Amount = (0, math_1.getAmountByDecimals)(borrowed[0].amount, (0, tools_1.getTokenDecimals)(token0));
            const userBorrowed0Value = userBorrowed0Amount;
            const userBorrowed1Amount = (0, math_1.getAmountByDecimals)(borrowed[1].amount, (0, tools_1.getTokenDecimals)(token1));
            const userBorrowed1Value = userBorrowed1Amount * token1Price;
            const pcAmount = (0, math_1.getAmountByDecimals)(new bignumber_js_1.default(lpInfo.pcPerLP).multipliedBy(new bignumber_js_1.default(lpAmount.toNumber())), lpInfo.lpDecimals);
            console.log('RebalanceSDK params :>> ', {
                userEquity,
                token1Price,
                pcAmount,
                positionInfo,
                lpInfo,
            });
            const { longPosition, shortPosition } = (0, rebalance_1.rebalanceByEquity)(leverage, userEquity, token1Price, pcAmount);
            const borrowValue0 = longPosition.stableDebt - userBorrowed0Value;
            const borrowValue1 = shortPosition.cryptoDebt * token1Price - userBorrowed1Value;
            let token0ToAdd = 0;
            const rebalanceOptions = {
                option1: {},
                option2: {}
            };
            if (borrowValue0 >= 0 &&
                borrowValue1 >= 0) {
                rebalanceOptions.option1 = {
                    depositPcAmount: token0ToAdd,
                    depositCoinAmount: 0,
                    borrowPcAmount: borrowValue0,
                    borrowCoinAmount: borrowValue1 / token1Price,
                    stopLoss: userInfo.stopLoss,
                };
            }
            else {
                addMore();
                updateWithdrawConfig();
            }
            function ceilToken0Amount(num) {
                return (0, lodash_1.ceil)(num, (0, tools_1.getTokenDecimals)(token0));
            }
            function addMore() {
                const B = Math.max(2 * userBorrowed0Value, 2 / 3 * userBorrowed1Value);
                const S = pcAmount;
                const S1min = (B + rebalance_1.SWAP_FEE * S) / (1 + rebalance_1.SWAP_FEE * 3 / 2);
                const S1max = 2 / 3 * S;
                if (S1min <= S1max) {
                    const S1 = S1min;
                    if (S1 - userEquity > 0) {
                        token0ToAdd = ceilToken0Amount(S1 - userEquity);
                    }
                }
                const S2min = S1max;
                const S2min2 = (B - rebalance_1.SWAP_FEE * S) / (1 - rebalance_1.SWAP_FEE * 3 / 2);
                const S2 = Math.max(S2min, S2min2);
                if (S2 - userEquity > 0) {
                    token0ToAdd = ceilToken0Amount(S2 - userEquity);
                }
                const { longPosition, shortPosition } = (0, rebalance_1.rebalanceByEquity)(leverage, userEquity + token0ToAdd, token1Price, pcAmount + token0ToAdd);
                const borrowValue0 = longPosition.stableDebt - userBorrowed0Value;
                const borrowValue1 = shortPosition.cryptoDebt * token1Price - userBorrowed1Value;
                rebalanceOptions.option1 = {
                    depositPcAmount: token0ToAdd,
                    depositCoinAmount: 0,
                    borrowPcAmount: borrowValue0,
                    borrowCoinAmount: borrowValue1 / token1Price,
                    stopLoss: userInfo.stopLoss,
                };
            }
            function updateWithdrawConfig() {
                const A = userEquity - Math.abs(pcAmount - 3 / 2 * userEquity) * rebalance_1.SWAP_FEE;
                const aa = A / 2 / userBorrowed0Value;
                const bb = A * 3 / 2 / userBorrowed1Value;
                const remainPer = Math.min(aa, bb, 1);
                const { longPosition, shortPosition } = (0, rebalance_1.rebalanceByEquity)(leverage, userEquity, token1Price, pcAmount);
                const borrowValue0AfterWithdraw = longPosition.stableDebt - userBorrowed0Value * remainPer;
                const borrowValue1AfterWithdraw = shortPosition.cryptoDebt * token1Price - userBorrowed1Value * remainPer;
                const precise = 6;
                const ceiledWithdrawPer = ((0, lodash_1.ceil)(1 - remainPer, 6) + 0.01) || 0;
                const lpSharesToWithdraw = new bignumber_js_1.default(lpShares.toString()).multipliedBy(new bignumber_js_1.default(ceiledWithdrawPer * (Math.pow(10, precise)))).div(new bignumber_js_1.default(Math.pow(10, precise)));
                console.log('lpSharesToWithdraw :>> ', lpShares.toString(), 1 - remainPer, lpSharesToWithdraw.toString());
                rebalanceOptions.option2 = {
                    lpSharesToWithdraw,
                    borrowPcAmountAfterWithdraw: borrowValue0AfterWithdraw,
                    borrowCoinAmountAfterWithdraw: borrowValue1AfterWithdraw / token1Price,
                    stopLoss: userInfo.stopLoss,
                };
            }
            return {
                poolInfo: {
                    token0,
                    token1,
                    lyfType: lpInfo.type,
                },
                rebalanceOptions,
            };
        });
    }
    getRebalanceTransactions(userPublicKey, positionPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const { poolInfo, rebalanceOptions } = yield this.getRebalanceInfo(userPublicKey, positionPublicKey);
            const { token0, token1, lyfType, } = poolInfo;
            const token0Scale = Math.pow(10, (0, tools_1.getTokenDecimals)(token0));
            const token1Scale = Math.pow(10, (0, tools_1.getTokenDecimals)(token1));
            const pair = `${token1}-${token0}`;
            const trxs = yield this.getFarmTransactions(pair, lyfType, userPublicKey, {
                depositPcAmount: new BN(rebalanceOptions.option1.depositPcAmount * token0Scale),
                depositCoinAmount: new BN(rebalanceOptions.option1.depositCoinAmount * token1Scale),
                borrowPcAmount: new BN(rebalanceOptions.option1.borrowPcAmount * token0Scale),
                borrowCoinAmount: new BN(rebalanceOptions.option1.borrowCoinAmount * token1Scale),
                stopLoss: rebalanceOptions.option1.stopLoss,
                currentUserInfoAccount: new web3_js_1.PublicKey(positionPublicKey),
            });
            return trxs;
        });
    }
    sendRebalanceTransactions(userPublicKey, positionPublicKey, wallet, onTrxSended, onTrxConfirmed) {
        return __awaiter(this, void 0, void 0, function* () {
            const walletAddress = userPublicKey.toBase58();
            const { poolInfo, rebalanceOptions } = yield this.getRebalanceInfo(userPublicKey, positionPublicKey);
            console.log('rebalanceOptions :>> ', rebalanceOptions);
            const { token0, token1, lyfType, } = poolInfo;
            const token0Scale = Math.pow(10, (0, tools_1.getTokenDecimals)(token0));
            const token1Scale = Math.pow(10, (0, tools_1.getTokenDecimals)(token1));
            const pair = `${token1}-${token0}`;
            const sendRebalanceTransactionsOption1 = () => __awaiter(this, void 0, void 0, function* () {
                if (!rebalanceOptions.option1.depositPcAmount
                    && !rebalanceOptions.option1.depositCoinAmount) {
                    const trxs = yield this.getFarmTransactions(pair, lyfType, userPublicKey, {
                        depositPcAmount: new BN(rebalanceOptions.option1.depositPcAmount * token0Scale),
                        depositCoinAmount: new BN(rebalanceOptions.option1.depositCoinAmount * token1Scale),
                        borrowPcAmount: new BN(rebalanceOptions.option1.borrowPcAmount * token0Scale),
                        borrowCoinAmount: new BN(rebalanceOptions.option1.borrowCoinAmount * token1Scale),
                        stopLoss: rebalanceOptions.option1.stopLoss,
                        currentUserInfoAccount: new web3_js_1.PublicKey(positionPublicKey),
                    });
                    return yield this.sendMultipleTransactions(trxs, wallet, onTrxSended, onTrxConfirmed);
                }
            });
            const sendRebalanceTransactionsOption2 = () => __awaiter(this, void 0, void 0, function* () {
                const { closedAccount, trxs: withdrawTrxs } = yield (0, withdraw_1.default)(this.connection, pair, lyfType, userPublicKey, this.farmHub, {
                    lpShares: rebalanceOptions.option2.lpSharesToWithdraw,
                    withdrawType: 2,
                    currentUserInfoAccount: new web3_js_1.PublicKey(positionPublicKey),
                });
                yield this.sendMultipleTransactions(withdrawTrxs, wallet, undefined, (index, txid, stateInfo) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                    const total = stateInfo === null || stateInfo === void 0 ? void 0 : stateInfo.total;
                    const lastIndex = total - 2;
                    if (index === lastIndex && txid && stateInfo.state === 'success') {
                        const txInfo = yield this.connection.getParsedConfirmedTransaction(stateInfo.signature, 'confirmed');
                        console.log(`withdraw txInfo ${index}:>> `, txInfo);
                        const token0MintAddr = index_1.TOKENS_LIST[token0].mintAddress.toBase58();
                        const token1MintAddr = index_1.TOKENS_LIST[token1].mintAddress.toBase58();
                        const token0Before = (_c = (_b = (_a = txInfo === null || txInfo === void 0 ? void 0 : txInfo.meta) === null || _a === void 0 ? void 0 : _a.preTokenBalances) === null || _b === void 0 ? void 0 : _b.find((item) => item.owner === walletAddress && item.mint === token0MintAddr)) === null || _c === void 0 ? void 0 : _c.uiTokenAmount;
                        const token1Before = (_f = (_e = (_d = txInfo === null || txInfo === void 0 ? void 0 : txInfo.meta) === null || _d === void 0 ? void 0 : _d.preTokenBalances) === null || _e === void 0 ? void 0 : _e.find((item) => item.owner === walletAddress && item.mint === token1MintAddr)) === null || _f === void 0 ? void 0 : _f.uiTokenAmount;
                        const token0After = (_j = (_h = (_g = txInfo === null || txInfo === void 0 ? void 0 : txInfo.meta) === null || _g === void 0 ? void 0 : _g.postTokenBalances) === null || _h === void 0 ? void 0 : _h.find((item) => item.owner === walletAddress && item.mint === token0MintAddr)) === null || _j === void 0 ? void 0 : _j.uiTokenAmount;
                        const token1After = (_m = (_l = (_k = txInfo === null || txInfo === void 0 ? void 0 : txInfo.meta) === null || _k === void 0 ? void 0 : _k.postTokenBalances) === null || _l === void 0 ? void 0 : _l.find((item) => item.owner === walletAddress && item.mint === token1MintAddr)) === null || _m === void 0 ? void 0 : _m.uiTokenAmount;
                        let token0Change = (token0Before && token0After) ? new bignumber_js_1.default(token0After.amount).minus(new bignumber_js_1.default(token0Before.amount))
                            .div(new bignumber_js_1.default(Math.pow(10, token0After.decimals))).toNumber() : 0;
                        let token1Change = (token1Before && token1After) ? new bignumber_js_1.default(token1After.amount).minus(new bignumber_js_1.default(token1Before.amount))
                            .div(new bignumber_js_1.default(Math.pow(10, token1After.decimals))).toNumber() : 0;
                        console.log('closedAccount :>> ', closedAccount);
                        let WSOLChange = 0;
                        if (closedAccount) {
                            const waitParsed = () => {
                                return new Promise(resolve => {
                                    const timer = setInterval(() => {
                                        var _a, _b;
                                        const innerInstructionsAllParsed = (_b = (_a = txInfo === null || txInfo === void 0 ? void 0 : txInfo.meta) === null || _a === void 0 ? void 0 : _a.innerInstructions) === null || _b === void 0 ? void 0 : _b.every(innerInstruction => {
                                            return innerInstruction.instructions.every((item) => !item.program || !!item.parsed);
                                        });
                                        if (innerInstructionsAllParsed) {
                                            clearInterval(timer);
                                            resolve(1);
                                        }
                                    }, 50);
                                });
                            };
                            yield waitParsed();
                            (_p = (_o = txInfo === null || txInfo === void 0 ? void 0 : txInfo.meta) === null || _o === void 0 ? void 0 : _o.innerInstructions) === null || _p === void 0 ? void 0 : _p.forEach(innerInstruction => {
                                var _a;
                                (_a = innerInstruction.instructions) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
                                    var _a, _b, _c, _d;
                                    if (((_b = (_a = item.parsed) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.destination) === closedAccount) {
                                        WSOLChange = new bignumber_js_1.default((_d = (_c = item === null || item === void 0 ? void 0 : item.parsed) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.amount).div(new bignumber_js_1.default(Math.pow(10, (0, tools_1.getTokenDecimals)('SOL')))).toNumber();
                                    }
                                });
                            });
                            if (token0 === 'SOL') {
                                token0Change += WSOLChange;
                            }
                            if (token1 === 'SOL') {
                                token1Change += WSOLChange;
                            }
                        }
                        console.log('balance change:>> ', {
                            token0After, token0Before, token1After, token1Before,
                            token0Change, token1Change, WSOLChange,
                        });
                        const trxs = yield this.getFarmTransactions(pair, lyfType, userPublicKey, {
                            depositPcAmount: new BN(token0Change * token0Scale),
                            depositCoinAmount: new BN(token1Change * token1Scale),
                            borrowPcAmount: new BN(rebalanceOptions.option2.borrowPcAmountAfterWithdraw * token0Scale),
                            borrowCoinAmount: new BN(rebalanceOptions.option2.borrowCoinAmountAfterWithdraw * token1Scale),
                            stopLoss: rebalanceOptions.option2.stopLoss,
                            currentUserInfoAccount: new web3_js_1.PublicKey(positionPublicKey),
                        });
                        return yield this.sendMultipleTransactions(trxs, wallet, onTrxSended, onTrxConfirmed);
                    }
                }));
            });
            if (!rebalanceOptions.option1.depositPcAmount
                && !rebalanceOptions.option1.depositCoinAmount) {
                return sendRebalanceTransactionsOption1();
            }
            else {
                return sendRebalanceTransactionsOption2();
            }
        });
    }
}
exports.FranciumSDK = FranciumSDK;
