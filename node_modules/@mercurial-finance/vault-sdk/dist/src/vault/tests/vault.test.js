"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const spl_token_registry_1 = require("@solana/spl-token-registry");
const anchor_1 = require("@project-serum/anchor");
const __1 = __importDefault(require(".."));
const utils_1 = require("./utils");
const mockWallet = new anchor_1.Wallet(new web3_js_1.Keypair());
const mainnetConnection = new web3_js_1.Connection('https://api.mainnet-beta.solana.com');
// devnet ATA creation and reading must use confirmed.
const devnetConnection = new web3_js_1.Connection('https://api.devnet.solana.com/', { commitment: 'confirmed' });
// Prevent importing directly from .json, causing slowdown on Intellisense
const tokenMap = new spl_token_registry_1.StaticTokenListResolutionStrategy().resolve();
const SOL_TOKEN_INFO = tokenMap.find((token) => token.symbol === 'SOL');
const USDC_TOKEN_INFO = tokenMap.find((token) => token.symbol === 'USDC');
const USDT_TOKEN_INFO = tokenMap.find((token) => token.symbol === 'USDT');
describe('Get Mainnet vault state', () => {
    let vaults = [];
    // Make sure all vaults can be initialized
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        const allVaults = yield Promise.all([
            yield __1.default.create(mainnetConnection, SOL_TOKEN_INFO),
            yield __1.default.create(mainnetConnection, USDC_TOKEN_INFO),
            yield __1.default.create(mainnetConnection, USDT_TOKEN_INFO),
        ]);
        vaults = vaults.concat(allVaults);
    }));
    test('Get LP Supply', () => __awaiter(void 0, void 0, void 0, function* () {
        vaults.forEach((vault) => {
            expect(Number(vault.lpSupply)).toBeGreaterThan(0);
        });
    }));
    test('Get unlocked amount', () => __awaiter(void 0, void 0, void 0, function* () {
        vaults.forEach((vault) => __awaiter(void 0, void 0, void 0, function* () {
            const unlockedAmount = yield vault.getWithdrawableAmount();
            expect(Number(unlockedAmount)).toBeGreaterThan(0);
        }));
    }));
});
describe('Interact with Vault in devnet', () => {
    const provider = new anchor_1.AnchorProvider(devnetConnection, mockWallet, {
        commitment: 'confirmed',
    });
    let vault;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, utils_1.airDropSol)(devnetConnection, mockWallet.publicKey);
        vault = yield __1.default.create(devnetConnection, SOL_TOKEN_INFO, { cluster: 'devnet' });
    }));
    test('Deposit, check balance, withdraw', () => __awaiter(void 0, void 0, void 0, function* () {
        // Deposit
        const depositTx = yield vault.deposit(mockWallet.publicKey, new anchor_1.BN(100000000));
        const depositResult = yield provider.sendAndConfirm(depositTx);
        console.log('Deposit result', depositResult);
        expect(typeof depositResult).toBe('string');
        // Check balance
        const userBalanceDeposit = yield vault.getUserBalance(mockWallet.publicKey);
        expect(Number(userBalanceDeposit)).toBeGreaterThan(0);
        // Withdraw all lp
        const withdrawTx = yield vault.withdraw(mockWallet.publicKey, new anchor_1.BN(userBalanceDeposit));
        const withdrawResult = yield provider.sendAndConfirm(withdrawTx);
        console.log('Withdraw result', withdrawResult);
        expect(typeof withdrawResult).toBe('string');
        // Check balance
        const userBalanceWithdraw = yield vault.getUserBalance(mockWallet.publicKey);
        expect(Number(userBalanceWithdraw)).toEqual(0);
    }));
    test('Vault Withdraw SOL from all strategy', () => __awaiter(void 0, void 0, void 0, function* () {
        for (var strategy of vault.vaultState.strategies) {
            if (!strategy.equals(web3_js_1.PublicKey.default)) {
                console.log('Test with ', strategy.toString());
                // Deposit
                const depositTx = yield vault.deposit(mockWallet.publicKey, new anchor_1.BN(1000000));
                const depositResult = yield provider.sendAndConfirm(depositTx);
                expect(typeof depositResult).toBe('string');
                // Withdraw from specific strategy
                const withdrawTx = yield vault.withdraw(mockWallet.publicKey, new anchor_1.BN(1000), { strategy });
                try {
                    const withdrawResult = yield provider.sendAndConfirm(withdrawTx);
                    console.log('Strategy withdraw result', withdrawResult);
                    expect(typeof withdrawResult).toBe('string');
                }
                catch (error) {
                    console.log('Error creating withdrawFromStrategy instruction', error);
                }
            }
        }
    }));
});
