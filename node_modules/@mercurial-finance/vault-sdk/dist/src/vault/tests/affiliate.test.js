"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const spl_token_registry_1 = require("@solana/spl-token-registry");
const anchor_1 = require("@project-serum/anchor");
const __1 = __importDefault(require(".."));
const utils_1 = require("./utils");
const mockWallet = new anchor_1.Wallet(new web3_js_1.Keypair());
// devnet ATA creation and reading must use confirmed.
const devnetConnection = new web3_js_1.Connection('https://api.devnet.solana.com/', { commitment: 'confirmed' });
const tokenMap = new spl_token_registry_1.StaticTokenListResolutionStrategy().resolve();
const SOL_TOKEN_INFO = tokenMap.find((token) => token.symbol === 'SOL');
const USDC_TOKEN_INFO = tokenMap.find((token) => token.symbol === 'USDC');
const USDT_TOKEN_INFO = tokenMap.find((token) => token.symbol === 'USDT');
// TODO: Remove this fake partner ID
const TEMPORARY_PARTNER_PUBLIC_KEY = new web3_js_1.PublicKey('7236FoaWTXJyzbfFPZcrzg3tBpPhGiTgXsGWvjwrYfiF');
describe('Interact with Vault in devnet', () => {
    const provider = new anchor_1.AnchorProvider(devnetConnection, mockWallet, {
        commitment: 'confirmed',
    });
    let vaultImpl;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, utils_1.airDropSol)(devnetConnection, mockWallet.publicKey);
        vaultImpl = yield __1.default.create(devnetConnection, SOL_TOKEN_INFO, {
            cluster: 'devnet',
            affiliateId: TEMPORARY_PARTNER_PUBLIC_KEY,
        });
    }));
    test('Test affiliate init user, check balance, deposits, then withdraw all', () => __awaiter(void 0, void 0, void 0, function* () {
        // First deposit
        const depositTx = yield vaultImpl.deposit(mockWallet.publicKey, new anchor_1.BN(100000000));
        expect(depositTx.instructions.map((ix) => ix.programId.toString())).toEqual([
            'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
            'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
            '11111111111111111111111111111111',
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
            'GacY9YuN16HNRTy7ZWwULPccwvfFSBeNLuAQP7y38Du3',
            'GacY9YuN16HNRTy7ZWwULPccwvfFSBeNLuAQP7y38Du3', // Affiliate program deposit
        ]);
        const depositResult = yield provider.sendAndConfirm(depositTx);
        console.log('Deposit result', depositResult);
        expect(typeof depositResult).toBe('string');
        // Check balance
        const userBalanceDeposit = yield vaultImpl.getUserBalance(mockWallet.publicKey);
        expect(Number(userBalanceDeposit)).toBeGreaterThan(0);
        // Subsequent deposit should not create ATA, and no need to init user
        const depositTx2 = yield vaultImpl.deposit(mockWallet.publicKey, new anchor_1.BN(100000000));
        expect(depositTx2.instructions.map((ix) => ix.programId.toString())).toEqual([
            '11111111111111111111111111111111',
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
            'GacY9YuN16HNRTy7ZWwULPccwvfFSBeNLuAQP7y38Du3', // Affiliate program deposit
        ]);
        const depositResult2 = yield provider.sendAndConfirm(depositTx2);
        console.log('Deposit result', depositResult2);
        expect(typeof depositResult2).toBe('string');
        // Check balance again, should be greater than first deposit
        const userBalanceDeposit2 = yield vaultImpl.getUserBalance(mockWallet.publicKey);
        expect(Number(userBalanceDeposit2)).toBeGreaterThan(Number(userBalanceDeposit));
        // Withdraw
        const withdrawTx = yield vaultImpl.withdraw(mockWallet.publicKey, new anchor_1.BN(userBalanceDeposit2));
        const withdrawResult = yield provider.sendAndConfirm(withdrawTx);
        console.log('Withdraw result', withdrawResult);
        expect(typeof withdrawResult).toBe('string');
        // Check final balance to be zero
        const userBalanceDeposit3 = yield vaultImpl.getUserBalance(mockWallet.publicKey);
        expect(Number(userBalanceDeposit3)).toEqual(0);
    }));
    test('Get affiliate partner info', () => __awaiter(void 0, void 0, void 0, function* () {
        const partnerInfo = yield vaultImpl.getAffiliateInfo();
        expect(Object.keys(partnerInfo)).toEqual(expect.arrayContaining(['partnerToken', 'vault', 'outstandingFee', 'feeRatio', 'cummulativeFee']));
    }));
});
