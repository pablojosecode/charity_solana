var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { AnchorProvider, Program, BN } from '@project-serum/anchor';
import { PublicKey, Transaction, SYSVAR_RENT_PUBKEY, SystemProgram, } from '@solana/web3.js';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { deserializeAccount, getAssociatedTokenAccount, getLpSupply, getOnchainTime, getOrCreateATAInstruction, getVaultPdas, unwrapSOLInstruction, wrapSOLInstruction, } from './utils';
import { AFFILIATE_PROGRAM_ID, PROGRAM_ID, SOL_MINT, VAULT_STRATEGY_ADDRESS } from './constants';
import { getStrategyHandler, getStrategyType } from './strategy';
import { IDL } from './idl';
import { IDL as AffiliateIDL } from './affiliate-idl';
import { calculateWithdrawableAmount } from './helper';
const getVaultState = (vaultParams, program) => __awaiter(void 0, void 0, void 0, function* () {
    const { vaultPda, tokenVaultPda } = yield getVaultPdas(new PublicKey(vaultParams.address), new PublicKey(program.programId));
    const vaultState = (yield program.account.vault.fetchNullable(vaultPda));
    const lpSupply = yield getLpSupply(program.provider.connection, vaultState.lpMint);
    if (!vaultState) {
        throw 'Cannot get vault state';
    }
    return { vaultPda, tokenVaultPda, vaultState, lpSupply };
});
const getVaultLiquidity = (connection, tokenVaultPda) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultLiquidityResponse = yield connection.getAccountInfo(tokenVaultPda);
    if (!vaultLiquidityResponse)
        return null;
    const vaultLiquiditySerialize = deserializeAccount(vaultLiquidityResponse.data);
    return (vaultLiquiditySerialize === null || vaultLiquiditySerialize === void 0 ? void 0 : vaultLiquiditySerialize.amount.toString()) || null;
});
export default class VaultImpl {
    constructor(program, vaultDetails, opt) {
        var _a;
        this.cluster = 'mainnet-beta';
        this.lpSupply = new BN(0);
        this.connection = program.provider.connection;
        this.cluster = (_a = opt === null || opt === void 0 ? void 0 : opt.cluster) !== null && _a !== void 0 ? _a : 'mainnet-beta';
        this.tokenInfo = vaultDetails.tokenInfo;
        this.program = program;
        this.affiliateProgram = opt === null || opt === void 0 ? void 0 : opt.affiliateProgram;
        this.affiliateId = opt === null || opt === void 0 ? void 0 : opt.affiliateId;
        this.vaultPda = vaultDetails.vaultPda;
        this.tokenVaultPda = vaultDetails.tokenVaultPda;
        this.vaultState = vaultDetails.vaultState;
        this.lpSupply = vaultDetails.lpSupply;
    }
    static create(connection, tokenInfo, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
            const program = new Program(IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || PROGRAM_ID, provider);
            const { vaultPda, tokenVaultPda, vaultState, lpSupply } = yield getVaultState(tokenInfo, program);
            return new VaultImpl(program, { tokenInfo, vaultPda, tokenVaultPda, vaultState, lpSupply }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                    ? new Program(AffiliateIDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || AFFILIATE_PROGRAM_ID, provider)
                    : undefined }));
        });
    }
    getUserBalance(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const isAffiliated = this.affiliateId && this.affiliateProgram;
            const address = yield (() => __awaiter(this, void 0, void 0, function* () {
                // User deposit directly
                if (!isAffiliated) {
                    return yield getAssociatedTokenAccount(this.vaultState.lpMint, owner);
                }
                // Get user affiliated address with the partner
                const { userLpToken } = yield this.createAffiliateATAPreInstructions(owner);
                return userLpToken;
            }))();
            const accountInfo = yield this.connection.getAccountInfo(address);
            if (!accountInfo) {
                return new BN(0);
            }
            const result = deserializeAccount(accountInfo.data);
            if (result == undefined) {
                throw new Error('Failed to parse user account for LP token.');
            }
            return new BN(result.amount);
        });
    }
    /** To refetch the latest lpSupply */
    /** Use vaultImpl.lpSupply to use cached result */
    getVaultSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            const lpSupply = yield getLpSupply(this.connection, this.vaultState.lpMint);
            this.lpSupply = lpSupply;
            return lpSupply;
        });
    }
    getWithdrawableAmount() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTime = yield getOnchainTime(this.connection);
            return calculateWithdrawableAmount(currentTime, this.vaultState);
        });
    }
    refreshVaultState() {
        return __awaiter(this, void 0, void 0, function* () {
            const { vaultState, lpSupply } = yield getVaultState(this.tokenInfo, this.program);
            this.vaultState = vaultState;
            this.lpSupply = lpSupply;
        });
    }
    createATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield getOrCreateATAInstruction(new PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield getOrCreateATAInstruction(this.vaultState.lpMint, owner, this.connection);
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                userToken,
                userLpToken,
            };
        });
    }
    createAffiliateATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('Affiliate ID or program not found');
            const partner = this.affiliateId;
            const partnerToken = yield getAssociatedTokenAccount(new PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const [userAddress, _nonceUser] = yield PublicKey.findProgramAddress([partnerAddress.toBuffer(), owner.toBuffer()], this.affiliateProgram.programId);
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield getOrCreateATAInstruction(new PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield getOrCreateATAInstruction(this.vaultState.lpMint, userAddress, this.connection, {
                payer: owner,
                allowOwnerOffCurve: true,
            });
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                partner,
                partnerAddress,
                userAddress,
                userToken,
                userLpToken,
            };
        });
    }
    deposit(owner, baseTokenAmount) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            let preInstructions = [];
            let partnerAddress;
            let userAddress;
            let userToken;
            let userLpToken;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress: partnerAddressATA, userAddress: userAddressATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                partnerAddress = partnerAddressATA;
                userAddress = userAddressATA;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            // If it's SOL vault, wrap desired amount of SOL
            if (this.tokenInfo.address === SOL_MINT.toString()) {
                preInstructions = preInstructions.concat(wrapSOLInstruction(owner, userToken, baseTokenAmount));
            }
            let depositTx;
            if (partnerAddress && userAddress && this.affiliateId && this.affiliateProgram) {
                const userPda = yield this.connection.getParsedAccountInfo(userAddress);
                if (!userPda || !((_a = userPda.value) === null || _a === void 0 ? void 0 : _a.data)) {
                    // Init first time user
                    preInstructions.push(yield this.affiliateProgram.methods
                        .initUser()
                        .accounts({
                        user: userAddress,
                        partner: partnerAddress,
                        owner,
                        systemProgram: SystemProgram.programId,
                        rent: SYSVAR_RENT_PUBKEY,
                    })
                        .instruction());
                }
                depositTx = yield this.affiliateProgram.methods
                    .deposit(new BN(baseTokenAmount.toString()), new BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    partner: partnerAddress,
                    user: userAddress,
                    vaultProgram: this.program.programId,
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    owner,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            else {
                depositTx = yield this.program.methods
                    .deposit(new BN(baseTokenAmount.toString()), new BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            return new Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(depositTx);
        });
    }
    getStrategyWithHighestLiquidity(strategy) {
        return __awaiter(this, void 0, void 0, function* () {
            // Reserved for testing
            if (strategy) {
                const strategyState = (yield this.program.account.strategy.fetchNullable(strategy));
                return { publicKey: strategy, strategyState };
            }
            const vaultStrategiesStatePromise = this.vaultState.strategies
                .filter((address) => address.toString() !== VAULT_STRATEGY_ADDRESS)
                .map((strat) => __awaiter(this, void 0, void 0, function* () {
                const strategyState = (yield this.program.account.strategy.fetchNullable(strat));
                return { publicKey: strat, strategyState };
            }));
            const vaultStrategiesState = yield Promise.allSettled(vaultStrategiesStatePromise);
            const highestLiquidity = vaultStrategiesState
                .map((item) => (item.status === 'fulfilled' ? item.value : undefined))
                .sort((a, b) => {
                if (a && b) {
                    return b.strategyState.currentLiquidity.sub(a.strategyState.currentLiquidity).toNumber();
                }
                return 0;
            })[0];
            return highestLiquidity
                ? highestLiquidity
                : {
                    publicKey: new PublicKey(VAULT_STRATEGY_ADDRESS),
                    strategyState: null,
                };
        });
    }
    withdraw(owner, baseTokenAmount, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            // Get strategy with highest liquidity
            // opt.strategy reserved for testing
            const selectedStrategy = yield this.getStrategyWithHighestLiquidity(opt === null || opt === void 0 ? void 0 : opt.strategy);
            if (!selectedStrategy || // If there's no strategy deployed to the vault, use Vault Reserves instead
                selectedStrategy.publicKey.toString() === VAULT_STRATEGY_ADDRESS || // If opt.strategy specified Vault Reserves
                !selectedStrategy.strategyState // If opt.strategy specified Vault Reserves
            ) {
                return this.withdrawFromVaultReserve(owner, baseTokenAmount);
            }
            const currentLiquidity = new BN(selectedStrategy.strategyState.currentLiquidity);
            const vaultLiquidty = new BN((yield getVaultLiquidity(this.connection, this.tokenVaultPda)) || 0);
            const unlockedAmount = yield this.getWithdrawableAmount();
            const virtualPrice = new BN(unlockedAmount).div(new BN(this.lpSupply));
            const availableAmount = currentLiquidity.add(vaultLiquidty);
            const amountToUnmint = new BN(baseTokenAmount).mul(virtualPrice);
            if (amountToUnmint.gt(availableAmount)) {
                throw new Error('Selected strategy does not have enough liquidity.');
            }
            const strategyType = getStrategyType(selectedStrategy.strategyState.strategyType);
            const strategyHandler = getStrategyHandler(strategyType, this.cluster, this.connection);
            if (!strategyType || !strategyHandler) {
                throw new Error('Cannot find strategy handler');
            }
            let preInstructions = [];
            let withdrawOpt = {};
            let userToken;
            let userLpToken;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress, userAddress, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                withdrawOpt = {
                    affiliate: {
                        affiliateId: this.affiliateId,
                        affiliateProgram: this.affiliateProgram,
                        partner: partnerAddress,
                        user: userAddress,
                    },
                };
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            const withdrawFromStrategyTx = yield strategyHandler.withdraw(owner, this.program, {
                pubkey: selectedStrategy.publicKey,
                state: selectedStrategy.strategyState,
            }, this.vaultPda, this.tokenVaultPda, this.vaultState.feeVault, this.vaultState.lpMint, userToken, userLpToken, baseTokenAmount, preInstructions, postInstruction, withdrawOpt);
            if (withdrawFromStrategyTx instanceof Transaction) {
                return new Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawFromStrategyTx);
            }
            // Return error
            throw new Error(withdrawFromStrategyTx.error);
        });
    }
    // Reserved code to withdraw from Vault Reserves directly.
    // The only situation this piece of code will be required, is when a single Vault have no other strategy, and only have its own reserve.
    withdrawFromVaultReserve(owner, baseTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield getOrCreateATAInstruction(new PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield getOrCreateATAInstruction(this.vaultState.lpMint, owner, this.connection);
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            const withdrawTx = yield this.program.methods
                .withdraw(baseTokenAmount, new BN(0)) // Vault does not have slippage, second parameter is ignored.
                .accounts({
                vault: this.vaultPda,
                tokenVault: this.tokenVaultPda,
                lpMint: this.vaultState.lpMint,
                userToken,
                userLp: userLpToken,
                user: owner,
                tokenProgram: TOKEN_PROGRAM_ID,
            })
                .preInstructions(preInstructions)
                .postInstructions(postInstruction)
                .transaction();
            return new Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawTx);
        });
    }
    getAffiliateInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('No affiliateId or affiliate program found');
            const partner = this.affiliateId;
            const partnerToken = yield getAssociatedTokenAccount(new PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const partnerDetails = (yield this.affiliateProgram.account.partner.fetchNullable(partnerAddress));
            return partnerDetails;
        });
    }
}
//# sourceMappingURL=index.js.map