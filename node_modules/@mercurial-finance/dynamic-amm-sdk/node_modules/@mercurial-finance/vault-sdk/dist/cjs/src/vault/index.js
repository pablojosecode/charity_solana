"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const strategy_1 = require("./strategy");
const idl_1 = require("./idl");
const affiliate_idl_1 = require("./affiliate-idl");
const helper_1 = require("./helper");
const getVaultState = (vaultParams, program) => __awaiter(void 0, void 0, void 0, function* () {
    const { vaultPda, tokenVaultPda } = yield (0, utils_1.getVaultPdas)(new web3_js_1.PublicKey(vaultParams.address), new web3_js_1.PublicKey(program.programId));
    const vaultState = (yield program.account.vault.fetchNullable(vaultPda));
    const lpSupply = yield (0, utils_1.getLpSupply)(program.provider.connection, vaultState.lpMint);
    if (!vaultState) {
        throw 'Cannot get vault state';
    }
    return { vaultPda, tokenVaultPda, vaultState, lpSupply };
});
const getVaultLiquidity = (connection, tokenVaultPda) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultLiquidityResponse = yield connection.getAccountInfo(tokenVaultPda);
    if (!vaultLiquidityResponse)
        return null;
    const vaultLiquiditySerialize = (0, utils_1.deserializeAccount)(vaultLiquidityResponse.data);
    return (vaultLiquiditySerialize === null || vaultLiquiditySerialize === void 0 ? void 0 : vaultLiquiditySerialize.amount.toString()) || null;
});
class VaultImpl {
    constructor(program, vaultDetails, opt) {
        var _a;
        this.cluster = 'mainnet-beta';
        this.lpSupply = new anchor_1.BN(0);
        this.connection = program.provider.connection;
        this.cluster = (_a = opt === null || opt === void 0 ? void 0 : opt.cluster) !== null && _a !== void 0 ? _a : 'mainnet-beta';
        this.tokenInfo = vaultDetails.tokenInfo;
        this.program = program;
        this.affiliateProgram = opt === null || opt === void 0 ? void 0 : opt.affiliateProgram;
        this.affiliateId = opt === null || opt === void 0 ? void 0 : opt.affiliateId;
        this.vaultPda = vaultDetails.vaultPda;
        this.tokenVaultPda = vaultDetails.tokenVaultPda;
        this.vaultState = vaultDetails.vaultState;
        this.lpSupply = vaultDetails.lpSupply;
    }
    static create(connection, tokenInfo, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const { vaultPda, tokenVaultPda, vaultState, lpSupply } = yield getVaultState(tokenInfo, program);
            return new VaultImpl(program, { tokenInfo, vaultPda, tokenVaultPda, vaultState, lpSupply }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                    ? new anchor_1.Program(affiliate_idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || constants_1.AFFILIATE_PROGRAM_ID, provider)
                    : undefined }));
        });
    }
    getUserBalance(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const isAffiliated = this.affiliateId && this.affiliateProgram;
            const address = yield (() => __awaiter(this, void 0, void 0, function* () {
                // User deposit directly
                if (!isAffiliated) {
                    return yield (0, utils_1.getAssociatedTokenAccount)(this.vaultState.lpMint, owner);
                }
                // Get user affiliated address with the partner
                const { userLpToken } = yield this.createAffiliateATAPreInstructions(owner);
                return userLpToken;
            }))();
            const accountInfo = yield this.connection.getAccountInfo(address);
            if (!accountInfo) {
                return new anchor_1.BN(0);
            }
            const result = (0, utils_1.deserializeAccount)(accountInfo.data);
            if (result == undefined) {
                throw new Error('Failed to parse user account for LP token.');
            }
            return new anchor_1.BN(result.amount);
        });
    }
    /** To refetch the latest lpSupply */
    /** Use vaultImpl.lpSupply to use cached result */
    getVaultSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            const lpSupply = yield (0, utils_1.getLpSupply)(this.connection, this.vaultState.lpMint);
            this.lpSupply = lpSupply;
            return lpSupply;
        });
    }
    getWithdrawableAmount() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTime = yield (0, utils_1.getOnchainTime)(this.connection);
            return (0, helper_1.calculateWithdrawableAmount)(currentTime, this.vaultState);
        });
    }
    refreshVaultState() {
        return __awaiter(this, void 0, void 0, function* () {
            const { vaultState, lpSupply } = yield getVaultState(this.tokenInfo, this.program);
            this.vaultState = vaultState;
            this.lpSupply = lpSupply;
        });
    }
    createATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(new web3_js_1.PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.vaultState.lpMint, owner, this.connection);
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                userToken,
                userLpToken,
            };
        });
    }
    createAffiliateATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('Affiliate ID or program not found');
            const partner = this.affiliateId;
            const partnerToken = yield (0, utils_1.getAssociatedTokenAccount)(new web3_js_1.PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield web3_js_1.PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const [userAddress, _nonceUser] = yield web3_js_1.PublicKey.findProgramAddress([partnerAddress.toBuffer(), owner.toBuffer()], this.affiliateProgram.programId);
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(new web3_js_1.PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.vaultState.lpMint, userAddress, this.connection, {
                payer: owner,
                allowOwnerOffCurve: true,
            });
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                partner,
                partnerAddress,
                userAddress,
                userToken,
                userLpToken,
            };
        });
    }
    deposit(owner, baseTokenAmount) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            let preInstructions = [];
            let partnerAddress;
            let userAddress;
            let userToken;
            let userLpToken;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress: partnerAddressATA, userAddress: userAddressATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                partnerAddress = partnerAddressATA;
                userAddress = userAddressATA;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            // If it's SOL vault, wrap desired amount of SOL
            if (this.tokenInfo.address === constants_1.SOL_MINT.toString()) {
                preInstructions = preInstructions.concat((0, utils_1.wrapSOLInstruction)(owner, userToken, baseTokenAmount));
            }
            let depositTx;
            if (partnerAddress && userAddress && this.affiliateId && this.affiliateProgram) {
                const userPda = yield this.connection.getParsedAccountInfo(userAddress);
                if (!userPda || !((_a = userPda.value) === null || _a === void 0 ? void 0 : _a.data)) {
                    // Init first time user
                    preInstructions.push(yield this.affiliateProgram.methods
                        .initUser()
                        .accounts({
                        user: userAddress,
                        partner: partnerAddress,
                        owner,
                        systemProgram: web3_js_1.SystemProgram.programId,
                        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                    })
                        .instruction());
                }
                depositTx = yield this.affiliateProgram.methods
                    .deposit(new anchor_1.BN(baseTokenAmount.toString()), new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    partner: partnerAddress,
                    user: userAddress,
                    vaultProgram: this.program.programId,
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            else {
                depositTx = yield this.program.methods
                    .deposit(new anchor_1.BN(baseTokenAmount.toString()), new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(depositTx);
        });
    }
    getStrategyWithHighestLiquidity(strategy) {
        return __awaiter(this, void 0, void 0, function* () {
            // Reserved for testing
            if (strategy) {
                const strategyState = (yield this.program.account.strategy.fetchNullable(strategy));
                return { publicKey: strategy, strategyState };
            }
            const vaultStrategiesStatePromise = this.vaultState.strategies
                .filter((address) => address.toString() !== constants_1.VAULT_STRATEGY_ADDRESS)
                .map((strat) => __awaiter(this, void 0, void 0, function* () {
                const strategyState = (yield this.program.account.strategy.fetchNullable(strat));
                return { publicKey: strat, strategyState };
            }));
            const vaultStrategiesState = yield Promise.allSettled(vaultStrategiesStatePromise);
            const highestLiquidity = vaultStrategiesState
                .map((item) => (item.status === 'fulfilled' ? item.value : undefined))
                .sort((a, b) => {
                if (a && b) {
                    return b.strategyState.currentLiquidity.sub(a.strategyState.currentLiquidity).toNumber();
                }
                return 0;
            })[0];
            return highestLiquidity
                ? highestLiquidity
                : {
                    publicKey: new web3_js_1.PublicKey(constants_1.VAULT_STRATEGY_ADDRESS),
                    strategyState: null,
                };
        });
    }
    withdraw(owner, baseTokenAmount, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            // Get strategy with highest liquidity
            // opt.strategy reserved for testing
            const selectedStrategy = yield this.getStrategyWithHighestLiquidity(opt === null || opt === void 0 ? void 0 : opt.strategy);
            if (!selectedStrategy || // If there's no strategy deployed to the vault, use Vault Reserves instead
                selectedStrategy.publicKey.toString() === constants_1.VAULT_STRATEGY_ADDRESS || // If opt.strategy specified Vault Reserves
                !selectedStrategy.strategyState // If opt.strategy specified Vault Reserves
            ) {
                return this.withdrawFromVaultReserve(owner, baseTokenAmount);
            }
            const currentLiquidity = new anchor_1.BN(selectedStrategy.strategyState.currentLiquidity);
            const vaultLiquidty = new anchor_1.BN((yield getVaultLiquidity(this.connection, this.tokenVaultPda)) || 0);
            const unlockedAmount = yield this.getWithdrawableAmount();
            const virtualPrice = new anchor_1.BN(unlockedAmount).div(new anchor_1.BN(this.lpSupply));
            const availableAmount = currentLiquidity.add(vaultLiquidty);
            const amountToUnmint = new anchor_1.BN(baseTokenAmount).mul(virtualPrice);
            if (amountToUnmint.gt(availableAmount)) {
                throw new Error('Selected strategy does not have enough liquidity.');
            }
            const strategyType = (0, strategy_1.getStrategyType)(selectedStrategy.strategyState.strategyType);
            const strategyHandler = (0, strategy_1.getStrategyHandler)(strategyType, this.cluster, this.connection);
            if (!strategyType || !strategyHandler) {
                throw new Error('Cannot find strategy handler');
            }
            let preInstructions = [];
            let withdrawOpt = {};
            let userToken;
            let userLpToken;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress, userAddress, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                withdrawOpt = {
                    affiliate: {
                        affiliateId: this.affiliateId,
                        affiliateProgram: this.affiliateProgram,
                        partner: partnerAddress,
                        user: userAddress,
                    },
                };
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === constants_1.SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            const withdrawFromStrategyTx = yield strategyHandler.withdraw(owner, this.program, {
                pubkey: selectedStrategy.publicKey,
                state: selectedStrategy.strategyState,
            }, this.vaultPda, this.tokenVaultPda, this.vaultState.feeVault, this.vaultState.lpMint, userToken, userLpToken, baseTokenAmount, preInstructions, postInstruction, withdrawOpt);
            if (withdrawFromStrategyTx instanceof web3_js_1.Transaction) {
                return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawFromStrategyTx);
            }
            // Return error
            throw new Error(withdrawFromStrategyTx.error);
        });
    }
    // Reserved code to withdraw from Vault Reserves directly.
    // The only situation this piece of code will be required, is when a single Vault have no other strategy, and only have its own reserve.
    withdrawFromVaultReserve(owner, baseTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(new web3_js_1.PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.vaultState.lpMint, owner, this.connection);
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === constants_1.SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            const withdrawTx = yield this.program.methods
                .withdraw(baseTokenAmount, new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                .accounts({
                vault: this.vaultPda,
                tokenVault: this.tokenVaultPda,
                lpMint: this.vaultState.lpMint,
                userToken,
                userLp: userLpToken,
                user: owner,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            })
                .preInstructions(preInstructions)
                .postInstructions(postInstruction)
                .transaction();
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawTx);
        });
    }
    getAffiliateInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('No affiliateId or affiliate program found');
            const partner = this.affiliateId;
            const partnerToken = yield (0, utils_1.getAssociatedTokenAccount)(new web3_js_1.PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield web3_js_1.PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const partnerDetails = (yield this.affiliateProgram.account.partner.fetchNullable(partnerAddress));
            return partnerDetails;
        });
    }
}
exports.default = VaultImpl;
//# sourceMappingURL=index.js.map