"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateSwapQuote = exports.getDepegAccounts = exports.calculateMaxSwapOutAmount = exports.calculateTradingFee = exports.calculateAdminTradingFee = exports.calculatePoolInfo = exports.computeActualDepositAmount = exports.getOnchainTime = exports.unwrapSOLInstruction = exports.wrapSOLInstruction = exports.getOrCreateATAInstruction = exports.getMinAmountWithSlippage = exports.getMaxAmountWithSlippage = void 0;
const vault_sdk_1 = require("@mercurial-finance/vault-sdk");
const anchor_1 = require("@project-serum/anchor");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const invariant_1 = __importDefault(require("invariant"));
const constants_1 = require("./constants");
const curve_1 = require("./curve");
/**
 * It takes an amount and a slippage rate, and returns the maximum amount that can be received with
 * that slippage rate
 * @param {BN} amount - The amount of tokens you want to buy.
 * @param {number} slippageRate - The maximum percentage of slippage you're willing to accept. (Max to 2 decimal place)
 * @returns The maximum amount of tokens that can be bought with the given amount of ETH, given the
 * slippage rate.
 */
const getMaxAmountWithSlippage = (amount, slippageRate) => {
    const slippage = ((100 + slippageRate) / 100) * 10000;
    return amount.mul(new anchor_1.BN(slippage)).div(new anchor_1.BN(10000));
};
exports.getMaxAmountWithSlippage = getMaxAmountWithSlippage;
/**
 * It takes an amount and a slippage rate, and returns the minimum amount that will be received after
 * slippage
 * @param {BN} amount - The amount of tokens you want to sell.
 * @param {number} slippageRate - The percentage of slippage you're willing to accept. (Max to 2 decimal place)
 * @returns The minimum amount that can be received after slippage is applied.
 */
const getMinAmountWithSlippage = (amount, slippageRate) => {
    const slippage = ((100 - slippageRate) / 100) * 10000;
    return amount.mul(new anchor_1.BN(slippage)).div(new anchor_1.BN(10000));
};
exports.getMinAmountWithSlippage = getMinAmountWithSlippage;
const getOrCreateATAInstruction = (tokenMint, owner, connection) => __awaiter(void 0, void 0, void 0, function* () {
    let toAccount;
    try {
        toAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner);
        const account = yield connection.getAccountInfo(toAccount);
        if (!account) {
            const ix = spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, toAccount, owner, owner);
            return [toAccount, ix];
        }
        return [toAccount, undefined];
    }
    catch (e) {
        /* handle error */
        console.error('Error::getOrCreateATAInstruction', e);
        throw e;
    }
});
exports.getOrCreateATAInstruction = getOrCreateATAInstruction;
const wrapSOLInstruction = (from, to, amount) => {
    return [
        web3_js_1.SystemProgram.transfer({
            fromPubkey: from,
            toPubkey: to,
            lamports: amount,
        }),
        new web3_js_1.TransactionInstruction({
            keys: [
                {
                    pubkey: to,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            data: Buffer.from(new Uint8Array([17])),
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }),
    ];
};
exports.wrapSOLInstruction = wrapSOLInstruction;
const unwrapSOLInstruction = (owner) => __awaiter(void 0, void 0, void 0, function* () {
    const wSolATAAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, constants_1.WRAPPED_SOL_MINT, owner);
    if (wSolATAAccount) {
        const closedWrappedSolInstruction = spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, wSolATAAccount, owner, owner, []);
        return closedWrappedSolInstruction;
    }
    return null;
});
exports.unwrapSOLInstruction = unwrapSOLInstruction;
const getOnchainTime = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const parsedClock = yield connection.getParsedAccountInfo(web3_js_1.SYSVAR_CLOCK_PUBKEY);
    const parsedClockAccount = parsedClock.value.data.parsed;
    const currentTime = parsedClockAccount.info.unixTimestamp;
    return currentTime;
});
exports.getOnchainTime = getOnchainTime;
// Typescript implementation of https://github.com/mercurial-finance/mercurial-dynamic-amm/blob/main/programs/amm/src/state.rs#L87
const getLastVirtualPrice = (apyState) => {
    const { snapshot } = apyState;
    const virtualPrices = snapshot.virtualPrices;
    let prev = ((_) => {
        if (snapshot.pointer.eq(new anchor_1.BN(0))) {
            return virtualPrices.length - 1;
        }
        else {
            return snapshot.pointer.toNumber() - 1;
        }
    })();
    const virtualPrice = virtualPrices[prev];
    if (virtualPrice.price.eq(new anchor_1.BN(0))) {
        return null;
    }
    return virtualPrice;
};
// Typescript implementation of https://github.com/mercurial-finance/mercurial-dynamic-amm/blob/main/programs/amm/src/state.rs#L101
const getFirstVirtualPrice = (apyState) => {
    const { snapshot } = apyState;
    let initial = snapshot.pointer.toNumber();
    let current = initial;
    const virtualPrices = snapshot.virtualPrices;
    while ((current + 1) % virtualPrices.length != initial) {
        if (virtualPrices[current].price.eq(new anchor_1.BN(0))) {
            current = (current + 1) % virtualPrices.length;
        }
        else {
            break;
        }
    }
    let virtualPrice = virtualPrices[current];
    if (virtualPrice.price.eq(new anchor_1.BN(0))) {
        return null;
    }
    return virtualPrice;
};
/**
 * Compute "actual" amount deposited to vault (precision loss)
 * @param depositAmount
 * @param beforeAmount
 * @param vaultLpBalance
 * @param vaultLpSupply
 * @param vaultTotalAmount
 * @returns
 */
const computeActualDepositAmount = (depositAmount, beforeAmount, vaultLpBalance, vaultLpSupply, vaultTotalAmount) => {
    if (depositAmount.eq(new anchor_1.BN(0)))
        return depositAmount;
    const vaultLpMinted = depositAmount.mul(vaultLpSupply).div(vaultTotalAmount);
    vaultLpSupply = vaultLpSupply.add(vaultLpMinted);
    vaultTotalAmount = vaultTotalAmount.add(depositAmount);
    vaultLpBalance = vaultLpBalance.add(vaultLpMinted);
    const afterAmount = vaultLpBalance.mul(vaultTotalAmount).div(vaultLpSupply);
    return afterAmount.sub(beforeAmount);
};
exports.computeActualDepositAmount = computeActualDepositAmount;
/**
 * Compute pool information, Typescript implementation of https://github.com/mercurial-finance/mercurial-dynamic-amm/blob/main/programs/amm/src/lib.rs#L960
 * @param {number} currentTime - the on solana chain time in seconds (SYSVAR_CLOCK_PUBKEY)
 * @param {BN} poolVaultALp - The amount of LP tokens in the pool for token A
 * @param {BN} poolVaultBLp - The amount of Lp tokens in the pool for token B,
 * @param {BN} vaultALpSupply - The total amount of Vault A LP tokens in the pool.
 * @param {BN} vaultBLpSupply - The total amount of Vault B LP token in the pool.
 * @param {BN} poolLpSupply - The total amount of LP tokens in the pool.
 * @param {ApyState} apyState - ApyState
 * @param {SwapCurve} swapCurve - SwapCurve - the swap curve used to calculate the virtual price
 * @param {VaultState} vaultA - VaultState of vault A
 * @param {VaultState} vaultB - VaultState of Vault B
 * @returns an object of type PoolInformation.
 */
const calculatePoolInfo = (currentTime, poolVaultALp, poolVaultBLp, vaultALpSupply, vaultBLpSupply, poolLpSupply, apyState, swapCurve, vaultA, vaultB) => {
    const currentTimestamp = new anchor_1.BN(currentTime);
    const vaultAWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(currentTime, vaultA);
    const vaultBWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(currentTime, vaultB);
    const tokenAAmount = (0, vault_sdk_1.getAmountByShare)(poolVaultALp, vaultAWithdrawableAmount, vaultALpSupply);
    const tokenBAmount = (0, vault_sdk_1.getAmountByShare)(poolVaultBLp, vaultBWithdrawableAmount, vaultBLpSupply);
    let firstTimestamp = new anchor_1.BN(0);
    let apy, virtualPriceNumber, firstVirtualPriceNumber = 0;
    const d = swapCurve.computeD(tokenAAmount, tokenBAmount);
    let latestVirtualPrice = d.mul(constants_1.VIRTUAL_PRICE_PRECISION).div(poolLpSupply);
    if (latestVirtualPrice.eq(new anchor_1.BN(0))) {
        const lastVirtualPrice = getLastVirtualPrice(apyState);
        if (lastVirtualPrice) {
            latestVirtualPrice = lastVirtualPrice.price;
        }
    }
    const firstVirtualPrice = getFirstVirtualPrice(apyState);
    if (firstVirtualPrice && latestVirtualPrice.gt(new anchor_1.BN(0))) {
        // Compute APY
        const second = latestVirtualPrice.toNumber() / constants_1.VIRTUAL_PRICE_PRECISION.toNumber();
        const first = firstVirtualPrice.price.toNumber() / constants_1.VIRTUAL_PRICE_PRECISION.toNumber();
        const timeElapsed = currentTimestamp.sub(firstVirtualPrice.timestamp).toNumber();
        const rate = second / first;
        const frequency = (365 * 24 * 3600) / timeElapsed;
        const compoundRate = Math.pow(rate, frequency);
        apy = (compoundRate - 1) * 100;
        virtualPriceNumber = second;
        firstVirtualPriceNumber = first;
        firstTimestamp = firstVirtualPrice.timestamp;
    }
    const poolInformation = {
        tokenAAmount,
        tokenBAmount,
        currentTimestamp,
        apy,
        firstTimestamp,
        firstVirtualPrice: firstVirtualPriceNumber,
        virtualPrice: virtualPriceNumber,
    };
    return poolInformation;
};
exports.calculatePoolInfo = calculatePoolInfo;
const calculateAdminTradingFee = (amount, poolState) => {
    const { ownerTradeFeeDenominator, ownerTradeFeeNumerator } = poolState.fees;
    return amount.mul(ownerTradeFeeNumerator).div(ownerTradeFeeDenominator);
};
exports.calculateAdminTradingFee = calculateAdminTradingFee;
const calculateTradingFee = (amount, poolState) => {
    const { tradeFeeDenominator, tradeFeeNumerator } = poolState.fees;
    return amount.mul(tradeFeeNumerator).div(tradeFeeDenominator);
};
exports.calculateTradingFee = calculateTradingFee;
/**
 * "Calculate the maximum amount of tokens that can be swapped out of a pool."
 *
 * @param {PublicKey} tokenMint - The mint that want to swap out
 * @param {PublicKey} tokenAMint - The public key of the token A mint.
 * @param {PublicKey} tokenBMint - The public key of the token B mint.
 * @param {BN} tokenAAmount - The amount of token A that the user wants to swap out.
 * @param {BN} tokenBAmount - The amount of token B that the user wants to swap out.
 * @param {BN} vaultAReserve - The amount of tokenA that the vault has in reserve.
 * @param {BN} vaultBReserve - The amount of tokenB that the vault has in reserve.
 * @returns The max amount of tokens that can be swapped out.
 */
const calculateMaxSwapOutAmount = (tokenMint, tokenAMint, tokenBMint, tokenAAmount, tokenBAmount, vaultAReserve, vaultBReserve) => {
    (0, invariant_1.default)(tokenMint.equals(tokenAMint) || tokenMint.equals(tokenBMint), constants_1.ERROR.INVALID_MINT);
    const [outTotalAmount, outReserveBalance] = tokenMint.equals(tokenAMint)
        ? [tokenAAmount, vaultAReserve]
        : [tokenBAmount, vaultBReserve];
    return outTotalAmount.gt(outReserveBalance) ? outReserveBalance : outTotalAmount;
};
exports.calculateMaxSwapOutAmount = calculateMaxSwapOutAmount;
/**
 * It gets the account info for the two accounts that are used in depeg Pool
 * @param {Connection} connection - Connection - The connection to the Solana cluster
 * @returns A map of the depeg accounts.
 */
const getDepegAccounts = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const depegAccounts = new Map();
    const [marinadeBuffer, solidoBuffer] = yield connection.getMultipleAccountsInfo([
        constants_1.CURVE_TYPE_ACCOUNTS.marinade,
        constants_1.CURVE_TYPE_ACCOUNTS.lido,
    ]);
    depegAccounts.set(constants_1.CURVE_TYPE_ACCOUNTS.marinade.toBase58(), marinadeBuffer);
    depegAccounts.set(constants_1.CURVE_TYPE_ACCOUNTS.lido.toBase58(), solidoBuffer);
    return depegAccounts;
});
exports.getDepegAccounts = getDepegAccounts;
/**
 * It calculates the amount of tokens you will receive after swapping your tokens
 * @param {PublicKey} inTokenMint - The mint of the token you're swapping in.
 * @param {BN} inAmountLamport - The amount of the input token you want to swap.
 * @param {SwapQuoteParam} params - SwapQuoteParam
 * @param {PoolState} params.poolState - pool state that fetch from program
 * @param {VaultState} params.vaultA - vault A state that fetch from vault program
 * @param {VaultState} params.vaultB - vault B state that fetch from vault program
 * @param {BN} params.poolVaultALp - The amount of LP tokens in the pool for token A (`PoolState.aVaultLp` accountInfo)
 * @param {BN} params.poolVaultBLp - The amount of LP tokens in the pool for token B (`PoolState.bVaultLp` accountInfo)
 * @param {BN} params.vaultALpSupply - vault A lp supply (`VaultState.lpMint` accountInfo)
 * @param {BN} params.vaultBLpSupply - vault B lp supply (`VaultState.lpMint` accountInfo)
 * @param {BN} params.vaultAReserve - vault A reserve (`VaultState.tokenVault` accountInfo)
 * @param {BN} params.vaultBReserve - vault B reserve (`VaultState.tokenVault` accountInfo)
 * @param {BN} params.currentTime - on chain time (use `SYSVAR_CLOCK_PUBKEY`)
 * @param {BN} params.depegAccounts - A map of the depeg accounts. (get from `getDepegAccounts` util)
 * @returns The amount of tokens that will be received after the swap.
 */
const calculateSwapQuote = (inTokenMint, inAmountLamport, params) => {
    const { vaultA, vaultB, vaultALpSupply, vaultBLpSupply, poolState, poolVaultALp, poolVaultBLp, currentTime, depegAccounts, vaultAReserve, vaultBReserve, } = params;
    const { tokenAMint, tokenBMint } = poolState;
    (0, invariant_1.default)(inTokenMint.equals(tokenAMint) || inTokenMint.equals(tokenBMint), constants_1.ERROR.INVALID_MINT);
    let swapCurve;
    if ('stable' in poolState.curveType) {
        const { amp, depeg, tokenMultiplier } = poolState.curveType['stable'];
        swapCurve = new curve_1.StableSwap(amp.toNumber(), tokenMultiplier, depeg, depegAccounts, currentTime);
    }
    else {
        swapCurve = new curve_1.ConstantProductSwap();
    }
    const vaultAWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(currentTime, vaultA);
    const vaultBWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(currentTime, vaultB);
    const tokenAAmount = (0, vault_sdk_1.getAmountByShare)(poolVaultALp, vaultAWithdrawableAmount, vaultALpSupply);
    const tokenBAmount = (0, vault_sdk_1.getAmountByShare)(poolVaultBLp, vaultBWithdrawableAmount, vaultBLpSupply);
    const isFromAToB = inTokenMint.equals(tokenAMint);
    const [sourceAmount, swapSourceAmount, swapDestinationAmount, swapSourceVault, swapDestinationVault, swapSourceVaultLpSupply, swapDestinationVaultLpSupply, tradeDirection,] = isFromAToB
        ? [inAmountLamport, tokenAAmount, tokenBAmount, vaultA, vaultB, vaultALpSupply, vaultBLpSupply, curve_1.TradeDirection.AToB]
        : [
            inAmountLamport,
            tokenBAmount,
            tokenAAmount,
            vaultB,
            vaultA,
            vaultBLpSupply,
            vaultALpSupply,
            curve_1.TradeDirection.BToA,
        ];
    const adminFee = (0, exports.calculateAdminTradingFee)(sourceAmount, poolState);
    const tradeFee = (0, exports.calculateTradingFee)(sourceAmount, poolState);
    const sourceVaultWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(currentTime, swapSourceVault);
    // Get vault lp minted when deposit to the vault
    const sourceVaultLp = (0, vault_sdk_1.getUnmintAmount)(sourceAmount.sub(adminFee), sourceVaultWithdrawableAmount, swapSourceVaultLpSupply);
    const actualSourceAmount = (0, vault_sdk_1.getAmountByShare)(sourceVaultLp, sourceVaultWithdrawableAmount, swapSourceVaultLpSupply);
    let sourceAmountWithFee = actualSourceAmount.sub(tradeFee);
    const destinationAmount = swapCurve.computeOutAmount(sourceAmountWithFee, swapSourceAmount, swapDestinationAmount, tradeDirection);
    const destinationVaultWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(currentTime, swapDestinationVault);
    // Get vault lp to burn when withdraw from the vault
    const destinationVaultLp = (0, vault_sdk_1.getUnmintAmount)(destinationAmount, destinationVaultWithdrawableAmount, swapDestinationVaultLpSupply);
    let actualDestinationAmount = (0, vault_sdk_1.getAmountByShare)(destinationVaultLp, destinationVaultWithdrawableAmount, swapDestinationVaultLpSupply);
    const maxSwapOutAmount = (0, exports.calculateMaxSwapOutAmount)(tradeDirection == curve_1.TradeDirection.AToB ? tokenBMint : tokenAMint, tokenAMint, tokenBMint, tokenAAmount, tokenBAmount, vaultAReserve, vaultBReserve);
    (0, invariant_1.default)(actualDestinationAmount.lt(maxSwapOutAmount), 'Out amount > vault reserve');
    return {
        amountOut: actualDestinationAmount,
        fee: adminFee.add(tradeFee),
    };
};
exports.calculateSwapQuote = calculateSwapQuote;
//# sourceMappingURL=utils.js.map