"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const token_1 = require("@project-serum/anchor/dist/cjs/utils/token");
const vault_sdk_1 = __importStar(require("@mercurial-finance/vault-sdk"));
const invariant_1 = __importDefault(require("invariant"));
const idl_1 = require("./idl");
const vault_idl_1 = require("./vault-idl");
const constants_1 = require("./constants");
const curve_1 = require("./curve");
const constant_product_1 = require("./curve/constant-product");
const utils_1 = require("./utils");
const getPoolState = (poolMint, program) => __awaiter(void 0, void 0, void 0, function* () {
    const poolState = (yield program.account.pool.fetchNullable(poolMint));
    (0, invariant_1.default)(poolState, `Pool ${poolMint.toBase58()} not found`);
    const account = yield program.provider.connection.getTokenSupply(poolState.lpMint);
    (0, invariant_1.default)(account.value.amount, constants_1.ERROR.INVALID_ACCOUNT);
    return Object.assign(Object.assign({}, poolState), { lpSupply: new anchor_1.BN(account.value.amount) });
});
const getRemainingAccounts = (poolState) => {
    let accounts = [];
    if ('stable' in poolState.curveType) {
        if ('marinade' in poolState.curveType['stable'].depeg.depegType) {
            accounts.push({
                pubkey: constants_1.CURVE_TYPE_ACCOUNTS.marinade,
                isWritable: false,
                isSigner: false,
            });
        }
        if ('lido' in poolState.curveType['stable'].depeg.depegType) {
            accounts.push({
                pubkey: constants_1.CURVE_TYPE_ACCOUNTS.lido,
                isWritable: false,
                isSigner: false,
            });
        }
    }
    return accounts;
};
const getAccountsBuffer = ({ connection, vaultA, vaultB, apyPda, poolState, }) => __awaiter(void 0, void 0, void 0, function* () {
    return connection.getMultipleAccountsInfo([
        apyPda,
        vaultA.tokenVault,
        vaultB.tokenVault,
        vaultA.lpMint,
        vaultB.lpMint,
        poolState.aVaultLp,
        poolState.bVaultLp,
        poolState.lpMint,
        web3_js_1.SYSVAR_CLOCK_PUBKEY,
    ]);
});
// param order need to be the same from `getAccountsBuffer`
const deserializeAccountsBuffer = ([apyPdaBuffer, vaultAReserveBuffer, vaultBReserveBuffer, vaultALpMintBuffer, vaultBLpMintBuffer, poolVaultALpBuffer, poolVaultBLpBuffer, poolLpMintBuffer, clockAccountBuffer,]) => {
    const poolCoder = new anchor_1.BorshCoder(idl_1.IDL);
    const apy = poolCoder.accounts.decode('apy', apyPdaBuffer.data);
    const vaultAReserveInfo = spl_token_1.AccountLayout.decode(vaultAReserveBuffer.data);
    const vaultBReserveInfo = spl_token_1.AccountLayout.decode(vaultBReserveBuffer.data);
    const vaultALpMintInfo = spl_token_1.MintLayout.decode(vaultALpMintBuffer.data);
    const vaultBLpMintInfo = spl_token_1.MintLayout.decode(vaultBLpMintBuffer.data);
    const poolVaultALpInfo = spl_token_1.AccountLayout.decode(poolVaultALpBuffer.data);
    const poolVaultBLpInfo = spl_token_1.AccountLayout.decode(poolVaultBLpBuffer.data);
    const poolLpMintInfo = spl_token_1.MintLayout.decode(poolLpMintBuffer.data);
    return {
        apy,
        vaultAReserve: new anchor_1.BN(spl_token_1.u64.fromBuffer(vaultAReserveInfo.amount)),
        vaultBReserve: new anchor_1.BN(spl_token_1.u64.fromBuffer(vaultBReserveInfo.amount)),
        vaultALpSupply: new anchor_1.BN(spl_token_1.u64.fromBuffer(vaultALpMintInfo.supply)),
        vaultBLpSupply: new anchor_1.BN(spl_token_1.u64.fromBuffer(vaultBLpMintInfo.supply)),
        poolVaultALp: new anchor_1.BN(spl_token_1.u64.fromBuffer(poolVaultALpInfo.amount)),
        poolVaultBLp: new anchor_1.BN(spl_token_1.u64.fromBuffer(poolVaultBLpInfo.amount)),
        poolLpSupply: new anchor_1.BN(spl_token_1.u64.fromBuffer(poolLpMintInfo.supply)),
        currentTime: new anchor_1.BN(clockAccountBuffer.data.readBigInt64LE(32).toString()).toNumber(),
    };
};
class AmmImpl {
    constructor(address, program, vaultProgram, apyPda, tokenInfos, poolState, poolInfo, vaultA, vaultB, accountsInfo, swapCurve, depegAccounts, opt) {
        this.address = address;
        this.program = program;
        this.vaultProgram = vaultProgram;
        this.apyPda = apyPda;
        this.tokenInfos = tokenInfos;
        this.poolState = poolState;
        this.poolInfo = poolInfo;
        this.vaultA = vaultA;
        this.vaultB = vaultB;
        this.accountsInfo = accountsInfo;
        this.swapCurve = swapCurve;
        this.depegAccounts = depegAccounts;
        this.opt = {
            cluster: 'mainnet-beta',
        };
        this.opt = Object.assign(Object.assign({}, this.opt), opt);
    }
    static create(connection, pool, tokenInfoA, tokenInfoB, opt) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const cluster = (_a = opt === null || opt === void 0 ? void 0 : opt.cluster) !== null && _a !== void 0 ? _a : 'mainnet-beta';
            const ammProgram = new anchor_1.Program(idl_1.IDL, constants_1.PROGRAM_ID, provider);
            const vaultProgram = new anchor_1.Program(vault_idl_1.IDL, constants_1.VAULT_PROGRAM_ID, provider);
            const [apyPda] = yield web3_js_1.PublicKey.findProgramAddress([Buffer.from(constants_1.SEEDS.APY), pool.toBuffer()], ammProgram.programId);
            const poolState = yield getPoolState(pool, ammProgram);
            (0, invariant_1.default)(tokenInfoA.address === poolState.tokenAMint.toBase58(), `TokenInfoA provided is incorrect`);
            (0, invariant_1.default)(tokenInfoB.address === poolState.tokenBMint.toBase58(), `TokenInfoB provided is incorrect`);
            (0, invariant_1.default)(tokenInfoA, `TokenInfo ${poolState.tokenAMint.toBase58()} A not found`);
            (0, invariant_1.default)(tokenInfoB, `TokenInfo ${poolState.tokenBMint.toBase58()} A not found`);
            const [vaultA, vaultB] = yield Promise.all([
                vault_sdk_1.default.create(provider.connection, tokenInfoA, { cluster }),
                vault_sdk_1.default.create(provider.connection, tokenInfoB, { cluster }),
            ]);
            const accountsBuffer = yield getAccountsBuffer({
                connection: provider.connection,
                vaultA: vaultA.vaultState,
                vaultB: vaultB.vaultState,
                apyPda,
                poolState,
            });
            const accountsInfo = deserializeAccountsBuffer(accountsBuffer);
            const depegAccounts = yield (0, utils_1.getDepegAccounts)(ammProgram.provider.connection);
            let swapCurve;
            if ('stable' in poolState.curveType) {
                const { amp, depeg, tokenMultiplier } = poolState.curveType['stable'];
                swapCurve = new curve_1.StableSwap(amp.toNumber(), tokenMultiplier, depeg, depegAccounts, accountsInfo.currentTime);
            }
            else {
                swapCurve = new constant_product_1.ConstantProductSwap();
            }
            const poolInfo = (0, utils_1.calculatePoolInfo)(accountsInfo.currentTime, accountsInfo.poolVaultALp, accountsInfo.poolVaultBLp, accountsInfo.vaultALpSupply, accountsInfo.vaultBLpSupply, accountsInfo.poolLpSupply, accountsInfo.apy, swapCurve, vaultA.vaultState, vaultB.vaultState);
            return new AmmImpl(pool, ammProgram, vaultProgram, apyPda, [tokenInfoA, tokenInfoB], poolState, poolInfo, vaultA, vaultB, accountsInfo, swapCurve, depegAccounts, {
                cluster,
            });
        });
    }
    get tokenA() {
        return this.tokenInfos[0];
    }
    get tokenB() {
        return this.tokenInfos[1];
    }
    get decimals() {
        return Math.max(this.tokenA.decimals, this.tokenB.decimals);
    }
    get isStablePool() {
        return 'stable' in this.poolState.curveType;
    }
    /**
     * It updates the state of the pool
     */
    updateState() {
        return __awaiter(this, void 0, void 0, function* () {
            const [poolState] = yield Promise.all([
                getPoolState(this.address, this.program),
                this.vaultA.refreshVaultState(),
                this.vaultB.refreshVaultState(),
            ]);
            // update spl info
            const accountsBuffer = yield getAccountsBuffer({
                poolState,
                connection: this.program.provider.connection,
                vaultA: this.vaultA.vaultState,
                vaultB: this.vaultB.vaultState,
                apyPda: this.apyPda,
            });
            this.accountsInfo = deserializeAccountsBuffer(accountsBuffer);
            if (this.isStablePool) {
                // update swap curve
                const { amp, depeg, tokenMultiplier } = poolState.curveType['stable'];
                this.swapCurve = new curve_1.StableSwap(amp.toNumber(), tokenMultiplier, depeg, this.depegAccounts, this.accountsInfo.currentTime);
            }
            const poolInfo = (0, utils_1.calculatePoolInfo)(this.accountsInfo.currentTime, this.accountsInfo.poolVaultALp, this.accountsInfo.poolVaultBLp, this.accountsInfo.vaultALpSupply, this.accountsInfo.vaultBLpSupply, this.accountsInfo.poolLpSupply, this.accountsInfo.apy, this.swapCurve, this.vaultA.vaultState, this.vaultB.vaultState);
            this.poolState = Object.assign(Object.assign({}, poolState), poolInfo);
        });
    }
    /**
     * It returns the pool token mint.
     * @returns The poolState.lpMint
     */
    getPoolTokenMint() {
        return this.poolState.lpMint;
    }
    /**
     * It gets the total supply of the LP token
     * @returns The total supply of the LP token.
     */
    getLpSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.program.provider.connection.getTokenSupply(this.poolState.lpMint);
            (0, invariant_1.default)(account.value.amount, constants_1.ERROR.INVALID_ACCOUNT);
            return new anchor_1.BN(account.value.amount);
        });
    }
    /**
     * Get the user's balance by looking up the account associated with the user's public key
     * @param {PublicKey} owner - PublicKey - The public key of the user you want to get the balance of
     * @returns The amount of tokens the user has.
     */
    getUserBalance(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield spl_token_1.Token.getAssociatedTokenAddress(token_1.ASSOCIATED_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, this.poolState.lpMint, owner);
            if (!account)
                return new anchor_1.BN(0);
            const parsedAccountInfo = yield this.program.provider.connection.getParsedAccountInfo(account);
            if (!parsedAccountInfo.value)
                return new anchor_1.BN(0);
            const accountInfoData = parsedAccountInfo.value.data.parsed;
            return new anchor_1.BN(accountInfoData.info.tokenAmount.amount);
        });
    }
    /**
     * `getSwapQuote` returns the amount of `outToken` that you will receive if you swap
     * `inAmountLamport` of `inToken` into the pool
     * @param {PublicKey} inTokenMint - The mint you want to swap from.
     * @param {BN} inAmountLamport - The amount of lamports you want to swap.
     * @param {number} [slippage] - The maximum amount of slippage you're willing to accept. (Max to 2 decimal place)
     * @returns The amount of the destination token that will be received after the swap.
     */
    getSwapQuote(inTokenMint, inAmountLamport, slippage) {
        const { amountOut: swapQuote } = (0, utils_1.calculateSwapQuote)(inTokenMint, inAmountLamport, {
            currentTime: this.accountsInfo.currentTime,
            poolState: this.poolState,
            depegAccounts: this.depegAccounts,
            poolVaultALp: this.accountsInfo.poolVaultALp,
            poolVaultBLp: this.accountsInfo.poolVaultBLp,
            vaultA: this.vaultA.vaultState,
            vaultB: this.vaultB.vaultState,
            vaultALpSupply: this.accountsInfo.vaultALpSupply,
            vaultBLpSupply: this.accountsInfo.vaultBLpSupply,
            vaultAReserve: this.accountsInfo.vaultAReserve,
            vaultBReserve: this.accountsInfo.vaultBReserve,
        });
        return (0, utils_1.getMinAmountWithSlippage)(swapQuote, slippage);
    }
    /**
     * Get maximum in amount (source amount) for swap
     * !!! NOTE it is just estimation
     * @param tokenMint
     */
    getMaxSwapInAmount(tokenMint) {
        // Get maximum in amount by swapping maximum withdrawable amount of tokenMint in the pool
        (0, invariant_1.default)(tokenMint.equals(this.poolState.tokenAMint) || tokenMint.equals(this.poolState.tokenBMint), constants_1.ERROR.INVALID_MINT);
        const [outTokenMint, swapSourceAmount, swapDestAmount, tradeDirection] = tokenMint.equals(this.poolState.tokenAMint)
            ? [this.poolState.tokenBMint, this.poolInfo.tokenAAmount, this.poolInfo.tokenBAmount, curve_1.TradeDirection.AToB]
            : [this.poolState.tokenAMint, this.poolInfo.tokenBAmount, this.poolInfo.tokenAAmount, curve_1.TradeDirection.BToA];
        let maxOutAmount = this.getMaxSwapOutAmount(outTokenMint);
        // Impossible to deplete the pool, therefore if maxOutAmount is equals to tokenAmount in pool, subtract it by 1
        if (maxOutAmount.eq(swapDestAmount)) {
            maxOutAmount = maxOutAmount.sub(new anchor_1.BN(1)); // Left 1 token in pool
        }
        let maxInAmount = this.swapCurve.computeInAmount(maxOutAmount, swapSourceAmount, swapDestAmount, tradeDirection);
        const adminFee = this.calculateAdminTradingFee(maxInAmount);
        const tradeFee = this.calculateTradingFee(maxInAmount);
        maxInAmount = maxInAmount.sub(adminFee);
        maxInAmount = maxInAmount.sub(tradeFee);
        return maxInAmount;
    }
    /**
     * `getMaxSwapOutAmount` returns the maximum amount of tokens that can be swapped out of the pool
     * @param {PublicKey} tokenMint - The mint of the token you want to swap out.
     * @returns The maximum amount of tokens that can be swapped out of the pool.
     */
    getMaxSwapOutAmount(tokenMint) {
        return (0, utils_1.calculateMaxSwapOutAmount)(tokenMint, this.poolState.tokenAMint, this.poolState.tokenBMint, this.poolInfo.tokenAAmount, this.poolInfo.tokenBAmount, this.accountsInfo.vaultAReserve, this.accountsInfo.vaultBReserve);
    }
    /**
     * `swap` is a function that takes in a `PublicKey` of the owner, a `PublicKey` of the input token
     * mint, an `BN` of the input amount of lamports, and an `BN` of the output amount of lamports. It
     * returns a `Promise<Transaction>` of the swap transaction
     * @param {PublicKey} owner - The public key of the user who is swapping
     * @param {PublicKey} inTokenMint - The mint of the token you're swapping from.
     * @param {BN} inAmountLamport - The amount of the input token you want to swap.
     * @param {BN} outAmountLamport - The minimum amount of the output token you want to receive.
     * @returns A transaction object
     */
    swap(owner, inTokenMint, inAmountLamport, outAmountLamport) {
        return __awaiter(this, void 0, void 0, function* () {
            const [sourceToken, destinationToken] = this.tokenA.address === inTokenMint.toBase58()
                ? [this.poolState.tokenAMint, this.poolState.tokenBMint]
                : [this.poolState.tokenBMint, this.poolState.tokenAMint];
            const adminTokenFee = this.tokenA.address === inTokenMint.toBase58() ? this.poolState.adminTokenAFee : this.poolState.adminTokenBFee;
            let preInstructions = [];
            const [[userSourceToken, createUserSourceIx], [userDestinationToken, createUserDestinationIx]] = yield this.createATAPreInstructions(owner, [sourceToken, destinationToken]);
            createUserSourceIx && preInstructions.push(createUserSourceIx);
            createUserDestinationIx && preInstructions.push(createUserDestinationIx);
            if (sourceToken.equals(constants_1.WRAPPED_SOL_MINT)) {
                preInstructions = preInstructions.concat((0, utils_1.wrapSOLInstruction)(owner, userSourceToken, inAmountLamport.toNumber()));
            }
            preInstructions.push(yield this.getApySyncInstructions());
            const postInstructions = [];
            if (constants_1.WRAPPED_SOL_MINT.equals(destinationToken)) {
                const unwrapSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                unwrapSOLIx && postInstructions.push(unwrapSOLIx);
            }
            const swapTx = yield this.program.methods
                .swap(inAmountLamport, outAmountLamport)
                .accounts({
                aTokenVault: this.vaultA.vaultState.tokenVault,
                bTokenVault: this.vaultB.vaultState.tokenVault,
                aVault: this.poolState.aVault,
                bVault: this.poolState.bVault,
                aVaultLp: this.poolState.aVaultLp,
                bVaultLp: this.poolState.bVaultLp,
                aVaultLpMint: this.vaultA.vaultState.lpMint,
                bVaultLpMint: this.vaultB.vaultState.lpMint,
                userSourceToken,
                userDestinationToken,
                user: owner,
                adminTokenFee,
                pool: this.address,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                vaultProgram: this.vaultProgram.programId,
            })
                .remainingAccounts(getRemainingAccounts(this.poolState))
                .preInstructions(preInstructions)
                .postInstructions(postInstructions)
                .transaction();
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.program.provider.connection.getLatestBlockhash('finalized')))).add(swapTx);
        });
    }
    /**
     * `getDepositQuote` is a function that takes in a tokenAInAmount, tokenBInAmount, balance, and
     * slippage, and returns a poolTokenAmountOut, tokenAInAmount, and tokenBInAmount. `tokenAInAmount` or `tokenBAmount`
     * can be zero for balance deposit quote.
     * @param {BN} tokenAInAmount - The amount of token A to be deposit,
     * @param {BN} tokenBInAmount - The amount of token B to be deposit,
     * @param {boolean} [balance] - return false if the deposit is imbalance
     * @param {number} [slippage] - The amount of slippage you're willing to accept. (Max to 2 decimal place)
     * @returns The return value is a tuple of the poolTokenAmountOut, tokenAInAmount, and
     * tokenBInAmount.
     */
    getDepositQuote(tokenAInAmount, tokenBInAmount, balance, slippage) {
        (0, invariant_1.default)(!(!this.isStablePool && !tokenAInAmount.isZero() && !tokenBInAmount.isZero()), 'Constant product only supports balanced deposit');
        (0, invariant_1.default)(!(!tokenAInAmount.isZero() && !tokenBInAmount.isZero() && balance), 'Deposit balance is not possible when both token in amount is non-zero');
        const vaultAWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(this.accountsInfo.currentTime, this.vaultA.vaultState);
        const vaultBWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(this.accountsInfo.currentTime, this.vaultB.vaultState);
        if (tokenAInAmount.isZero() && balance) {
            const poolTokenAmountOut = this.getShareByAmount(tokenBInAmount, this.poolInfo.tokenBAmount, this.accountsInfo.poolLpSupply);
            // Calculate for stable pool balance deposit but used `addImbalanceLiquidity`
            if (this.isStablePool) {
                return {
                    poolTokenAmountOut: (0, utils_1.getMinAmountWithSlippage)(poolTokenAmountOut, slippage),
                    tokenAInAmount: tokenBInAmount.mul(this.poolInfo.tokenAAmount).div(this.poolInfo.tokenBAmount),
                    tokenBInAmount,
                };
            }
            // Constant product pool balance deposit
            const [actualTokenAInAmount, actualTokenBInAmount] = this.computeActualInAmount(poolTokenAmountOut, this.accountsInfo.poolLpSupply, this.accountsInfo.poolVaultALp, this.accountsInfo.poolVaultBLp, this.accountsInfo.vaultALpSupply, this.accountsInfo.vaultBLpSupply, vaultAWithdrawableAmount, vaultBWithdrawableAmount);
            return {
                poolTokenAmountOut: (0, utils_1.getMinAmountWithSlippage)(poolTokenAmountOut, constants_1.UNLOCK_AMOUNT_BUFFER),
                tokenAInAmount: (0, utils_1.getMaxAmountWithSlippage)(actualTokenAInAmount, slippage),
                tokenBInAmount: (0, utils_1.getMaxAmountWithSlippage)(actualTokenBInAmount, slippage),
            };
        }
        if (tokenBInAmount.isZero() && balance) {
            const poolTokenAmountOut = this.getShareByAmount(tokenAInAmount, this.poolInfo.tokenAAmount, this.accountsInfo.poolLpSupply);
            // Calculate for stable pool balance deposit but used `addImbalanceLiquidity`
            if (this.isStablePool) {
                return {
                    poolTokenAmountOut: (0, utils_1.getMinAmountWithSlippage)(poolTokenAmountOut, slippage),
                    tokenAInAmount,
                    tokenBInAmount: tokenAInAmount.mul(this.poolInfo.tokenBAmount).div(this.poolInfo.tokenAAmount),
                };
            }
            // Constant product pool
            const [actualTokenAInAmount, actualTokenBInAmount] = this.computeActualInAmount(poolTokenAmountOut, this.accountsInfo.poolLpSupply, this.accountsInfo.poolVaultALp, this.accountsInfo.poolVaultBLp, this.accountsInfo.vaultALpSupply, this.accountsInfo.vaultBLpSupply, vaultAWithdrawableAmount, vaultBWithdrawableAmount);
            return {
                poolTokenAmountOut: (0, utils_1.getMinAmountWithSlippage)(poolTokenAmountOut, constants_1.UNLOCK_AMOUNT_BUFFER),
                tokenAInAmount: (0, utils_1.getMaxAmountWithSlippage)(actualTokenAInAmount, slippage),
                tokenBInAmount: (0, utils_1.getMaxAmountWithSlippage)(actualTokenBInAmount, slippage),
            };
        }
        // Imbalance deposit
        const actualDepositAAmount = (0, utils_1.computeActualDepositAmount)(tokenAInAmount, this.poolInfo.tokenAAmount, this.accountsInfo.poolVaultALp, this.accountsInfo.vaultALpSupply, vaultAWithdrawableAmount);
        const actualDepositBAmount = (0, utils_1.computeActualDepositAmount)(tokenBInAmount, this.poolInfo.tokenBAmount, this.accountsInfo.poolVaultBLp, this.accountsInfo.vaultBLpSupply, vaultBWithdrawableAmount);
        const poolTokenAmountOut = this.swapCurve.computeImbalanceDeposit(actualDepositAAmount, actualDepositBAmount, this.poolInfo.tokenAAmount, this.poolInfo.tokenBAmount, this.accountsInfo.poolLpSupply, this.poolState.fees);
        return {
            poolTokenAmountOut: (0, utils_1.getMinAmountWithSlippage)(poolTokenAmountOut, slippage),
            tokenAInAmount,
            tokenBInAmount,
        };
    }
    /**
     * `deposit` creates a transaction that deposits `tokenAInAmount` and `tokenBInAmount` into the pool,
     * and mints `poolTokenAmount` of the pool's liquidity token
     * @param {PublicKey} owner - PublicKey - The public key of the user who is depositing liquidity
     * @param {BN} tokenAInAmount - The amount of token A you want to deposit
     * @param {BN} tokenBInAmount - The amount of token B you want to deposit
     * @param {BN} poolTokenAmount - The amount of pool tokens you want to mint.
     * @returns A transaction object
     */
    deposit(owner, tokenAInAmount, tokenBInAmount, poolTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tokenAMint, tokenBMint, lpMint } = this.poolState;
            const [[userAToken, createTokenAIx], [userBToken, createTokenBIx], [userPoolLp, createLpMintIx]] = yield this.createATAPreInstructions(owner, [tokenAMint, tokenBMint, lpMint]);
            let preInstructions = [];
            createTokenAIx && preInstructions.push(createTokenAIx);
            createTokenBIx && preInstructions.push(createTokenBIx);
            createLpMintIx && preInstructions.push(createLpMintIx);
            if (constants_1.WRAPPED_SOL_MINT.equals(new web3_js_1.PublicKey(this.tokenA.address))) {
                preInstructions = preInstructions.concat((0, utils_1.wrapSOLInstruction)(owner, userAToken, tokenAInAmount.toNumber()));
            }
            if (constants_1.WRAPPED_SOL_MINT.equals(new web3_js_1.PublicKey(this.tokenB.address))) {
                preInstructions = preInstructions.concat((0, utils_1.wrapSOLInstruction)(owner, userBToken, tokenBInAmount.toNumber()));
            }
            preInstructions.push(yield this.getApySyncInstructions());
            const postInstructions = [];
            if ([this.tokenA.address, this.tokenB.address].includes(constants_1.WRAPPED_SOL_MINT.toBase58())) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
            }
            const programMethod = this.isStablePool
                ? this.program.methods.addImbalanceLiquidity
                : this.program.methods.addBalanceLiquidity;
            const depositTx = yield programMethod(poolTokenAmount, tokenAInAmount, tokenBInAmount)
                .accounts({
                aTokenVault: this.vaultA.vaultState.tokenVault,
                bTokenVault: this.vaultB.vaultState.tokenVault,
                aVault: this.poolState.aVault,
                bVault: this.poolState.bVault,
                pool: this.address,
                user: owner,
                userAToken,
                userBToken,
                aVaultLp: this.poolState.aVaultLp,
                bVaultLp: this.poolState.bVaultLp,
                aVaultLpMint: this.vaultA.vaultState.lpMint,
                bVaultLpMint: this.vaultB.vaultState.lpMint,
                lpMint: this.poolState.lpMint,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                vaultProgram: this.vaultProgram.programId,
                userPoolLp,
            })
                .remainingAccounts(getRemainingAccounts(this.poolState))
                .preInstructions(preInstructions)
                .postInstructions(postInstructions)
                .transaction();
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.program.provider.connection.getLatestBlockhash('finalized')))).add(depositTx);
        });
    }
    /**
     * `getWithdrawQuote` is a function that takes in a withdraw amount and returns the amount of tokens
     * that will be withdrawn from the pool
     * @param {BN} withdrawTokenAmount - The amount of tokens you want to withdraw from the pool.
     * @param {PublicKey} [tokenMint] - The token you want to withdraw. If you want balanced withdraw, leave this blank.
     * @param {number} [slippage] - The amount of slippage you're willing to accept. (Max to 2 decimal place)
     * @returns The return value is a tuple of the poolTokenAmountIn, tokenAOutAmount, and
     * tokenBOutAmount.
     */
    getWithdrawQuote(withdrawTokenAmount, slippage, tokenMint) {
        const vaultAWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(this.accountsInfo.currentTime, this.vaultA.vaultState);
        const vaultBWithdrawableAmount = (0, vault_sdk_1.calculateWithdrawableAmount)(this.accountsInfo.currentTime, this.vaultB.vaultState);
        // balance withdraw
        if (!tokenMint) {
            const vaultALpBurn = this.getShareByAmount(withdrawTokenAmount, this.accountsInfo.poolLpSupply, this.accountsInfo.poolVaultALp);
            const vaultBLpBurn = this.getShareByAmount(withdrawTokenAmount, this.accountsInfo.poolLpSupply, this.accountsInfo.poolVaultBLp);
            const tokenAOutAmount = this.getAmountByShare(vaultALpBurn, vaultAWithdrawableAmount, this.accountsInfo.vaultALpSupply);
            const tokenBOutAmount = this.getAmountByShare(vaultBLpBurn, vaultBWithdrawableAmount, this.accountsInfo.vaultBLpSupply);
            return {
                poolTokenAmountIn: withdrawTokenAmount,
                tokenAOutAmount: (0, utils_1.getMinAmountWithSlippage)(tokenAOutAmount, slippage),
                tokenBOutAmount: (0, utils_1.getMinAmountWithSlippage)(tokenBOutAmount, slippage),
            };
        }
        // Imbalance withdraw
        const isWithdrawingTokenA = tokenMint.equals(new web3_js_1.PublicKey(this.tokenA.address));
        const isWithdrawingTokenB = tokenMint.equals(new web3_js_1.PublicKey(this.tokenB.address));
        (0, invariant_1.default)(isWithdrawingTokenA || isWithdrawingTokenB, constants_1.ERROR.INVALID_MINT);
        const tradeDirection = tokenMint.equals(this.poolState.tokenAMint) ? curve_1.TradeDirection.BToA : curve_1.TradeDirection.AToB;
        const outAmount = this.swapCurve.computeWithdrawOne(withdrawTokenAmount, this.accountsInfo.poolLpSupply, this.poolInfo.tokenAAmount, this.poolInfo.tokenBAmount, this.poolState.fees, tradeDirection);
        const [vaultLpSupply, vaultTotalAmount] = tradeDirection == curve_1.TradeDirection.AToB
            ? [this.accountsInfo.vaultBLpSupply, vaultBWithdrawableAmount]
            : [this.accountsInfo.vaultALpSupply, vaultAWithdrawableAmount];
        const vaultLpToBurn = outAmount.mul(vaultLpSupply).div(vaultTotalAmount);
        // "Actual" out amount (precision loss)
        const realOutAmount = (0, utils_1.getMinAmountWithSlippage)(vaultLpToBurn.mul(vaultTotalAmount).div(vaultLpSupply), slippage);
        return {
            poolTokenAmountIn: withdrawTokenAmount,
            tokenAOutAmount: isWithdrawingTokenA ? realOutAmount : new anchor_1.BN(0),
            tokenBOutAmount: isWithdrawingTokenB ? realOutAmount : new anchor_1.BN(0),
        };
    }
    /**
     * `withdraw` is a function that takes in the owner's public key, the amount of tokens to withdraw,
     * and the amount of tokens to withdraw from each pool, and returns a transaction that withdraws the
     * specified amount of tokens from the pool
     * @param {PublicKey} owner - PublicKey - The public key of the user who is withdrawing liquidity
     * @param {BN} lpTokenAmount - The amount of LP tokens to withdraw.
     * @param {BN} tokenAOutAmount - The amount of token A you want to withdraw.
     * @param {BN} tokenBOutAmount - The amount of token B you want to withdraw,
     * @returns A transaction object
     */
    withdraw(owner, lpTokenAmount, tokenAOutAmount, tokenBOutAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const preInstructions = [];
            const [[userAToken, createUserAIx], [userBToken, createUserBIx], [userPoolLp, createLpTokenIx]] = yield Promise.all([this.poolState.tokenAMint, this.poolState.tokenBMint, this.poolState.lpMint].map((key) => (0, utils_1.getOrCreateATAInstruction)(key, owner, this.program.provider.connection)));
            createUserAIx && preInstructions.push(createUserAIx);
            createUserBIx && preInstructions.push(createUserBIx);
            createLpTokenIx && preInstructions.push(createLpTokenIx);
            preInstructions.push(yield this.getApySyncInstructions());
            const postInstructions = [];
            if ([this.tokenA.address, this.tokenB.address].includes(constants_1.WRAPPED_SOL_MINT.toBase58())) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
            }
            const programMethod = this.isStablePool && (tokenAOutAmount.isZero() || tokenBOutAmount.isZero())
                ? this.program.methods.removeLiquiditySingleSide(lpTokenAmount, new anchor_1.BN(0)).accounts({
                    aTokenVault: this.vaultA.vaultState.tokenVault,
                    aVault: this.poolState.aVault,
                    aVaultLp: this.poolState.aVaultLp,
                    aVaultLpMint: this.vaultA.vaultState.lpMint,
                    bTokenVault: this.vaultB.vaultState.tokenVault,
                    bVault: this.poolState.bVault,
                    bVaultLp: this.poolState.bVaultLp,
                    bVaultLpMint: this.vaultB.vaultState.lpMint,
                    lpMint: this.poolState.lpMint,
                    pool: this.address,
                    userDestinationToken: tokenBOutAmount.isZero() ? userAToken : userBToken,
                    userPoolLp,
                    user: owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    vaultProgram: this.vaultProgram.programId,
                })
                : this.program.methods.removeBalanceLiquidity(lpTokenAmount, tokenAOutAmount, tokenBOutAmount).accounts({
                    pool: this.address,
                    lpMint: this.poolState.lpMint,
                    aVault: this.poolState.aVault,
                    aTokenVault: this.vaultA.vaultState.tokenVault,
                    aVaultLp: this.poolState.aVaultLp,
                    aVaultLpMint: this.vaultA.vaultState.lpMint,
                    bVault: this.poolState.bVault,
                    bTokenVault: this.vaultB.vaultState.tokenVault,
                    bVaultLp: this.poolState.bVaultLp,
                    bVaultLpMint: this.vaultB.vaultState.lpMint,
                    userAToken,
                    userBToken,
                    user: owner,
                    userPoolLp,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    vaultProgram: this.vaultProgram.programId,
                });
            const withdrawTx = yield programMethod
                .remainingAccounts(getRemainingAccounts(this.poolState))
                .preInstructions(preInstructions)
                .postInstructions(postInstructions)
                .transaction();
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.program.provider.connection.getLatestBlockhash('finalized')))).add(withdrawTx);
        });
    }
    getApySyncInstructions() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.program.methods
                .syncApy()
                .accounts({
                aVault: this.poolState.aVault,
                bVault: this.poolState.bVault,
                aVaultLp: this.poolState.aVaultLp,
                bVaultLp: this.poolState.bVaultLp,
                pool: this.address,
                lpMint: this.poolState.lpMint,
                aVaultLpMint: this.vaultA.vaultState.lpMint,
                bVaultLpMint: this.vaultB.vaultState.lpMint,
                apy: this.apyPda,
            })
                .remainingAccounts(getRemainingAccounts(this.poolState))
                .instruction();
        });
    }
    createATAPreInstructions(owner, mintList) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(mintList.map((mint) => {
                return (0, utils_1.getOrCreateATAInstruction)(mint, owner, this.program.provider.connection);
            }));
        });
    }
    calculateAdminTradingFee(amount) {
        const { ownerTradeFeeDenominator, ownerTradeFeeNumerator } = this.poolState.fees;
        return amount.mul(ownerTradeFeeNumerator).div(ownerTradeFeeDenominator);
    }
    calculateTradingFee(amount) {
        const { tradeFeeDenominator, tradeFeeNumerator } = this.poolState.fees;
        return amount.mul(tradeFeeNumerator).div(tradeFeeDenominator);
    }
    computeActualInAmount(poolTokenAmount, poolLpSupply, poolVaultALp, poolVaultBLp, vaultALpSupply, vaultBLpSupply, vaultAWithdrawableAmount, vaultBWithdrawableAmount) {
        const aVaultLpMinted = this.getShareByAmount(poolTokenAmount, poolLpSupply, poolVaultALp, true);
        const bVaultLpMinted = this.getShareByAmount(poolTokenAmount, poolLpSupply, poolVaultBLp, true);
        const actualTokenAInAmount = this.getAmountByShare(aVaultLpMinted, vaultAWithdrawableAmount, vaultALpSupply, true);
        const actualTokenBInAmount = this.getAmountByShare(bVaultLpMinted, vaultBWithdrawableAmount, vaultBLpSupply, true);
        return [actualTokenAInAmount, actualTokenBInAmount];
    }
    getShareByAmount(amount, tokenAmount, lpSupply, roundUp) {
        return roundUp ? amount.mul(lpSupply).divRound(tokenAmount) : amount.mul(lpSupply).div(tokenAmount);
    }
    getAmountByShare(amount, tokenAmount, lpSupply, roundUp) {
        return roundUp ? amount.mul(tokenAmount).divRound(lpSupply) : amount.mul(tokenAmount).div(lpSupply);
    }
}
exports.default = AmmImpl;
//# sourceMappingURL=index.js.map