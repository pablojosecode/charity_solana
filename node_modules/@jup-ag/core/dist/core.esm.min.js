import{u64 as t,TOKEN_PROGRAM_ID as e,NATIVE_MINT as n,ASSOCIATED_TOKEN_PROGRAM_ID as i,Token as o}from"@solana/spl-token";import{PublicKey as s,MAX_SEED_LENGTH as r,SystemProgram as a,SYSVAR_RENT_PUBKEY as u,SYSVAR_CLOCK_PUBKEY as c,ComputeBudgetProgram as m,TransactionInstruction as p,Transaction as d}from"@solana/web3.js";import{Market as l,OpenOrders as g,Orderbook as h}from"@project-serum/serum";import{calculateAmpFactor as f,SWAP_PROGRAM_ID as S,StableSwap as k}from"@saberhq/stableswap-sdk";import{TokenSwapStable as w,Fraction as A,TokenSwapConstantProduct as y,ZERO as M,toDecimal as T,Stable as v,ZERO_FRACTION as P,TWO as B,ONE as b}from"@jup-ag/math";import I from"jsbi";import{deserializeAccount as F,TransactionError as L,parseErrorForTransaction as D,UNKNOWN_ERROR as q}from"@mercurial-finance/optimist";export{TransactionError}from"@mercurial-finance/optimist";import*as E from"fzstd";import{AnchorProvider as x,Program as C,BN as O,utils as V}from"@project-serum/anchor";import{findProgramAddressSync as N,createProgramAddressSync as U}from"@project-serum/anchor/dist/cjs/utils/pubkey";import{Layout as R,blob as K,struct as W,u8 as Q,u32 as z,nu64 as j}from"@solana/buffer-layout";import{sha256 as H}from"@noble/hashes/sha256";import X,{BN as G}from"bn.js";import Y from"decimal.js";import{TokenSwapAccountLayout as Z,parseTicksAccount as J,calculateSwapA2B as _,calculateSwapB2A as $}from"@jup-ag/crema-sdk";import{tickPosition as tt,TickMath as et,generateBitmapWord as nt,TICK_SEED as it,u32ToSeed as ot,BITMAP_SEED as st,u16ToSeed as rt,nextInitializedBit as at,buildTick as ut,Pool as ct,OBSERVATION_SEED as mt,IDL as pt}from"@jup-ag/cykura-sdk";import{Token as dt,CurrencyAmount as lt}from"@jup-ag/cykura-sdk-core";import{getSwappedAmountsAndPriceImpactFromRawValue as gt,getDeltafiDexV2 as ht}from"@jup-ag/deltafi-sdk";import{parsePriceData as ft}from"@pythnetwork/client";import{BigNumber as St}from"bignumber.js";import{PAIR_LAYOUT as kt,SyncSwap as wt,SSL as At,wasm as yt,loadWasm as Mt}from"@jup-ag/goosefx-ssl-sdk";import{ASSOCIATED_PROGRAM_ID as Tt}from"@project-serum/anchor/dist/cjs/utils/token";import{calculatePriceSqrt as vt,MIN_TICK as Pt,MAX_TICK as Bt,toDecimal as bt,simulateSwap as It,findClosestTicks as Ft,TICK_CROSSES_PER_IX as Lt,IDL as Dt,DENOMINATOR as qt}from"@jup-ag/invariant";import{LIFINITY_AMM_LAYOUT as Et,TradeDirection as xt,getParsedData as Ct,getCurveAmount as Ot}from"@jup-ag/lifinity-sdk";import{AmmIdl as Vt,PROGRAM_ID as Nt,VaultIdl as Ut,calculateSwapQuote as Rt}from"@mercurial-finance/dynamic-amm-sdk";import{getTickArrayPks as Kt,parseTickArray as Wt,getSwapQuote as Qt,getDefaultSqrtPriceLimit as zt,getTickArrayPublicKeysForSwap as jt,parseWhirlpool as Ht}from"@jup-ag/whirlpool-sdk";import Xt from"cross-fetch";import{bs58 as Gt}from"@project-serum/anchor/dist/cjs/utils/bytes";const Yt={Serum:{Meteora:!0,GooseFX:!0},Meteora:{Raydium:!0,Serum:!0,GooseFX:!0},Raydium:{Meteora:!0,GooseFX:!0},GooseFX:{Raydium:!0,Serum:!0,Meteora:!0},"Saber (Decimals)":{"Saber (Decimals)":!0}},Zt={Raydium:{"*":!0},GooseFX:{"*":!0},Meteora:{"*":!0}},Jt={GooseFX:!0,Meteora:!0,Raydium:!0,Lifinity:!0,Serum:!0,Invariant:!0},_t={Raydium:!0,GooseFX:!0,Meteora:!0,Serum:!0},$t=(t,e,n)=>{const i=t[e];if(i){if(!0===i||!0===i["*"])return!0;if(n)return!0===i[n]}return!1},te=(t,e,n)=>$t(t,e,n)||!!n&&$t(t,n,e);function ee(t,e){return Array.apply(0,new Array(Math.ceil(t.length/e))).map(((n,i)=>t.slice(i*e,(i+1)*e)))}async function ne(t,e,n=1e3,i=100){return(await Promise.all(ee(e,n).map((async e=>{const n=ee(e,i).map((e=>({methodName:"getMultipleAccounts",args:t._buildArgs([e],t.commitment,"base64+zstd")})));return t._rpcBatchRequest(n).then((t=>t.reduce(((t,e)=>(e.result.value.forEach((e=>{if(e){const n=e;n.data=Buffer.from(E.decompress(Buffer.from(e.data[0],"base64"))),n.owner=new s(e.owner),t.push(n)}else t.push(null)})),t)),[]))).catch((t=>e.map((()=>null))))})))).flat()}var ie;!function(t){t.ExactIn="ExactIn",t.ExactOut="ExactOut"}(ie||(ie={}));const oe=(t,e)=>e.map((e=>{const n=t.get(e.toString());if(!n)throw new Error(`Account info ${e.toBase58()} missing`);return n})),se=t=>t.map((t=>I.BigInt(t.amount))),re=async(t,e)=>{const n=t.map((t=>t.getAccountsForUpdate().map((t=>t.toBase58())))).flat(),i=new Map;(await ne(e,n)).forEach(((t,e)=>{t&&i.set(n[e],t)}));for(let e of t)e.update(i)},ae={version:"0.1.0",name:"jupiter",instructions:[{name:"route",accounts:[{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"destinationTokenAccount",isMut:!1,isSigner:!1}],args:[{name:"swapLeg",type:{defined:"SwapLeg"}},{name:"inAmount",type:"u64"},{name:"quotedOutAmount",type:"u64"},{name:"slippageBps",type:"u16"},{name:"platformFeeBps",type:"u8"}]},{name:"whirlpoolSwapExactOutput",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[{name:"outAmount",type:"u64"},{name:"inAmountWithSlippage",type:{defined:"AmountWithSlippage"}},{name:"aToB",type:"bool"},{name:"platformFeeBps",type:"u8"}]},{name:"createOpenOrders",accounts:[{name:"openOrders",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"market",isMut:!1,isSigner:!1}],args:[]},{name:"mercurialSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"poolAuthority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceTokenAccount",isMut:!0,isSigner:!1},{name:"destinationTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"cykuraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"signer",isMut:!1,isSigner:!0},{name:"factoryState",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"lastObservationState",isMut:!0,isSigner:!1},{name:"coreProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"serumSwap",accounts:[{name:"market",accounts:[{name:"market",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"requestQueue",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"coinVault",isMut:!0,isSigner:!1},{name:"pcVault",isMut:!0,isSigner:!1},{name:"vaultSigner",isMut:!1,isSigner:!1}]},{name:"authority",isMut:!1,isSigner:!0},{name:"orderPayerTokenAccount",isMut:!0,isSigner:!1},{name:"coinWallet",isMut:!0,isSigner:!1},{name:"pcWallet",isMut:!0,isSigner:!1},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"saberSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"saberAddDecimals",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"tokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"senchaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!0,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"inputFeesAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"outputFeesAccount",isMut:!0,isSigner:!1}],args:[]},{name:"stepSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"cropperSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"raydiumSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[]},{name:"cremaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolSourceTokenAccount",isMut:!0,isSigner:!1},{name:"poolDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolTicksAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"lifinitySwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"pythAccount",isMut:!1,isSigner:!1},{name:"pythPcAccount",isMut:!1,isSigner:!1},{name:"configAccount",isMut:!0,isSigner:!1}],args:[]},{name:"marinadeDeposit",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1},{name:"tempWsolTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!0,isSigner:!0},{name:"wsolMint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"marinadeUnstake",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"aldrinSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"aldrinV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"curve",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"whirlpoolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[]},{name:"invariantSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tickmap",isMut:!0,isSigner:!1},{name:"accountX",isMut:!0,isSigner:!1},{name:"accountY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"meteoraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"aVault",isMut:!0,isSigner:!1},{name:"bVault",isMut:!0,isSigner:!1},{name:"aTokenVault",isMut:!0,isSigner:!1},{name:"bTokenVault",isMut:!0,isSigner:!1},{name:"aVaultLpMint",isMut:!0,isSigner:!1},{name:"bVaultLpMint",isMut:!0,isSigner:!1},{name:"aVaultLp",isMut:!0,isSigner:!1},{name:"bVaultLp",isMut:!0,isSigner:!1},{name:"adminTokenFee",isMut:!0,isSigner:!1},{name:"user",isMut:!1,isSigner:!0},{name:"vaultProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"goosefxSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"controller",isMut:!1,isSigner:!1},{name:"pair",isMut:!0,isSigner:!1},{name:"sslIn",isMut:!0,isSigner:!1},{name:"sslOut",isMut:!0,isSigner:!1},{name:"liabilityVaultIn",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultIn",isMut:!0,isSigner:!1},{name:"liabilityVaultOut",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultOut",isMut:!0,isSigner:!1},{name:"userInAta",isMut:!0,isSigner:!1},{name:"userOutAta",isMut:!0,isSigner:!1},{name:"feeCollectorAta",isMut:!0,isSigner:!1},{name:"userWallet",isMut:!1,isSigner:!0},{name:"feeCollector",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"deltafiSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"marketConfig",isMut:!1,isSigner:!1},{name:"swapInfo",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"swapSourceToken",isMut:!0,isSigner:!1},{name:"swapDestinationToken",isMut:!0,isSigner:!1},{name:"deltafiUser",isMut:!0,isSigner:!1},{name:"adminDestinationToken",isMut:!0,isSigner:!1},{name:"pythPriceBase",isMut:!1,isSigner:!1},{name:"pythPriceQuote",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]}],types:[{name:"AmountWithSlippage",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"slippageBps",type:"u16"}]}},{name:"SplitLegDeeper",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegSwap"}}]}},{name:"SplitLeg",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegDeeper"}}]}},{name:"SwapInstrution",type:{kind:"enum",variants:[{name:"Swap",fields:[{defined:"Swap"}]}]}},{name:"Side",type:{kind:"enum",variants:[{name:"Bid"},{name:"Ask"}]}},{name:"SwapLegSwap",type:{kind:"enum",variants:[{name:"PlaceholderOne"},{name:"PlaceholderTwo"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLegDeeper",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegSwap"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLegDeeper"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLeg",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegDeeper"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLeg"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"Swap",type:{kind:"enum",variants:[{name:"Saber"},{name:"SaberAddDecimalsDeposit"},{name:"SaberAddDecimalsWithdraw"},{name:"TokenSwap"},{name:"Sencha"},{name:"Step"},{name:"Cropper"},{name:"Raydium"},{name:"Crema"},{name:"Lifinity"},{name:"Mercurial"},{name:"Cykura"},{name:"Serum",fields:[{name:"side",type:{defined:"Side"}}]},{name:"MarinadeDeposit"},{name:"MarinadeUnstake"},{name:"Aldrin",fields:[{name:"side",type:{defined:"Side"}}]},{name:"AldrinV2",fields:[{name:"side",type:{defined:"Side"}}]},{name:"Whirlpool",fields:[{name:"a_to_b",type:"bool"}]},{name:"Invariant",fields:[{name:"x_to_y",type:"bool"}]},{name:"Meteora"},{name:"GooseFX"},{name:"DeltaFi",fields:[{name:"stable",type:"bool"}]}]}},{name:"SwapAction",type:{kind:"enum",variants:[{name:"SetupSplit",fields:[{name:"percents",type:"bytes"}]},{name:"NextSplitLeg"},{name:"MergeSplit"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}}],errors:[{code:6e3,name:"EmptyRoute",msg:"Empty route"},{code:6001,name:"SlippageToleranceExceeded",msg:"Slippage tolerance exceeded"},{code:6002,name:"InvalidTokenLedger",msg:"Invalid token ledger"},{code:6003,name:"MissingTokenLedger",msg:"Missing token ledger"},{code:6004,name:"MissingMercurialSwapTokenAccount",msg:"Missing mercurial swap token account"},{code:6005,name:"LedgerTokenAccountDoesNotMatch",msg:"Ledger token account does not match"},{code:6006,name:"InvalidCalculation",msg:"Invalid calculation"},{code:6007,name:"MissingPlatformFeeAccount",msg:"Missing platform fee account"},{code:6008,name:"InvalidSlippage",msg:"Invalid slippage"},{code:6009,name:"NotEnoughPercent",msg:"Not enough percent to 100"},{code:6010,name:"InAmountsStackIsEmpty",msg:"In amounts stack is empty"},{code:6011,name:"OutAmountsStackIsEmpty",msg:"Out amounts stack is empty"}]},ue=new s("So11111111111111111111111111111111111111112"),ce=new s("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),me=new s("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),pe={devnet:"https://api.jup.ag/api/markets/cache/devnet","mainnet-beta":"https://cache.jup.ag/markets?v=3",testnet:"https://api.jup.ag/api/markets/cache/devnet"},de="https://cache.jup.ag/indexed-route-map",le={devnet:"https://api.jup.ag/api/tokens/devnet",testnet:"https://api.jup.ag/api/markets/devnet","mainnet-beta":"https://cache.jup.ag/tokens"},ge=5e3,he=new s("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),fe=new s("AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6"),Se=new s("CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4"),ke=new s("DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB"),we=new s("CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh"),Ae=new s("SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ"),ye=new s("EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S"),Me=new s("6MLxLqiXaaSUpkgMnWDTuejNZEz3kE7k2woyHGVFw319"),Te=new s("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),ve=new s("MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky"),Pe=new s("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"),Be=new s("HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt"),be=new s("8NsPwRFYqob3FzYvHYTjFK6WVFJADFN8Hn7yNQKcVNW1"),Ie=new s("J4uBbeoWpZE8fH58PM1Fp9n9K6f1aThyeVCyRdJbaXqt"),Fe=new s("cysPXAjehMpVKUapzbMCCnpFxUFFryEWEaLgnb9NrR8"),Le=new s("DBsMwKfeoUHhxMi9x6wd2AsT12UwUCssjNbUzu1aKgqj"),De=new s("MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"),qe=new s("Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j"),Ee=new s("9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP"),xe=new s("SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1"),Ce=new s("PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP"),Oe=new s("SSwapUtytfBdBn1b9NUGG6foMVPtcWgpRU32HToDUZr"),Ve=new s("Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"),Ne=new s("24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"),Ue=new s("GNExJhNUhc9LN2DauuQAUJnXoy6DJ6zey3t9kT9A2PF3"),Re=new s("ziSPuDShwunW4xNrCfTnSHTPVT6FZDREtdofpf1BJwe"),Ke=new s("7WduLbRfYhTJktjLw5FDEyrqoEv61aTTCuGAetgLjzN5"),We=new s("8CxKnuJeoeQXFwiG6XiGY2akBjvJA5k3bE52BfnuEmNQ"),Qe=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],ze=Object.freeze({AlreadyInUse:{code:1,name:"AlreadyInUsed",msg:"Account already In Used"},InsufficientSOL:{code:1,name:"InsufficientSOL",msg:"Insufficient SOL"},TransactionNotConfirmed:{code:7e3,name:"TransactionNotConfirmed",msg:"Transaction was not confirmed"},BalancesNotExtractedProperly:{code:7001,name:"BalancesNotExtractedProperly",msg:"Balances cannot be extracted properly"},...ae.errors.reduce(((t,e)=>({...t,[e.name]:e})),{})}),je="development"===process.env.NODE_ENV,He=100,Xe=new x(null,null,{skipPreflight:!1});class Ge extends R{constructor(t){const e=K(32);super(e.span,t),this.layout=void 0,this.layout=e}getSpan(t,e){return this.layout.getSpan(t,e)}decode(t,e){return new s(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(t.toBuffer(),e,n)}}const Ye=t=>new Ge(t);class Ze extends R{constructor(t=8,e){const n=K(t);super(n.span,e),this.layout=void 0,this.layout=n}getSpan(t,e){return this.layout.getSpan(t,e)}decode(e,n){return new t(this.layout.decode(e,n),10,"le")}encode(t,e,n){return this.layout.encode(t.toArrayLike(Buffer,"le",this.layout.span),e,n)}}const Je=t=>new Ze(8,t),_e=t=>new Ze(16,t);function $e(t,e){let n=Buffer.alloc(0);t.forEach((function(t){if(t.length>r)throw new TypeError("Max seed length exceeded");var e;n=Buffer.concat([n,(e=t,Buffer.isBuffer(e)?e:e instanceof Uint8Array?Buffer.from(e.buffer,e.byteOffset,e.byteLength):Buffer.from(e))])})),n=Buffer.concat([n,e.toBuffer(),Buffer.from("ProgramDerivedAddress")]);let i=H(new Uint8Array(n)),o=new X(i,16).toArray(void 0,32);return new s(o)}const tn=W([Q("version"),Q("isInitialized"),Q("nonce"),Ye("ammId"),Ye("serumProgramId"),Ye("serumMarket"),Ye("tokenProgramId"),Ye("tokenAAccount"),Ye("tokenBAccount"),Ye("poolMint"),Ye("mintA"),Ye("mintB")]),en=W([Q("isInitialized"),Ye("stateOwner"),Ye("feeOwner"),Je("initialSupply"),Je("returnFeeNumerator"),Je("fixedFeeNumerator"),Je("feeDenominator"),Q("curveType"),K(32,"curveParameters")]),nn=new s("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),on=(t,e)=>{const n=e.owner,i=tn.decode(e.data);return{programId:n,authority:$e([t.toBuffer(),Buffer.from([i.nonce])],n),version:i.version,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:i.ammId,serumProgramId:i.serumProgramId,tokenProgramId:i.tokenProgramId,tokenAAccount:i.tokenAAccount,tokenBAccount:i.tokenBAccount,serumMarket:i.serumMarket,poolMint:i.poolMint,mintA:i.mintA,mintB:i.mintB}},sn={Bid:{bid:{}},Ask:{ask:{}}},rn=t=>({serum:{side:t}}),an=t=>({aldrin:{side:t}}),un=t=>({aldrinV2:{side:t}}),cn=t=>({whirlpool:{aToB:t}}),mn=t=>({invariant:{xToY:t}}),pn=t=>({chain:{swapLegs:t}}),dn=t=>({split:{splitLegs:t}}),ln=t=>({swap:{swap:t}}),gn=(t,e)=>({percent:t,swapLeg:e}),hn=new s("JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB"),fn=new C(ae,hn,{}),Sn={pubkey:hn,isSigner:!1,isWritable:!1};function kn(t,n,i,o,s,r,a,u){return fn.instruction.route(i,s,r,a,u,{accounts:{tokenProgram:e,userTransferAuthority:t,destinationTokenAccount:n},remainingAccounts:o})}function wn(t,n,i,o){return{swapProgram:ve,swapState:t.ammId,tokenProgram:e,poolAuthority:t.authority,userTransferAuthority:o,sourceTokenAccount:n,destinationTokenAccount:i}}const[An]=N([new Uint8Array(Buffer.from("amm authority".replace(" "," "),"utf-8"))],he);function yn(t,n,i,o){if(!t.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:he,tokenProgram:e,ammId:t.ammId,ammAuthority:An,ammOpenOrders:t.ammOpenOrders,poolCoinTokenAccount:t.poolCoinTokenAccount,poolPcTokenAccount:t.poolPcTokenAccount,serumProgramId:t.serumProgramId,serumMarket:t.serumMarket,serumBids:t.serumMarketKeys.serumBids,serumAsks:t.serumMarketKeys.serumAsks,serumEventQueue:t.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:t.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:t.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:t.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:n,userDestinationTokenAccount:i,userSourceOwner:o}}function Mn(t,n,i,o,s,r){const a=U([t.address.toBuffer(),t.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],t.programId);return{market:{market:t.address,openOrders:n,requestQueue:t.decoded.requestQueue,eventQueue:t.decoded.eventQueue,bids:t.bidsAddress,asks:t.asksAddress,coinVault:t.decoded.baseVault,pcVault:t.decoded.quoteVault,vaultSigner:a},authority:r,orderPayerTokenAccount:i,coinWallet:o,pcWallet:s,dexProgram:t.programId,tokenProgram:e,rent:u}}function Tn(t,n,i,o,s){const r=n.equals(t.state.tokenA.mint)?t.state.tokenB.adminFeeAccount:t.state.tokenA.adminFeeAccount,[a,u]=n.equals(t.state.tokenA.mint)?[t.state.tokenA.reserve,t.state.tokenB.reserve]:[t.state.tokenB.reserve,t.state.tokenA.reserve];return{swapProgram:t.config.swapProgramID,tokenProgram:e,swap:t.config.swapAccount,swapAuthority:t.config.authority,userAuthority:s,inputUserAccount:i,inputTokenAccount:a,outputUserAccount:o,outputTokenAccount:u,feesTokenAccount:r}}function vn(t,e){const n=[];return n.push(t?{pubkey:t,isSigner:!1,isWritable:!0}:e?{pubkey:e,isSigner:!1,isWritable:!0}:Sn),n}const Pn=new t(0);class Bn{constructor(t,e){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=t,this.denominator=e}static fromDecimal(t){return Bn.fromFraction(t.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(e,n){const i="number"==typeof e?new t(e.toString()):e,o="number"==typeof n?new t(n.toString()):n;return new Bn(i,o)}toDecimal(){return this.denominator.eq(Pn)?new Y(0):new Y(this.numerator.toString()).div(new Y(this.denominator.toString()))}add(e){const n=this.denominator.gcd(e.denominator),i=this.denominator.div(n).mul(e.denominator),o=i.div(this.denominator),s=i.div(e.denominator),r=this.numerator.mul(o),a=e.numerator.mul(s),u=r.add(a);return new Bn(new t(u.toString()),new t(i.toString()))}}const bn=W([Je("tradeFeeNumerator"),Je("tradeFeeDenominator"),Je("ownerTradeFeeNumerator"),Je("ownerTradeFeeDenominator"),Je("ownerWithdrawFeeNumerator"),Je("ownerWithdrawFeeDenominator")],"fees"),In=[K(8,"padding"),Ye("lpTokenFreezeVault"),Ye("poolMint"),Ye("baseTokenVault"),Ye("baseTokenMint"),Ye("quoteTokenVault"),Ye("quoteTokenMint"),Ye("poolSigner"),Q("poolSignerNonce"),Ye("authority"),Ye("initializerAccount"),Ye("feeBaseAccount"),Ye("feeQuoteAccount"),Ye("feePoolTokenAccount"),bn],Fn=W(In),Ln=W([...In,Q("curveType"),Ye("curve")]),Dn=W([K(8,"padding"),Je("amp")]);function qn(t,e){const n=!!e.owner.equals(Se),i=(n?Ln:Fn).decode(e.data),o="curveType"in i?{curveType:i.curveType,curve:i.curve}:{};return{isV2:n,address:t,poolMint:i.poolMint,baseTokenVault:i.baseTokenVault,baseTokenMint:i.baseTokenMint,quoteTokenVault:i.quoteTokenVault,quoteTokenMint:i.quoteTokenMint,poolSigner:i.poolSigner,feeBaseAccount:i.feeBaseAccount,feeQuoteAccount:i.feeQuoteAccount,feePoolTokenAccount:i.feePoolTokenAccount,fees:{traderFee:Bn.fromFraction(i.fees.tradeFeeNumerator,i.fees.tradeFeeDenominator),ownerFee:Bn.fromFraction(i.fees.ownerTradeFeeNumerator,i.fees.ownerTradeFeeDenominator)},...o}}class En{constructor(t,e,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.poolState=qn(t,e),this.id=t.toBase58(),1===this.poolState.curveType){const{amp:t}=this.params;if(!t)throw new Error("Amp is required for a stable curve");this.calculator=new w(I.BigInt(t),new A(I.BigInt(this.poolState.fees.traderFee.numerator.toString()),I.BigInt(this.poolState.fees.traderFee.denominator.toString())),new A(I.BigInt(this.poolState.fees.ownerFee.numerator.toString()),I.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new y(new A(I.BigInt(this.poolState.fees.traderFee.numerator.toString()),I.BigInt(this.poolState.fees.traderFee.denominator.toString())),new A(I.BigInt(this.poolState.fees.ownerFee.numerator.toString()),I.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(t){const{amp:e}=Dn.decode(t.data);return 2*e.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(t){const e=oe(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=F(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new Y(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new Y(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const i=this.tokenAccounts[0].mint.equals(t)?1:0;let o=this.calculator.exchange(se(this.tokenAccounts),e,i);return{notEnoughLiquidity:!1,inAmount:e,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:t.toBase58(),feePct:n.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,curve:s,userTransferAuthority:r}){const[a,u,c]=n.equals(t.baseTokenMint)?[sn.Ask,i,o]:[sn.Bid,o,i];return[ln(un(a)),fn.instruction.aldrinV2Swap({accounts:{swapProgram:Se,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:r,userBaseTokenAccount:u,userQuoteTokenAccount:c,curve:s,tokenProgram:e}}).keys]}({poolState:this.poolState,curve:this.poolState.curve,...t})}return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[r,a,u]=n.equals(t.baseTokenMint)?[sn.Ask,i,o]:[sn.Bid,o,i];return[ln(an(r)),fn.instruction.aldrinSwap({accounts:{swapProgram:fe,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:s,userBaseTokenAccount:a,userQuoteTokenAccount:u,tokenProgram:e}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.baseTokenMint,this.poolState.quoteTokenMint]}}En.accountInfoToAldrinPoolState=qn;const xn=(t,e)=>{const n=e.owner,i=Z.decode(e.data);return{programId:n,authority:$e([t.toBuffer(),Buffer.from([i.nonce])],n),version:i.version,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:t,tokenProgramId:i.tokenProgramId,tokenAAccount:i.swapTokenA,tokenBAccount:i.swapTokenB,ticksKey:i.ticksKey,mintA:i.tokenAMint,mintB:i.tokenBMint,fee:i.fee,currentSqrtPrice:i.currentSqrtPrice,currentLiquity:i.currentLiquity}};class Cn{constructor(t,e){this.id=void 0,this.label="Crema",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.ticks=void 0,this.poolState=void 0,this.poolState=xn(t,e),this.id=t.toBase58()}getAccountsForUpdate(){return[this.poolState.ammId,this.poolState.ticksKey]}update(t){const[e,n]=oe(t,this.getAccountsForUpdate());this.poolState=xn(this.poolState.ammId,e);const i=J(this.poolState.ticksKey,n);if(!i)throw new Error(`Ticks account invalid: ${this.poolState.ticksKey.toBase58()}`);this.ticks=i.data.ticks}getQuote({sourceMint:t,amount:e}){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");if(I.equal(e,M))return{notEnoughLiquidity:!1,inAmount:e,outAmount:M,feeAmount:M,feeMint:t.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:0};const n=this.poolState.mintA.equals(t)?this.preSwapA(new Y(e.toString())):this.preSwapB(new Y(e.toString()));if(n.revert)throw new Error("Crema error: insufficient liquidity");return{notEnoughLiquidity:!1,inAmount:e,outAmount:I.BigInt(n.amountOut.toString()),feeAmount:I.BigInt(n.feeUsed.toString()),feeMint:t.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:n.impact.toNumber()}}preSwapA(t){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");const e=_(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,t),n=this.poolState.currentSqrtPrice.pow(2),i=e.amountOut.div(e.amountUsed).sub(n).div(n).abs(),o=e.amountUsed.lessThan(t);return{...e,impact:i,revert:o}}preSwapB(t){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");const e=$(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,t),n=this.poolState.currentSqrtPrice.pow(2),i=new Y(1).div(n),o=e.amountOut.div(e.amountUsed).sub(i).div(i).abs(),s=e.amountUsed.lessThan(t);return{...e,impact:o,revert:s}}getSwapLegAndAccounts(t){return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[r,a]=n.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return[ln({crema:{}}),fn.instruction.cremaSwap({accounts:{swapProgram:t.programId,pool:t.ammId,poolSigner:t.authority,userSourceTokenAccount:i,userDestinationTokenAccount:o,poolSourceTokenAccount:r,poolDestinationTokenAccount:a,poolTicksAccount:t.ticksKey,walletAuthority:s,tokenProgram:e}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}class On{static async getStateFromStateAccount(t){const e=await t.getAccountInfo(nn);if(!e)throw new Error("State account not found");return(t=>{const e=en.decode(t.data);return{isInitialized:Boolean(e.isInitialized),stateOwner:e.stateOwner,feeOwner:e.feeOwner,initialSupply:e.initialSupply,returnFeeNumerator:e.returnFeeNumerator.toNumber(),fixedFeeNumerator:e.fixedFeeNumerator.toNumber(),feeDenominator:e.feeDenominator.toNumber(),curveType:e.curveType,curveParameters:e.curveParameters}})(e)}constructor(t,e,n){this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.feePct=void 0,this.params=void 0,this.id=t.toBase58(),this.poolState=on(t,e),this.params={...n,tokenAFeeAccount:new s(n.tokenAFeeAccount),tokenBFeeAccount:new s(n.tokenBFeeAccount)},this.feePct=new Y(this.params.fixedFeeNumerator).div(this.params.feeDenominator).add(new Y(this.params.returnFeeNumerator).div(this.params.feeDenominator)),this.calculator=new y(new A(I.BigInt(this.params.fixedFeeNumerator),I.BigInt(this.params.feeDenominator)),new A(I.BigInt(this.params.returnFeeNumerator),I.BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(t){const e=oe(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=F(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(t)?1:0,i=this.calculator.exchange(se(this.tokenAccounts),e,n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){const n=t.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return function({poolState:t,feeAccount:n,sourceMint:i,userSourceTokenAccount:o,userDestinationTokenAccount:s,userTransferAuthority:r}){const[a,u]=i.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return[ln({cropper:{}}),fn.instruction.cropperSwap({accounts:{tokenSwapProgram:t.programId,tokenProgram:e,swap:t.ammId,swapState:nn,authority:t.authority,userTransferAuthority:r,source:o,swapSource:a,swapDestination:u,destination:s,poolMint:t.poolMint,poolFee:n}}).keys]}({poolState:this.poolState,feeAccount:n,...t})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}On.decodePoolState=on;class Vn{constructor(t,e){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=t,this.pool=e,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(t,e){const n=I.toNumber(I.divide(I.BigInt(t),I.BigInt(e))),{wordPos:i}=tt(n);try{const t=[],{wordPos:n}=tt(Math.floor(et.MIN_TICK/e)),{wordPos:s}=tt(Math.floor(et.MAX_TICK/e)),r=Math.max(i-10,n),a=Math.min(i+10,s);for(let e=r;e<a;e++)t.push(this.getBitmapAddressSync(e));const u=await this.program.account.tickBitmapState.fetchMultiple(t),c=[];for(let n=0;n<a-r;n++){var o;const i=n+r,s=null===(o=u[n])||void 0===o?void 0:o.word,a=s?nt(s):new O(0);if(this.bitmapCache.set(i,{address:t[n],word:a}),a&&!a.eqn(0))for(let t=0;t<256;t++)if(a.shrn(t).and(new O(1)).eqn(1)){const n=this.getTickAddressSync(((i<<8)+t)*e);c.push(n)}}const m=await this.program.account.tickState.fetchMultiple(c);for(const t in c){const e=m[t];if(!e)continue;const{tick:n,liquidityNet:i}=e;this.tickCache.set(n,{address:c[t],liquidityNet:I.BigInt(i)})}}catch(t){}}lazyLoadAccountsToCache(t,e){const n=I.toNumber(I.divide(I.BigInt(t),I.BigInt(e))),{wordPos:i}=tt(n),o=[],s=[],{wordPos:r}=tt(Math.floor(et.MIN_TICK/e)),{wordPos:a}=tt(Math.floor(et.MAX_TICK/e)),u=Math.max(i-10,r),c=Math.min(i+10,a);for(let t=u;t<c;t++){o.push(this.getBitmapAddressSync(t));const e=this.bitmapCache.get(t);s.push(e)}const m=[];for(let t=0;t<c-u;t++){var p,d;const n=t+u,i=null!==(p=null===(d=s[t])||void 0===d?void 0:d.word)&&void 0!==p?p:new O(0);if(this.bitmapCache.set(n,{address:o[t],word:i}),i&&!i.eqn(0))for(let t=0;t<256;t++)if(i.shrn(t).and(new O(1)).eqn(1)){const i=this.getTickAddressSync(((n<<8)+t)*e);m.push(i)}}return this.accountsToFetch={bitmaps:o,ticks:m},[...o,...m]}getTick(t){let e=this.tickCache.get(t);if(!e)throw new Error("Tick not cached");return{address:e.address,liquidityNet:e.liquidityNet}}async getTickAddress(t){return this.getTickAddressSync(t)}getTickAddressSync(t){return N([it,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),ot(this.pool.fee),ot(t)],this.program.programId)[0]}async getBitmapAddress(t){return this.getBitmapAddressSync(t)}getBitmapAddressSync(t){return N([st,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),ot(this.pool.fee),rt(t)],this.program.programId)[0]}getBitmap(t){let e=this.bitmapCache.get(t);if(!e)throw new Error("Bitmap not cached");return e}nextInitializedTickWithinOneWord(t,e,n){let i=I.toNumber(I.divide(I.BigInt(t),I.BigInt(n)));t<0&&t%n!=0&&(i-=1),e||(i+=1);const{wordPos:o,bitPos:s}=tt(i),r=this.getBitmap(o),{next:a,initialized:u}=at(r.word,s,e);return[ut(o,a,n),u,o,s,r.address]}updateCachedAccountInfos(t){for(const e of this.accountsToFetch.bitmaps){const n=t.get(e.toBase58());if(n){const t=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(t.wordPos,{address:e,word:nt(t.word)})}}for(const e of this.accountsToFetch.ticks){const n=t.get(e.toBase58());if(n){const t=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(t.tick,{address:e,liquidityNet:I.BigInt(t.liquidityNet)})}}}}const Nn=I.BigInt(1e6),Un=new C(pt,Fe,Xe);class Rn{constructor(t,n){let o;this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.feePct=void 0,this.fee=void 0,this.address=t,this.id=t.toBase58(),o="data"in n?Un.coder.accounts.decode("poolState",n.data):n,this.poolState=o;const{token0:s,token1:r,fee:a,sqrtPriceX32:u,liquidity:c,tick:m}=this.poolState;this.tickDataProvider=new Vn(Un,{token0:s,token1:r,fee:a}),this.tokens={token0:new dt(101,s,0,"",""),token1:new dt(101,r,0,"","")},this.pool=new ct(this.tokens.token0,this.tokens.token1,a,I.BigInt(u.toString()),I.BigInt(c.toString()),m,this.tickDataProvider),this.vaults={vault0:N([this.address.toBuffer(),e.toBuffer(),s.toBuffer()],i)[0],vault1:N([this.address.toBuffer(),e.toBuffer(),r.toBuffer()],i)[0]},this.fee=I.BigInt(this.poolState.fee),this.feePct=this.poolState.fee/I.toNumber(Nn)}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=Un.coder.accounts.decode("poolState",e.data);const{fee:n,sqrtPriceX32:i,liquidity:o,tick:s}=this.poolState;this.pool=new ct(this.tokens.token0,this.tokens.token1,n,I.BigInt(i.toString()),I.BigInt(o.toString()),s,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(t)}getQuote({sourceMint:t,amount:e}){const n=t.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[i,o,s]=this.pool.getOutputAmount(lt.fromRawAmount(n,e)),r=T(I.subtract(this.pool.sqrtRatioX32,o.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:e,outAmount:i.quotient,feeAmount:I.divide(I.multiply(e,this.fee),Nn),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:r.toNumber()}}getSwapLegAndAccounts(t){const[n,i]=t.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],o=N([mt,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),ot(this.poolState.fee),rt(this.poolState.observationIndex)],Fe)[0],s=t.sourceMint.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[,,r]=this.pool.getOutputAmount(lt.fromRawAmount(s,t.amount)),a=N([mt,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),ot(this.poolState.fee),rt((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],Fe)[0],u={poolAddress:this.address,inputVault:n,outputVault:i,nextObservationState:a,lastObservationState:o,swapAccountMetas:r};return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[ln({cykura:{}}),fn.instruction.cykuraSwap({accounts:{swapProgram:Fe,signer:o,factoryState:Le,poolState:t.poolAddress,inputTokenAccount:n,outputTokenAccount:i,inputVault:t.inputVault,outputVault:t.outputVault,lastObservationState:t.lastObservationState,coreProgram:Fe,tokenProgram:e},remainingAccounts:[...t.swapAccountMetas,{pubkey:t.nextObservationState,isSigner:!1,isWritable:!0},Sn]}).keys]}({...t,additionalArgs:u})}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}const Kn={DkwiQyA2JfD8ARfvMbMqu2DD4XKRkewRZVDE94SZNxSS:{price:1}},Wn=ht(Ue,Xe);class Qn{constructor(t,e){this.address=void 0,this.id=void 0,this.label="DeltaFi",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapInfo=void 0,this.feePct=void 0,this.prices=void 0,this.pythAddresses=void 0,this.address=t,this.id=t.toBase58(),this.swapInfo=Wn.coder.accounts.decode("SwapInfo",e.data);const{swapConfig:n}=this.swapInfo;this.feePct=n.tradeFeeNumerator/n.tradeFeeDenominator,this.pythAddresses=[this.swapInfo.pythPriceBase,this.swapInfo.pythPriceQuote].filter((t=>!a.programId.equals(t)))}getAccountsForUpdate(){return[this.address,...this.pythAddresses]}getPriceData(t,e){const{id:n}=this,i=t.get(e.toBase58())||Kn[n];if(!i)throw new Error(`Missing pyth account info for ${e.toBase58()}`);return"data"in i?ft(i.data):i}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing ${this.address.toBase58()}`);this.swapInfo=Wn.coder.accounts.decode("SwapInfo",e.data);try{const e=this.getPriceData(t,this.swapInfo.pythPriceBase),n=this.getPriceData(t,this.swapInfo.pythPriceQuote);if(e.price&&n.price){const t=new St(e.price).dividedBy(new St(n.price)),i=new St(e.price+e.confidence).dividedBy(new St(n.price-n.confidence)),o=new St(e.price-e.confidence).dividedBy(new St(n.price+n.confidence));this.prices={marketPrice:t,highPrice:i,lowPrice:o}}else this.prices=void 0}catch(t){this.prices=void 0}}getQuote({destinationMint:t,amount:e}){if(!this.prices)throw new Error("Missing price data from pyth");const{swapInfo:n}=this,{amountIn:i,amountOut:o,priceImpact:s}=gt(n,t.equals(n.mintQuote)?{sellBase:{}}:{sellQuote:{}},new St(e.toString()),this.prices.marketPrice,this.prices.highPrice,this.prices.lowPrice),r=o.multipliedBy(n.swapConfig.tradeFeeNumerator.toString()).dividedBy(n.swapConfig.tradeFeeDenominator.toString()).decimalPlaces(0),a=o.minus(r);return{notEnoughLiquidity:!1,inAmount:I.BigInt(i),outAmount:I.BigInt(a),feeAmount:I.BigInt(r),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:Number(s)}}getSwapLegAndAccounts(t){var n;if(!this.prices)throw new Error("Missing price data from pyth");const{swapSourceToken:i,swapDestinationToken:o,adminDestinationToken:s}=this.swapInfo.mintBase.equals(t.sourceMint)?{swapSourceToken:this.swapInfo.tokenBase,swapDestinationToken:this.swapInfo.tokenQuote,adminDestinationToken:this.swapInfo.adminFeeTokenQuote}:{swapSourceToken:this.swapInfo.tokenQuote,swapDestinationToken:this.swapInfo.tokenBase,adminDestinationToken:this.swapInfo.adminFeeTokenBase};return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[ln((s=t.stable,{deltaFi:{stable:s}})),fn.instruction.deltafiSwap({accounts:{swapProgram:Ue,marketConfig:t.marketConfig,swapInfo:t.swapInfo,userSourceToken:n,userDestinationToken:i,swapSourceToken:t.swapSourceToken,swapDestinationToken:t.swapDestinationToken,deltafiUser:Re,adminDestinationToken:t.adminDestinationToken,pythPriceBase:t.pythPriceBase,pythPriceQuote:t.pythPriceQuote,userAuthority:o,tokenProgram:e},remainingAccounts:t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[Sn]}).keys];var s}({additionalArgs:{stable:!!this.swapInfo.swapType.stableSwap,marketConfig:this.swapInfo.configKey,swapInfo:this.address,swapSourceToken:i,swapDestinationToken:o,adminDestinationToken:s,pythPriceBase:this.swapInfo.pythPriceBase,pythPriceQuote:this.swapInfo.pythPriceQuote,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.destinationMint.toBase58())},...t})}get reserveTokenMints(){return[this.swapInfo.mintQuote,this.swapInfo.mintBase]}}const zn=e=>t.fromBuffer(e.data.slice(64,72)),jn=e=>t.fromBuffer(e.data.slice(36,44));class Hn{constructor(t,e){this.address=void 0,this.id=void 0,this.label="GooseFX",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.pairLayout=void 0,this.quoter=void 0,this.gooseFxAccounts=void 0,this.fixedAccounts=void 0,this.oracleAccounts=[],this.quoteParams=void 0,this.isQuoteInvalid=!0,this.address=t,this.id=t.toBase58(),this.pairLayout=kt.decode(e.data);const[n,i]=this.pairLayout.mints,o=new wt;this.quoter=o.getSyncQuoter(n,i),this.gooseFxAccounts=this.quoter.getAccounts();const{pairAddress:s,sslIn:r,sslOut:a,liabilityVaultIn:u,liabilityVaultOut:c,swappedLiabilityVaultIn:m,swappedLiabilityVaultOut:p}=this.gooseFxAccounts;this.fixedAccounts=[s,r,a,u,c,m,p],this.updateOracles()}updateOracles(){const t=Number(this.pairLayout.nOracle.toString()),e=this.pairLayout.oracles.slice(0,t).reduce(((t,e)=>{const n=Number(e.n);for(const i of e.elements.slice(0,n))t.push(i.address);return t}),[]);this.oracleAccounts=e}getAccountsForUpdate(){return[...this.fixedAccounts,...this.oracleAccounts]}update(t){var e;const[n,i,o,s,r,a,u]=oe(t,this.fixedAccounts);if(!(n&&i&&o&&s&&r&&a&&u))throw new Error("Missing account data");const c=yt.OracleRegistry;this.pairLayout=kt.decode(n.data);const{oracles:m,nOracle:p}=this.pairLayout,d=Number(p.toString()),l=new c;this.updateOracles();for(const e of m.slice(0,d)){const n=Number(e.n);for(const i of e.elements.slice(0,n)){const e=t.get(i.address.toBase58());if(!e)return void(this.isQuoteInvalid=!0);l.add_oracle(i.address.toBuffer(),e.data)}}this.isQuoteInvalid&&(this.isQuoteInvalid=!1),null===(e=this.quoteParams)||void 0===e||e.registry.free(),this.quoteParams={liabilityIn:BigInt(zn(s).toString()),liabilityOut:BigInt(zn(r).toString()),pairData:n.data,sslInData:i.data,sslOutData:o.data,swappedLiabilityIn:BigInt(zn(a).toString()),swappedLiabilityOut:BigInt(zn(u).toString()),registry:l,suspended:new At(i).isSuspended()||new At(o).isSuspended()}}getQuote({sourceMint:t,amount:e}){if(!this.quoteParams||this.isQuoteInvalid)throw new Error("Missing quote data");const{quoteParams:n}=this,i=yt.swap;let o;const s=t.equals(this.pairLayout.mints[0]);o=s?i(n.sslInData.slice(),n.sslOutData.slice(),n.pairData.slice(),n.liabilityIn,n.liabilityOut,n.swappedLiabilityIn,n.swappedLiabilityOut,n.registry,BigInt(e.toString())):i(n.sslOutData.slice(),n.sslInData.slice(),n.pairData.slice(),n.liabilityOut,n.liabilityIn,n.swappedLiabilityOut,n.swappedLiabilityIn,n.registry,BigInt(e.toString()));const r=this.pairLayout.feeRates[s?0:1],a={notEnoughLiquidity:!1,inAmount:I.BigInt(o.amount_in.toString()),outAmount:I.BigInt(o.amount_out.toString()),feeAmount:I.BigInt(o.fee_paid.toString()),feeMint:t.toBase58(),feePct:r/1e4,priceImpactPct:o.price_impact};return o.free(),a}findAssociatedTokenAddress(t,n){return s.findProgramAddressSync([t.toBuffer(),e.toBuffer(),n.toBuffer()],Tt)[0]}getSwapLegAndAccounts(t){var n;if(!this.quoteParams)throw new Error("Missing quote data");const i=t.sourceMint.equals(this.pairLayout.mints[0]),{gooseFxAccounts:o}=this,[s,r,a,u,c,m]=i?[o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn,o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut]:[o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut,o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn];return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const s=[];return s.push(t.referrer?{pubkey:t.referrer,isSigner:!1,isWritable:!0}:Sn),t.oracles.forEach((t=>{s.push({pubkey:t,isSigner:!1,isWritable:!1})})),s.push(Sn),[ln({gooseFx:{}}),fn.instruction.goosefxSwap({accounts:{swapProgram:Ke,controller:We,pair:t.pair,sslIn:t.sslIn,sslOut:t.sslOut,liabilityVaultIn:t.liabilityVaultIn,swappedLiabilityVaultIn:t.swappedLiabilityVaultIn,liabilityVaultOut:t.liabilityVaultOut,swappedLiabilityVaultOut:t.swappedLiabilityVaultOut,userInAta:n,userOutAta:i,feeCollectorAta:t.feeCollectorAta,userWallet:o,feeCollector:t.feeCollector,tokenProgram:e},remainingAccounts:s}).keys]}({additionalArgs:{pair:this.gooseFxAccounts.pairAddress,sslIn:s,sslOut:u,liabilityVaultIn:r,swappedLiabilityVaultIn:a,liabilityVaultOut:c,swappedLiabilityVaultOut:m,feeCollectorAta:this.findAssociatedTokenAddress(this.pairLayout.feeCollector,t.sourceMint),feeCollector:this.pairLayout.feeCollector,oracles:this.oracleAccounts,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.sourceMint.toBase58())},...t})}get reserveTokenMints(){return this.pairLayout.mints}}const Xn=new C(Dt,Be,Xe);class Gn{static parsePoolStructure(t){return Xn.coder.accounts.decode("pool",t.data)}static parseTickmap(t){return Xn.coder.accounts.decode("tickmap",t.data)}static parseTick(t){return{...Xn.coder.accounts.decode("tick",t.data)}}static getQuote(t,e,n,i,o,s){const{currentTickIndex:r,fee:a,tickSpacing:u,tokenX:c,liquidity:m,sqrtPrice:p}=t,d={currentTickIndex:r,tickSpacing:u,liquidity:m,fee:a,sqrtPrice:p},l={xToY:i.equals(c),byAmountIn:s===ie.ExactIn,swapAmount:new G(o.toString()),priceLimit:i.equals(c)?vt(Pt):vt(Bt),slippage:bt(0),ticks:e,tickmap:n,pool:d};return It(l)}static getTickIndexToTickPubkeyHash(t,e,n){if(!n){const{tickAddress:n}=this.getTickAddress(t,e.currentTickIndex),i=new Map;return i.set(e.currentTickIndex,n),i}const i=Ft(n.bitmap,e.currentTickIndex,e.tickSpacing,Lt,Infinity,"down"),o=Ft(n.bitmap,e.currentTickIndex,e.tickSpacing,Lt,Infinity,"up");return i.concat([e.currentTickIndex]).concat(o).reduce(((e,n)=>{const{tickAddress:i}=this.getTickAddress(t,n);return e.set(n,i),e}),new Map)}static getTickAddress(t,e){const n=Buffer.alloc(4);n.writeInt32LE(e);const[i,o]=s.findProgramAddressSync([Buffer.from(V.bytes.utf8.encode("tickv1")),t.toBuffer(),n],Xn.programId);return{tickAddress:i,tickBump:o}}}class Yn{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Invariant",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolStructure=void 0,this.tickmap=void 0,this.tickPkToTickIndexHash=void 0,this.ticks=new Map,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.poolStructure=Gn.parsePoolStructure(e),this.tickPkToTickIndexHash=Gn.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.feePct=new Y(this.poolStructure.fee.v.toString()).div(qt.toString()).toNumber()}getAccountsForUpdate(){const t=this.tickPkToTickIndexHash.values();return[this.address,this.poolStructure.tickmap,...t]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing invariant pool data ${this.address.toBase58()}`);this.poolStructure=Gn.parsePoolStructure(e);const n=t.get(this.poolStructure.tickmap.toBase58());n&&(this.tickmap=Gn.parseTickmap(n)),this.tickPkToTickIndexHash=Gn.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.ticks.clear();for(const[e,n]of this.tickPkToTickIndexHash){const i=t.get(n.toBase58());if(!i)continue;const o=Gn.parseTick(i);this.ticks.set(e,o)}}getQuote({sourceMint:t,amount:e,swapMode:n}){if(!this.tickmap)throw new Error("Missing tickmap");const i=Gn.getQuote(this.poolStructure,this.ticks,this.tickmap,t,e,n),o=new Y(i.priceImpact.toString()).div(qt.toString()).toNumber();if(0!==i.status)throw new Error(`Invariant simulation failed: ${this.address}`);return{notEnoughLiquidity:!1,inAmount:I.BigInt(i.accumulatedAmountIn.toString()),outAmount:I.BigInt(i.accumulatedAmountOut.toString()),feeAmount:I.BigInt(i.accumulatedFee.toString()),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:o}}getSwapLegAndAccounts(t){var n;if(!this.tickmap)throw new Error("Missing tickmap");const i=Gn.getQuote(this.poolStructure,this.ticks,this.tickmap,t.sourceMint,t.amount,t.swapMode),o={};this.tickPkToTickIndexHash.forEach(((t,e)=>{o[e]=t}));const s=i.crossedTicks.concat(this.poolStructure.currentTickIndex).map((t=>{const e=o[t];if(!e)throw new Error("Missing tick account.");return e})),r=t.sourceMint.equals(this.poolStructure.tokenX);return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,r]=t.xToY?[n,i]:[i,n],a=t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[];return t.crossedTickAddresses.forEach((t=>{a.push({pubkey:t,isSigner:!1,isWritable:!0})})),a.push(Sn),[ln(mn(t.xToY)),fn.instruction.invariantSwap({accounts:{swapProgram:Be,tokenProgram:e,owner:o,state:be,pool:t.pool,tickmap:t.tickmap,accountX:s,accountY:r,reserveX:t.reserveX,reserveY:t.reserveY,programAuthority:Ie},remainingAccounts:a}).keys]}({...t,additionalArgs:{xToY:r,pool:this.address,tickmap:this.poolStructure.tickmap,reserveX:this.poolStructure.tokenXReserve,reserveY:this.poolStructure.tokenYReserve,crossedTickAddresses:s,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.sourceMint.toBase58())}})}get reserveTokenMints(){return[this.poolStructure.tokenX,this.poolStructure.tokenY]}}class Zn{constructor(t,e){var n;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapState=void 0,this.poolInfo=void 0,this.accountInfos=[],this.ammAccountInfo=e,this.id=t.toBase58(),this.swapState=((t,e)=>{const n=e.owner,i=Et.decode(e.data),[o]=N([t.toBuffer()],n);return{programId:n,authority:o,amm:t,tokenAMint:i.tokenAMint,tokenBMint:i.tokenBMint,poolMint:i.poolMint,feeAccount:i.poolFeeAccount,pythAccount:i.pythAccount,pythPcAccount:i.pythPcAccount,configAccount:i.configAccount,poolCoinTokenAccount:i.tokenAAccount,poolCoinMint:i.tokenAMint,poolPcTokenAccount:i.tokenBAccount,poolPcMint:i.tokenBMint}})(t,e),this.poolInfo={amm:(n=this.swapState).amm.toBase58(),configAccount:n.configAccount.toBase58(),feeAccount:n.feeAccount.toBase58(),pythAccount:n.pythAccount.toBase58(),pythPcAccount:n.pythPcAccount.toBase58(),poolCoinMint:n.poolCoinMint.toBase58(),poolCoinTokenAccount:n.poolCoinTokenAccount.toBase58(),poolMint:n.poolMint.toBase58(),poolPcTokenAccount:n.poolPcTokenAccount.toBase58(),poolPcMint:n.poolPcMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:0}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount]}update(t){this.getAccountsForUpdate().forEach(((e,n)=>{const i=t.get(e.toBase58());i&&(this.accountInfos[n]={publicKey:e,account:i})}))}getQuote({sourceMint:t,amount:e}){if(this.accountInfos.length!==this.getAccountsForUpdate().length)throw new Error("Accounts not loaded");const n=this.swapState.poolCoinMint.equals(t)?xt.AtoB:xt.BtoA,{amm:i,pyth:o,pythPc:s,fees:r,coinBalance:a,pcBalance:u,config:c}=Ct([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...this.accountInfos],this.poolInfo);if(!o.status.equals(1)||s&&!s.status.equals(1))throw new Error("Pyth accounts are outdated");const m=new Y(e.toString()),p=Ot(m,o.publishSlot.toNumber(),i,r,a,u,c,o,s,n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:I.BigInt(p.amountSwapped.toString()),feeAmount:I.BigInt(p.fee.ceil().toString()),feeMint:t.toBase58(),feePct:p.feePercent.toNumber(),priceImpactPct:p.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({swapState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[r,a]=n.equals(t.tokenAMint)?[t.poolCoinTokenAccount,t.poolPcTokenAccount]:[t.poolPcTokenAccount,t.poolCoinTokenAccount];return[ln({lifinity:{}}),fn.instruction.lifinitySwap({accounts:{swapProgram:t.programId,authority:t.authority,amm:t.amm,userTransferAuthority:s,sourceInfo:i,destinationInfo:o,swapSource:r,swapDestination:a,poolMint:t.poolMint,feeAccount:t.feeAccount,tokenProgram:e,pythAccount:t.pythAccount,pythPcAccount:t.pythPcAccount,configAccount:t.configAccount}}).keys]}({swapState:this.swapState,...t})}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}}var Jn="marinade_finance",_n=[{name:"initialize",accounts:[{name:"creatorAuthority",isMut:!1,isSigner:!0},{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!1,isSigner:!1},{name:"liqPool",accounts:[{name:"lpMint",isMut:!1,isSigner:!1},{name:"solLegPda",isMut:!1,isSigner:!1},{name:"msolLeg",isMut:!1,isSigner:!1}]},{name:"treasuryMsolAccount",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"data",type:{defined:"InitializeData"}}]},{name:"changeAuthority",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"data",type:{defined:"ChangeAuthorityData"}}]},{name:"addValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!1,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"score",type:"u32"}]},{name:"removeValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"}]},{name:"setValidatorScore",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"},{name:"score",type:"u32"}]},{name:"configValidatorSystem",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0}],args:[{name:"extraRuns",type:"u32"}]},{name:"deposit",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"depositStakeAccount",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeAuthority",isMut:!1,isSigner:!0},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"msolMint",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"liquidUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"addLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"lpMintAuthority",isMut:!1,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!1,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"removeLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"burnFrom",isMut:!0,isSigner:!1},{name:"burnFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"transferMsolTo",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokens",type:"u64"}]},{name:"setLpParams",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"minFee",type:{defined:"Fee"}},{name:"maxFee",type:{defined:"Fee"}},{name:"liquidityTarget",type:"u64"}]},{name:"configMarinade",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigMarinadeParams"}}]},{name:"orderUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"burnMsolFrom",isMut:!0,isSigner:!1},{name:"burnMsolAuthority",isMut:!1,isSigner:!0},{name:"newTicketAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"claim",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"ticketAccount",isMut:!0,isSigner:!1},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"stakeReserve",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeConfig",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"updateActive",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"updateDeactivated",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"}]},{name:"deactivateStake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"emergencyUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"mergeStakes",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"destinationStake",isMut:!0,isSigner:!1},{name:"sourceStake",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"destinationStakeIndex",type:"u32"},{name:"sourceStakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]}],$n=[{name:"State",type:{kind:"struct",fields:[{name:"msolMint",type:"publicKey"},{name:"adminAuthority",type:"publicKey"},{name:"operationalSolAccount",type:"publicKey"},{name:"treasuryMsolAccount",type:"publicKey"},{name:"reserveBumpSeed",type:"u8"},{name:"msolMintAuthorityBumpSeed",type:"u8"},{name:"rentExemptForTokenAcc",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"stakeSystem",type:{defined:"StakeSystem"}},{name:"validatorSystem",type:{defined:"ValidatorSystem"}},{name:"liqPool",type:{defined:"LiqPool"}},{name:"availableReserveBalance",type:"u64"},{name:"msolSupply",type:"u64"},{name:"msolPrice",type:"u64"},{name:"circulatingTicketCount",type:"u64"},{name:"circulatingTicketBalance",type:"u64"},{name:"lentFromReserve",type:"u64"},{name:"minDeposit",type:"u64"},{name:"minWithdraw",type:"u64"},{name:"stakingSolCap",type:"u64"},{name:"emergencyCoolingDown",type:"u64"}]}},{name:"TicketAccountData",type:{kind:"struct",fields:[{name:"stateAddress",type:"publicKey"},{name:"beneficiary",type:"publicKey"},{name:"lamportsAmount",type:"u64"},{name:"createdEpoch",type:"u64"}]}}],ti=[{name:"Fee",type:{kind:"struct",fields:[{name:"basisPoints",type:"u32"}]}},{name:"InitializeData",type:{kind:"struct",fields:[{name:"adminAuthority",type:"publicKey"},{name:"validatorManagerAuthority",type:"publicKey"},{name:"minStake",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"liqPool",type:{defined:"LiqPoolInitializeData"}},{name:"additionalStakeRecordSpace",type:"u32"},{name:"additionalValidatorRecordSpace",type:"u32"},{name:"slotsForStakeDelta",type:"u64"}]}},{name:"LiqPoolInitializeData",type:{kind:"struct",fields:[{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"lpTreasuryCut",type:{defined:"Fee"}}]}},{name:"ChangeAuthorityData",type:{kind:"struct",fields:[{name:"admin",type:{option:"publicKey"}},{name:"validatorManager",type:{option:"publicKey"}},{name:"operationalSolAccount",type:{option:"publicKey"}},{name:"treasuryMsolAccount",type:{option:"publicKey"}}]}},{name:"ConfigMarinadeParams",type:{kind:"struct",fields:[{name:"rewardsFee",type:{option:{defined:"Fee"}}},{name:"slotsForStakeDelta",type:{option:"u64"}},{name:"minStake",type:{option:"u64"}},{name:"minDeposit",type:{option:"u64"}},{name:"minWithdraw",type:{option:"u64"}},{name:"stakingSolCap",type:{option:"u64"}},{name:"liquiditySolCap",type:{option:"u64"}},{name:"autoAddValidatorEnabled",type:{option:"bool"}}]}},{name:"LiqPool",type:{kind:"struct",fields:[{name:"lpMint",type:"publicKey"},{name:"lpMintAuthorityBumpSeed",type:"u8"},{name:"solLegBumpSeed",type:"u8"},{name:"msolLegAuthorityBumpSeed",type:"u8"},{name:"msolLeg",type:"publicKey"},{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"treasuryCut",type:{defined:"Fee"}},{name:"lpSupply",type:"u64"},{name:"lentFromSolLeg",type:"u64"},{name:"liquiditySolCap",type:"u64"}]}},{name:"List",type:{kind:"struct",fields:[{name:"account",type:"publicKey"},{name:"itemSize",type:"u32"},{name:"count",type:"u32"},{name:"newAccount",type:"publicKey"},{name:"copiedCount",type:"u32"}]}},{name:"StakeRecord",type:{kind:"struct",fields:[{name:"stakeAccount",type:"publicKey"},{name:"lastUpdateDelegatedLamports",type:"u64"},{name:"lastUpdateEpoch",type:"u64"},{name:"isEmergencyUnstaking",type:"u8"}]}},{name:"StakeSystem",type:{kind:"struct",fields:[{name:"stakeList",type:{defined:"List"}},{name:"delayedUnstakeCoolingDown",type:"u64"},{name:"stakeDepositBumpSeed",type:"u8"},{name:"stakeWithdrawBumpSeed",type:"u8"},{name:"slotsForStakeDelta",type:"u64"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"minStake",type:"u64"},{name:"extraStakeDeltaRuns",type:"u32"}]}},{name:"ValidatorRecord",type:{kind:"struct",fields:[{name:"validatorAccount",type:"publicKey"},{name:"activeBalance",type:"u64"},{name:"score",type:"u32"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"duplicationFlagBumpSeed",type:"u8"}]}},{name:"ValidatorSystem",type:{kind:"struct",fields:[{name:"validatorList",type:{defined:"List"}},{name:"managerAuthority",type:"publicKey"},{name:"totalValidatorScore",type:"u32"},{name:"totalActiveBalance",type:"u64"},{name:"autoAddValidatorEnabled",type:"u8"}]}},{name:"CommonError",type:{kind:"enum",variants:[{name:"InvalidProgramId",fields:["publicKey"]},{name:"UnexpectedAccount",fields:["publicKey"]},{name:"CalculationFailure"},{name:"AccountWithLockup"},{name:"NumberTooLow",fields:["u64","u64"]},{name:"NumberTooHigh",fields:["u64","u64"]},{name:"FeeTooHigh",fields:[{defined:"Fee"}]},{name:"FeesWrongWayRound",fields:[{defined:"Fee"},{defined:"Fee"}]},{name:"LiquidityTargetTooLow"},{name:"TicketNotDue",fields:["u64"]},{name:"TicketNotReady"},{name:"WrongBeneficiary"},{name:"InsufficientLiquidity"},{name:"InvalidValidator"}]}},{name:"InitializeError",type:{kind:"enum",variants:[{name:"WrongReserveOwner",fields:["publicKey"]},{name:"NonEmptyReserveData",fields:[{defined:"usize"}]},{name:"InvalidInitialReserveLamports",fields:["u64"]},{name:"ZeroValidatorChunkSize"},{name:"TooBigValidatorChunkSize",fields:["u32"]},{name:"ZeroCreditChunkSize"},{name:"TooBigCreditChunkSize",fields:["u32"]},{name:"TooLowCreditFee",fields:["u64"]},{name:"InvalidMintAuthority",fields:[{name:"expected",type:"publicKey"},{name:"got",type:"publicKey"}]},{name:"MintHasInitialSupply",fields:["u64"]},{name:"InvalidOwnerFeeState",fields:[{defined:"spl_token::state::AccountState"}]}]}}],ei={__proto__:null,version:"0.0.0",name:Jn,instructions:_n,accounts:$n,types:ti,default:{version:"0.0.0",name:Jn,instructions:_n,accounts:$n,types:ti}};function ni(t,e,n){return n.isZero()?t:t.mul(e).div(n)}class ii{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Marinade",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.marinadeFinanceProgram=void 0,this.marinadeStateResponse=void 0,this.liqPoolSolLegPdaAddress=void 0,this.marinadeState=void 0,this.id=t.toBase58(),this.marinadeFinanceProgram=new C(ei,De,{}),this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",e.data),this.address=t,this.liqPoolSolLegPdaAddress=this.findProgramDerivedAddress("liq_sol")}getAccountsForUpdate(){return[this.address,this.liqPoolSolLegPdaAddress,this.marinadeStateResponse.liqPool.msolLeg]}update(t){const[e,n,i]=oe(t,this.getAccountsForUpdate());this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",e.data);const o=F(i.data);if(!o)throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);this.marinadeState=new oi(this.marinadeStateResponse,new X(n.lamports),o.amount)}getQuote({sourceMint:t,amount:e}){if(!this.marinadeState)throw new Error("Update was not run to create a complete marinadeState");const i=new X(e.toString()),o=t.equals(n)?this.marinadeState.depositQuote(i):this.marinadeState.liquidUnstakeQuote(i);return{notEnoughLiquidity:!1,inAmount:e,outAmount:I.BigInt(o.outAmount.toString()),feeAmount:I.BigInt(o.feeAmount.toString()),feeMint:this.marinadeStateResponse.msolMint.toBase58(),feePct:o.feePct,priceImpactPct:0}}getSwapLegAndAccounts(t){return t.sourceMint.equals(n)?function({additionalArgs:t,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const r=s,c=N([Buffer.from("temp-wsol-token-account"),r.toBuffer()],hn)[0],m=N([Buffer.from("temp-sol-pda"),s.toBuffer()],hn)[0];return[ln({marinadeDeposit:{}}),fn.instruction.marinadeDeposit({accounts:{marinadeFinanceProgram:De,state:t.address,userTransferAuthority:s,msolMint:t.marinadeStateResponse.msolMint,liqPoolSolLegPda:t.liqPoolSolLegPda,liqPoolMsolLeg:t.marinadeStateResponse.liqPool.msolLeg,liqPoolMsolLegAuthority:t.liqPoolMsolLegAuthority,reservePda:t.reservePda,transferFrom:m,mintTo:o,msolMintAuthority:t.msolMintAuthority,systemProgram:a.programId,tokenProgram:e,userWsolTokenAccount:i,tempWsolTokenAccount:c,wsolMint:n,rent:u}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress,liqPoolMsolLegAuthority:this.findProgramDerivedAddress("liq_st_sol_authority"),reservePda:this.findProgramDerivedAddress("reserve"),msolMintAuthority:this.findProgramDerivedAddress("st_mint")},...t}):function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const s=N([Buffer.from("temp-sol-pda"),o.toBuffer()],hn)[0];return[ln({marinadeUnstake:{}}),fn.instruction.marinadeUnstake({accounts:{marinadeFinanceProgram:De,state:t.address,msolMint:t.marinadeStateResponse.msolMint,liqPoolSolLegPda:t.liqPoolSolLegPda,liqPoolMsolLeg:t.marinadeStateResponse.liqPool.msolLeg,treasuryMsolAccount:t.marinadeStateResponse.treasuryMsolAccount,getMsolFrom:n,getMsolFromAuthority:o,transferSolTo:s,systemProgram:a.programId,tokenProgram:e,userWsolTokenAccount:i}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress},...t})}get reserveTokenMints(){return[n,this.marinadeStateResponse.msolMint]}findProgramDerivedAddress(t,e=[]){const n=[this.address.toBuffer(),Buffer.from(t),...e],[i]=N(n,this.marinadeFinanceProgram.programId);return i}}class oi{constructor(t,e,n){this.state=void 0,this.liqPoolSolLegPdaLamports=void 0,this.liqPoolMSOLLegAmount=void 0,this.state=t,this.liqPoolSolLegPdaLamports=e,this.liqPoolMSOLLegAmount=n}depositQuote(t){let e=t;const n=this.calcMSOLFromLamports(e),i=X.min(n,this.liqPoolMSOLLegAmount);let o=new X(0);if(e=(()=>{if(i.gt(new X(0))){const t=n.eq(i)?e:this.calcLamportsFromMSOLAmount(i);return o=o.add(i),si(e,t)}return e})(),e.gt(new X(0))){this.checkStakingCap(e);const t=this.calcMSOLFromLamports(e);o=o.add(t)}return{outAmount:o,feeAmount:0,feePct:0,priceImpactPct:0}}checkStakingCap(t){if(this.totalLamportsUnderControl().add(t).gt(this.state.stakingSolCap))throw new Error("Staking cap reached")}calcMSOLFromLamports(t){return e=t,n=this.totalVirtualStakedLamports(),(i=this.state.msolSupply).eq(new X(0))?e:ni(e,i,n);var e,n,i}calcLamportsFromMSOLAmount(t){return ni(t,this.totalVirtualStakedLamports(),this.state.msolSupply)}totalVirtualStakedLamports(){return si(this.totalLamportsUnderControl(),this.state.circulatingTicketBalance)}totalLamportsUnderControl(){return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance)}totalCoolingDown(){return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown)}liquidUnstakeQuote(t){const e=si(this.liqPoolSolLegPdaLamports,this.state.rentExemptForTokenAcc),n=this.calcLamportsFromMSOLAmount(t),i=function(t,e,n,i,o){if(o.gte(i))return e;const s=i.sub(o);return s.gte(n)?t:e-ni(new X(e-t),s,n).toNumber()}(this.state.liqPool.lpMinFee.basisPoints,this.state.liqPool.lpMaxFee.basisPoints,this.state.liqPool.lpLiquidityTarget,e,n),o=t.mul(new X(i)).div(new X(1e4)),s=this.calcLamportsFromMSOLAmount(t.sub(o));if(s.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports))throw new Error("Insufficient liquidity");return{outAmount:s,feeAmount:o,feePct:i/1e4,priceImpactPct:0}}}function si(t,e){return t.gt(e)?t.sub(e):new X(0)}const ri=Math.pow(10,10),ai=W([Q("version"),Q("isInitialized"),Q("nonce"),Je("amplificationCoefficient"),Je("feeNumerator"),Je("adminFeeNumerator"),z("tokenAccountsLength"),Je("precisionFactor"),Je("precisionMultiplierA"),Je("precisionMultiplierB"),Je("precisionMultiplierC"),Je("precisionMultiplierD"),Ye("tokenAccountA"),Ye("tokenAccountB"),Ye("tokenAccountC"),Ye("tokenAccountD")]),ui=(t,e)=>{const n=e.owner,i=ai.decode(e.data),o=i.tokenAccountsLength,s=$e([t.toBuffer(),Buffer.from([i.nonce])],n),r=[i.precisionMultiplierA.toNumber(),i.precisionMultiplierB.toNumber(),i.precisionMultiplierC.toNumber(),i.precisionMultiplierD.toNumber()].slice(0,o),a=[i.tokenAccountA,i.tokenAccountB,i.tokenAccountC,i.tokenAccountD].slice(0,o);return{programId:n,authority:s,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:t,amplificationCoefficient:i.amplificationCoefficient.toNumber(),feeNumerator:i.feeNumerator.toNumber(),tokenAccountsLength:o,precisionFactor:i.precisionFactor.toNumber(),precisionMultipliers:r,tokenAccounts:a}};class ci{constructor(t,e,n){this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapLayout=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.id=t.toBase58(),this.swapLayout=ui(t,e),this.calculator=new v(I.BigInt(this.swapLayout.tokenAccountsLength),I.BigInt(this.swapLayout.amplificationCoefficient),this.swapLayout.precisionMultipliers.map((t=>I.BigInt(t))),new A(I.BigInt(this.swapLayout.feeNumerator),I.BigInt(ri)))}getAccountsForUpdate(){return this.swapLayout.tokenAccounts}update(t){let e=oe(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>F(t.data))).filter((t=>null!==t))}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const i=this.tokenAccounts.findIndex((e=>e.mint.equals(t))),o=this.tokenAccounts.findIndex((t=>t.mint.equals(e))),s=this.calculator.exchange(se(this.tokenAccounts),n,i,o),r=this.swapLayout.feeNumerator/ri;return{notEnoughLiquidity:!1,inAmount:n,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:e.toBase58(),feePct:r,priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({swapLayout:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];for(const e of t.tokenAccounts)o.push({pubkey:e,isSigner:!1,isWritable:!0});return[ln({mercurial:{}}),fn.instruction.mercurialSwap({accounts:wn(t,e,n,i),remainingAccounts:o}).keys]}({swapLayout:this.swapLayout,...t})}get reserveTokenMints(){return this.params.tokenMints.map((t=>new s(t)))}}ci.decodeSwapLayout=ui;const mi=new C(Vt,Nt,Xe),pi=new C(Ut,Nt,Xe),di=t=>mi.coder.accounts.decode("pool",t.data),li=t=>pi.coder.accounts.decode("vault",t.data);class gi{constructor(t,e,n){this.address=void 0,this.id=void 0,this.label="Meteora",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.data=void 0,this.depegAccount=void 0,this.depegAccounts=new Map,this.vaultLpMint=void 0,this.vaultToken=void 0,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.poolState=di(e),this.vaultLpMint={a:new s(n.vaultLpMint.a),b:new s(n.vaultLpMint.b)},this.vaultToken={a:new s(n.vaultToken.a),b:new s(n.vaultToken.b)},n.depegAccount&&(this.depegAccount={...n.depegAccount,pubkey:new s(n.depegAccount.pubkey),data:Buffer.from(n.depegAccount.data[0],n.depegAccount.data[1]),owner:new s(n.depegAccount.owner)},this.depegAccounts=new Map([[this.depegAccount.pubkey.toBase58(),this.depegAccount]]));const{ownerTradeFeeDenominator:i,ownerTradeFeeNumerator:o,tradeFeeDenominator:r,tradeFeeNumerator:a}=this.poolState.fees;this.feePct=new Y(o.toString()).div(i.toString()).add(new Y(a.toString()).div(r.toString())).toNumber()}getAccountsForUpdate(){return[this.poolState.aVault,this.poolState.bVault,this.poolState.aVaultLp,this.poolState.bVaultLp,this.poolState.lpMint,this.vaultLpMint.a,this.vaultLpMint.b,this.vaultToken.a,this.vaultToken.b,c]}update(t){const[e,n,i,o,s,r,a,u,c,m]=oe(t,this.getAccountsForUpdate());this.data={vaultA:li(e),vaultB:li(n),poolAVaultLpAmount:zn(i),poolBVaultLpAmount:zn(o),poolLpTotalSupply:jn(s),vaultALpTotalSupply:jn(r),vaultBLpTotalSupply:jn(a),vaultAReserve:zn(u),vaultBReserve:zn(c),currentTime:new G(m.data.readBigInt64LE(32).toString()).toNumber()}}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(void 0===this.data)throw new Error("Unable to fetch accounts.");let i=new G(n.toString());const o=Rt(t,i,{currentTime:this.data.currentTime,depegAccounts:this.depegAccounts,poolState:this.poolState,poolVaultALp:this.data.poolAVaultLpAmount,poolVaultBLp:this.data.poolBVaultLpAmount,vaultA:this.data.vaultA,vaultALpSupply:this.data.vaultALpTotalSupply,vaultB:this.data.vaultB,vaultBLpSupply:this.data.vaultBLpTotalSupply,vaultAReserve:this.data.vaultAReserve,vaultBReserve:this.data.vaultBReserve});return{notEnoughLiquidity:!1,inAmount:n,outAmount:I.BigInt(o.amountOut.toString()),feeAmount:I.BigInt(o.fee.toString()),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:0}}getSwapLegAndAccounts(t){var n,i;if(void 0===this.data)throw new Error("Unable to fetch accounts.");const o=t.sourceMint.equals(this.poolState.tokenAMint)?this.poolState.adminTokenAFee:this.poolState.adminTokenBFee;return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const s=[];return s.push(t.referrer?{pubkey:t.referrer,isSigner:!1,isWritable:!0}:Sn),s.push(t.depeg?{pubkey:t.depeg,isSigner:!1,isWritable:!1}:Sn),[ln({meteora:{}}),fn.instruction.meteoraSwap({accounts:{swapProgram:Ve,pool:t.pool,userSourceToken:n,userDestinationToken:i,aVault:t.aVault,bVault:t.bVault,aTokenVault:t.aTokenVault,bTokenVault:t.bTokenVault,aVaultLpMint:t.aVaultLpMint,bVaultLpMint:t.bVaultLpMint,aVaultLp:t.aVaultLp,bVaultLp:t.bVaultLp,adminTokenFee:t.adminTokenFee,user:o,vaultProgram:Ne,tokenProgram:e},remainingAccounts:s}).keys]}({additionalArgs:{pool:this.address,aVault:this.poolState.aVault,bVault:this.poolState.bVault,aTokenVault:this.vaultToken.a,bTokenVault:this.vaultToken.b,aVaultLpMint:this.vaultLpMint.a,bVaultLpMint:this.vaultLpMint.b,aVaultLp:this.poolState.aVaultLp,bVaultLp:this.poolState.bVaultLp,adminTokenFee:o,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.sourceMint.toBase58()),depeg:null===(i=this.depegAccount)||void 0===i?void 0:i.pubkey},...t})}get reserveTokenMints(){return[this.poolState.tokenAMint,this.poolState.tokenBMint]}}gi.accountInfoToMeteoraSwapLayout=di,gi.accountInfoToVaultLayout=li;const hi=W([j("status"),j("nonce"),j("orderNum"),j("depth"),j("coinDecimals"),j("pcDecimals"),j("state"),j("resetFlag"),j("minSize"),j("volMaxCutRatio"),j("amountWaveRatio"),j("coinLotSize"),j("pcLotSize"),j("minPriceMultiplier"),j("maxPriceMultiplier"),j("systemDecimalsValue"),j("minSeparateNumerator"),j("minSeparateDenominator"),j("tradeFeeNumerator"),j("tradeFeeDenominator"),j("pnlNumerator"),j("pnlDenominator"),j("swapFeeNumerator"),j("swapFeeDenominator"),j("needTakePnlCoin"),j("needTakePnlPc"),j("totalPnlPc"),j("totalPnlCoin"),_e("poolTotalDepositPc"),_e("poolTotalDepositCoin"),_e("swapCoinInAmount"),_e("swapPcOutAmount"),j("swapCoin2PcFee"),_e("swapPcInAmount"),_e("swapCoinOutAmount"),j("swapPc2CoinFee"),Ye("poolCoinTokenAccount"),Ye("poolPcTokenAccount"),Ye("coinMintAddress"),Ye("pcMintAddress"),Ye("lpMintAddress"),Ye("ammOpenOrders"),Ye("serumMarket"),Ye("serumProgramId"),Ye("ammTargetOrders"),Ye("poolWithdrawQueue"),Ye("poolTempLpTokenAccount"),Ye("ammOwner"),Ye("pnlOwner")]);class fi{constructor(t,e,n){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=t,this.id=t.toBase58();const i=hi.decode(e.data);this.status=i.status,this.coinMint=new s(i.coinMintAddress),this.pcMint=new s(i.pcMintAddress),this.poolCoinTokenAccount=new s(i.poolCoinTokenAccount),this.poolPcTokenAccount=new s(i.poolPcTokenAccount),this.serumProgramId=new s(i.serumProgramId),this.serumMarket=new s(i.serumMarket),this.ammOpenOrders=new s(i.ammOpenOrders),this.ammTargetOrders=new s(i.ammTargetOrders),this.serumMarketKeys=Object.keys(n).reduce(((t,e)=>{if(!n[e])throw new Error(`Could not find ${e} in params`);return t[e]=new s(n[e]),t}),{});const o=i.swapFeeNumerator,r=i.swapFeeDenominator;this.feePct=new Y(o.toString()).div(r.toString()),this.calculator=new y(new A(I.BigInt(o),I.BigInt(r)),P)}static decodeSerumMarketKeysString(t,e,n){const i=l.getLayout(t).decode(n.data),o=$e([e.toBuffer(),i.vaultSignerNonce.toArrayLike(Buffer,"le",8)],t);return{serumBids:i.bids.toBase58(),serumAsks:i.asks.toBase58(),serumEventQueue:i.eventQueue.toBase58(),serumCoinVaultAccount:i.baseVault.toBase58(),serumPcVaultAccount:i.quoteVault.toBase58(),serumVaultSigner:o.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(e){const[n,i,o,s]=oe(e,this.getAccountsForUpdate()),[r,a]=[zn(i),zn(o)],u=g.fromAccountInfo(this.ammOpenOrders,s,s.owner),c=hi.decode(n.data);this.coinReserve=r.add(u.baseTokenTotal).sub(new t(String(c.needTakePnlCoin))),this.pcReserve=a.add(u.quoteTokenTotal).sub(new t(String(c.needTakePnlPc)))}getQuote({sourceMint:t,amount:e}){const{coinReserve:n,pcReserve:i}=this;if(!n||!i)throw new Error("Pool token accounts balances not refreshed or empty");const o=this.coinMint.equals(t)?1:0,s=this.calculator.exchange([I.BigInt(n),I.BigInt(i)],e,o);return{notEnoughLiquidity:!1,inAmount:e,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({raydiumAmm:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:i}){return[ln({raydium:{}}),fn.instruction.raydiumSwap({accounts:yn(t,e,n,i)}).keys]}({raydiumAmm:this,...t})}get reserveTokenMints(){return[this.coinMint,this.pcMint]}}var Si=[{wrapper:"2B5Qedoo95Pjpv9xVPw82bbmcGDGCNHroKpzQE2CNHRZ",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"3YCGgStAV9H7TdPYdBnRP8yoH4Zqdmyt7xo6KB4Wa8xt",mint:"C9xqJe3gMTUDKidZsZ6jJ7tL9zSLimDUKVpgUbLZnNbi",decimals:9},{wrapper:"2ffwMLE4dxSv59eYXhfhfuS81kz6gzf6DZjdBxRHZz9A",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"H5tnZcfHCzHueNnfd6foeBBUUW4g7qXKt6rKzT7wg6oP",mint:"FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",decimals:9},{wrapper:"3A85wiQg2REhBVxVS1CjDaS333TBNM2g37BbdNGSMheg",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"764FaQrrREvNTpaH2yXyrPZgVBaXA7AXM8vyCaevXitD",mint:"BtX7AfzEJLnU8KQR1AgHrhGH5s2AHUTbfjhUQP8BhPvi",decimals:10},{wrapper:"7hWjnVC6FNkmmgjq88LEnRycrKvxVB1MsJ6FQcrvxe4n",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"B22gDMgN2tNWmvyzhb5tamJKanWcUUUw2zN3h3qjgQg8",mint:"9999j2A8sXUtHtDoQdk528oVzhaKBsXyRGZ67FKGoi7H",decimals:9},{wrapper:"8zooyPZrq2mth917VrHLtNTk6GvAhc2KgdB4DGBXYyke",underlying:"AUrMpCDYYcPuHhyNX8gEEqbmDPFUpBpHrNW3vPeCFn5Z",underlyingDecimals:9,wrapperUnderlyingTokens:"7ZZyhVde6ZmnVMuFnrg3mRPHhvfBixLdEo7RnwxTtpF7",mint:"EY3s4nXTzHDiiysmjvj7zWP6yAX3n4xHmXkJWD1w1tGP",decimals:15},{wrapper:"93qsLbASEG8DmtSB2MEVaa25KvEm2afh5rzbaAJHLi5A",underlying:"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",underlyingDecimals:8,wrapperUnderlyingTokens:"4fUL9yLbFZEuG32SaCjWqJXwDTBFNnipteBWxMvvFoC8",mint:"KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",decimals:9},{wrapper:"ACvLVgR3UKdDB3b1QapsbJsPXaUrBPdJGDfiFnMYMXoz",underlying:"F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W",underlyingDecimals:6,wrapperUnderlyingTokens:"AvqMJWHsZscPWTAUcj8dZi2ch6XQEHMpiCMprfFovaU",mint:"LUNGEjUXyP48nrC1GYY5o4eTAkwm4RdX8BxFUxWJBLB",decimals:9},{wrapper:"AnKLLfpMcceM6YXtJ9nGxYekVXqfWy8WNsMZXoQTCVQk",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"77XHXCWYQ76E9Q3uCuz1geTaxsqJZf9RfX5ZY7yyLDYt",mint:"JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",decimals:9},{wrapper:"CGxMr5UrTjApBjU656N9NBAsGby4fWs1KgVtueQ8WKt6",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"7dVPR6jx3hKyNfuHPo3WtWdUpH4eh4Up4rfFhLHZqwy3",mint:"FTT8cGNp3rfTC6c44uPTuEFLqmsVDhjd2BhH65v2uppr",decimals:8},{wrapper:"D231Uoh24bXtUtWN51ZbFAFSBmGT3zuuEAHZNuCmtRjN",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"C39Wq6X98TLcrnYCMkcHQhwUurkQMUdibUCpf2fVBDsm",mint:"FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",decimals:9},{wrapper:"EhQqUmkUXXnxmV7yA6PDrQWvLgSd9HkrwdDKk1B5m6Tc",underlying:"CbNYA9n3927uXUukee2Hf4tm3xxkffJPPZvGazc2EAH1",underlyingDecimals:8,wrapperUnderlyingTokens:"8YC5eCS99umbK9K9LnHnTMMjnr7EWg1gam5maNB6uf9d",mint:"EU9aLffrTckFCs16da6CppHy63fAxMPF9ih1erQTuuRt",decimals:9},{wrapper:"EwWpia5t9Twiwdi8ghK8e8JHaf6ShNU9jmoYpvdZhBwC",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"9YB1zRL4ETuQFG8ZK1yD4GHBVDmH81EzwuSj75zdnKhK",mint:"UST8SCn7jrqsq51odVLqcmvnC658HkqrKrPL3w2hHQ7",decimals:8},{wrapper:"F9TsAsh5RirU3LqyTJECLQEGXnF4RQT7ckvexCP1KNTu",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"BSTjdztBrsptuxfz9JHS31Wc9CknpLeL1wqZjeVs1Ths",mint:"AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",decimals:9},{wrapper:"FCgoT8RpsopdM5QT6AB98NUfUnDnu7y865MFpRx93JrS",underlying:"EzfgjvkSwthhgHaceR3LnKXUoRkP6NUhfghdaHAj1tUv",underlyingDecimals:8,wrapperUnderlyingTokens:"5yugfArBAUZJJBUCRWPuiLyi6CWp1f67H9xgg3hcgSkx",mint:"FTT9GrHBVHvDeUTgLU8FxVJouGqg9uiWGmmjETdm32Sx",decimals:9},{wrapper:"FDGtFWVhEb1zxnaW2FzogeGDxLoAV7Cu9XdNYPEVwqt",underlying:"8wv2KAykQstNAj2oW6AHANGBiFKVFhvMiyyzzjhkmGvE",underlyingDecimals:6,wrapperUnderlyingTokens:"4R6PmC8BJcPDBsEMGpXpLCnFFkUZhEgZy6pMNtc2LqA4",mint:"KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",decimals:9},{wrapper:"FPuYMuodknZuQKHA8Wp4PBbp52Qu8nK2oAuwedp2WfM3",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"GxpyQZi5VkZDSq5TUycMau11sCkQkVCa8xYhBgiPMsyK",mint:"UST98bfV6EASdTFQrRwCBczpehdMFwYCUdLT5tEbhpW",decimals:9},{wrapper:"Ffxi5TSpFV9NeV5KyNDCC7fWnFoFd2bDcL1eViSAE2M2",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"5s2et753hMXV945U3p5uz6RQqMkZGCPEjKjNPdUcCLLF",mint:"CASHedBw9NfhsLBXq1WNVfueVznx255j8LLTScto3S6s",decimals:8},{wrapper:"G4gRGymKo7MGzGZup12JS39YVCvy8YMM6KY9AmcKi5iw",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"AQhP39mE4o6BYNwnwYqnz7ZobkPBSLpCg8WvEESq1viZ",mint:"88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",decimals:8},{wrapper:"GiLSv94Wwyd6suH57Fu6HjEKsMxhNGfEwKn9vT22me1p",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"3cjAWoyDcco8UVCN17keNUNHoyz37ctgDa7G6zkeb81Y",mint:"T8KdT8hDzNhbGx5sjpEUxepnbDB1TZoCa7vtC5JjsMw",decimals:8},{wrapper:"GpkFF2nPfjUcsavgDGscxaUEQ2hYJ563AXXtU8ohiZ7c",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"6hYDFhZ5ddfzoqaAbzRHm8mzG2MQzYQV9295sQHsvNBV",mint:"SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",decimals:8},{wrapper:"fvSvtHNFuDHrAN82YEyBApRs3U6vUGCLzKGMuPmCaF8",underlying:"2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",underlyingDecimals:6,wrapperUnderlyingTokens:"4JWyJ4ZYsQ8uiYue2tTEqcHcFXrDuaQ1rsyjNFfrZm65",mint:"SL819j8K9FuFPL84UepVcFkEZqDUUvVzwDmJjCHySYj",decimals:8}];function ki(){return Si.map((t=>{const e={wrapper:new s(t.wrapper),underlying:new s(t.underlying),underlyingDecimals:t.underlyingDecimals,wrapperUnderlyingTokens:new s(t.wrapperUnderlyingTokens),mint:new s(t.mint),decimals:t.decimals};return new Ai(new wi(e))}))}class wi{constructor(t){this.addDecimals=void 0,this.multiplier=void 0,this.addDecimals=t,this.multiplier=I.BigInt(10**(this.addDecimals.decimals-this.addDecimals.underlyingDecimals))}getOutputAmount(t,e){if(this.addDecimals.mint.equals(e))return this.calculateWithdrawOutputAmount(t);if(this.addDecimals.underlying.equals(e))return this.calculateDepositOutputAmount(t);throw new Error(`unknown input token: ${e.toString()}`)}calculateDepositOutputAmount(t){return I.multiply(t,this.multiplier)}calculateWithdrawOutputAmount(t){return I.divide(t,this.multiplier)}}class Ai{constructor(t){this.wrappedToken=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.wrappedToken=t,this.id=this.wrappedToken.addDecimals.wrapper.toBase58()}getAccountsForUpdate(){return new Array}update(t){}getQuote({sourceMint:t,amount:e}){return{notEnoughLiquidity:!1,inAmount:e,outAmount:this.wrappedToken.getOutputAmount(e,t),feeAmount:M,feeMint:t.toBase58(),feePct:0,priceImpactPct:0}}getSwapLegAndAccounts(t){return function({addDecimals:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,deposit:s}){return[ln(s?{saberAddDecimalsDeposit:{}}:{saberAddDecimalsWithdraw:{}}),fn.instruction.saberAddDecimals({accounts:{addDecimalsProgram:ke,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:o,userUnderlyingTokens:s?n:i,userWrappedTokens:s?i:n,tokenProgram:e}}).keys]}({addDecimals:this.wrappedToken.addDecimals,...t,deposit:this.wrappedToken.addDecimals.underlying.equals(t.sourceMint)})}get reserveTokenMints(){return[this.wrappedToken.addDecimals.underlying,this.wrappedToken.addDecimals.mint]}}class yi{constructor(t){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenAccounts=[],this.calculator=void 0,this.stableSwap=t,this.id=t.config.swapAccount.toBase58(),this.calculator=new v(B,f(this.stableSwap.state),[b,b],new A(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(t){let e=oe(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=F(t.data);if(!e)throw new Error("Invalid token account data");return e}))}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const i=new Y(this.stableSwap.state.fees.trade.asFraction.toFixed(4)),[o,s]=this.tokenAccounts[0].mint.equals(t)?[0,1]:[1,0];this.calculator.setAmp(f(this.stableSwap.state));const r=this.calculator.exchange(se(this.tokenAccounts),n,o,s);return{notEnoughLiquidity:!1,inAmount:n,outAmount:r.expectedOutputAmount,feeAmount:r.fees,feeMint:e.toBase58(),feePct:i.toNumber(),priceImpactPct:r.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({stableSwap:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[ln({saber:{}}),fn.instruction.saberSwap({accounts:Tn(t,e,n,i,o)}).keys]}({stableSwap:this.stableSwap,...t})}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const Mi=W([K(8,"discriminator"),Ye("factory"),Q("bump"),Je("index"),Ye("admin"),Ye("token0Reserves"),Ye("token0Mint"),Ye("token0Fees"),Ye("token1Reserves"),Ye("token1Mint"),Ye("token1Fees"),Q("isPaused"),Ye("poolMint"),Je("tradeFeeKbps"),Je("withdrawFeeKbps"),Je("adminTradeFeeKbps"),Je("adminWithdrawFeeKbps")]);class Ti{constructor(t,e){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.calculator=void 0,this.tokenAccounts=[],this.id=t.toBase58(),this.poolState=((t,e)=>{const n=e.owner,i=Mi.decode(e.data);return{programId:n,isPaused:Boolean(i.isPaused),bump:i.bump,ammId:t,token0Reserves:i.token0Reserves,token1Reserves:i.token1Reserves,token0Mint:i.token0Mint,token1Mint:i.token1Mint,token0Fees:i.token0Fees,token1Fees:i.token1Fees,poolMint:i.poolMint,tradeFeeKbps:i.tradeFeeKbps.toNumber()}})(t,e),this.calculator=new y(new A(I.BigInt(this.poolState.tradeFeeKbps),I.BigInt(1e7)),new A(M,M),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(t){const e=oe(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=F(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(t)?1:0;let i=this.calculator.exchange(se(this.tokenAccounts),e,n),o=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:e,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:t.toBase58(),feePct:o,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[r,a]=n.equals(t.token0Mint)?[t.token0Reserves,t.token1Reserves]:[t.token1Reserves,t.token0Reserves],[u,c]=n.equals(t.token0Mint)?[t.token0Fees,t.token1Fees]:[t.token1Fees,t.token0Fees];return[ln({sencha:{}}),fn.instruction.senchaSwap({accounts:{swapProgram:t.programId,tokenProgram:e,swap:t.ammId,userAuthority:s,inputUserAccount:i,inputTokenAccount:r,inputFeesAccount:u,outputUserAccount:o,outputTokenAccount:a,outputFeesAccount:c}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}const vi=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"];function*Pi(t){const e=t.isBids;for(const{key:n,quantity:i}of t.slab.items(e)){const t=I.BigInt(n.ushrn(64).toString());yield[t,I.BigInt(i.toString())]}}function Bi(t,e){const n=t._decoded.baseLotSize;return n.isZero()?new Y(0):function(t,e){const n=new Y(t.div(e).toString()),i=t.umod(e),o=i.gcd(e);return n.add(new Y(i.div(o).toString()).div(new Y(e.div(o).toString())))}(e.mul(t._decoded.quoteLotSize).mul(t._baseSplTokenMultiplier),n.mul(t._quoteSplTokenMultiplier))}class bi{constructor(t){this.market=void 0,this.id=void 0,this.label="Serum",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this._orderbooks=void 0,this.market=t,this.id=t.address.toBase58()}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(t){const[e,n]=oe(t,this.getAccountsForUpdate()),i=h.decode(this.market,e.data),o=h.decode(this.market,n.data);this._orderbooks={asks:i,bids:o}}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const i=function({market:t,asks:e,bids:n,fromAmount:i,fromMint:o,toMint:s}){const r=vi.includes(t.address.toBase58())?1e-4:4e-4;return o.equals(t.quoteMintAddress)&&s.equals(t.baseMintAddress)?function(t,e,n,i){let o=M,s=M,r=M,a=M,u=M;const c=t.quoteSizeLotsToNumber(new X(1));let m=c?I.BigInt(new Y(n.toString()).div(1+i).div(c).floor()):M;const p=I.BigInt(t.baseSizeLotsToNumber(new X(1)).toString());for(let[t,n]of Pi(e)){I.equal(s,M)&&(s=t),r=t;const e=I.multiply(n,p),i=I.multiply(n,t);if(u=I.add(u,e),I.greaterThanOrEqual(i,m)){const e=I.divide(m,t);a=I.add(a,I.multiply(t,e)),o=I.add(o,I.multiply(p,e)),m=M;break}a=I.add(a,I.multiply(t,n)),o=I.add(o,e),m=I.subtract(m,i)}const d=new Y(s.toString()),l=new Y(r.toString()).sub(d).div(d).toNumber(),g=Bi(t,new X(s.toString())),h=Bi(t,new X(a.toString())),f=h.mul(p.toString()).ceil(),S=h.mul(p.toString()).mul(i).ceil();return{side:"buy",notEnoughLiquidity:I.lessThanOrEqual(u,o),minimum:{in:I.BigInt(g.mul(p.toString()).mul(1+i).ceil()),out:p},inAmount:I.BigInt(f.add(S)),outAmount:o,feeAmount:I.BigInt(S),priceImpactPct:l,feePct:i}}(t,e,i,r):function(t,e,n,i){let o=I.BigInt(0),s=I.BigInt(0),r=I.BigInt(0),a=I.BigInt(0),u=n,c=I.BigInt(0);const m=I.BigInt(t.baseSizeLotsToNumber(new X(1))),p=I.BigInt(t.quoteSizeLotsToNumber(new X(1)));for(const[t,n]of Pi(e)){I.equal(s,M)&&(s=t),r=t;const e=I.multiply(m,n),i=I.multiply(n,I.multiply(t,p));if(a=I.add(a,e),I.greaterThanOrEqual(e,u)){const e=I.divide(u,m),n=I.multiply(e,t);o=I.add(o,I.multiply(n,p)),u=I.subtract(u,n),c=I.add(c,I.multiply(e,m));break}o=I.add(o,i),u=I.subtract(u,e),c=I.add(c,e)}let d=new Y(o.toString()).mul(1-i).floor();const l=Bi(t,new X(s.toString())),g=Bi(t,new X(r.toString())),h=l.minus(g).div(l).toNumber();return{side:"sell",notEnoughLiquidity:I.greaterThan(I.BigInt(n),a),minimum:{in:m,out:I.BigInt(l.mul(I.toNumber(m)).mul(1-i).floor().toString())},inAmount:c,outAmount:I.BigInt(d),feeAmount:I.BigInt(new Y(o.toString()).mul(i).round()),priceImpactPct:h,feePct:i}}(t,n,i,r)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:t,toMint:e,fromAmount:n});return{notEnoughLiquidity:i.notEnoughLiquidity,minInAmount:i.minimum.in,minOutAmount:i.minimum.out,inAmount:i.inAmount,outAmount:i.outAmount,feeAmount:i.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:i.feePct,priceImpactPct:i.priceImpactPct}}getSwapLegAndAccounts(t){var e;if(!t.openOrdersAddress)throw new Error("Missing open orders");return function({market:t,sourceMint:e,openOrdersAddress:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s,referrer:r}){const{side:a,coinWallet:u,pcWallet:c}=e.equals(t.baseMintAddress)?{side:sn.Ask,coinWallet:i,pcWallet:o}:{side:sn.Bid,coinWallet:o,pcWallet:i};return[ln(rn(a)),fn.instruction.serumSwap({accounts:Mn(t,n,i,u,c,s),remainingAccounts:r?[{pubkey:r,isSigner:!1,isWritable:!0}]:[Sn]}).keys]}({market:this.market,openOrdersAddress:t.openOrdersAddress,referrer:null==t||null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(this.market.quoteMintAddress.toBase58()),...t})}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}bi.getL2=Pi;const Ii=W([Q("version"),Q("isInitialized"),Q("bumpSeed"),Ye("tokenProgramId"),Ye("tokenAccountA"),Ye("tokenAccountB"),Ye("tokenPool"),Ye("mintA"),Ye("mintB"),Ye("feeAccount"),Je("tradeFeeNumerator"),Je("tradeFeeDenominator"),Je("ownerTradeFeeNumerator"),Je("ownerTradeFeeDenominator"),Je("ownerWithdrawFeeNumerator"),Je("ownerWithdrawFeeDenominator"),Je("hostFeeNumerator"),Je("hostFeeDenominator"),Q("curveType"),K(32,"curveParameters")]),Fi=W([Q("version"),Q("isInitialized"),Q("bumpSeed"),Ye("tokenProgramId"),Ye("tokenAccountA"),Ye("tokenAccountB"),Ye("tokenPool"),Ye("mintA"),Ye("mintB"),Ye("feeAccount"),Je("tradeFeeNumerator"),Je("tradeFeeDenominator"),Je("ownerTradeFeeNumerator"),Je("ownerTradeFeeDenominator"),Je("ownerWithdrawFeeNumerator"),Je("ownerWithdrawFeeDenominator"),Q("curveType"),K(32,"curveParameters"),Q("poolNonce")]);var Li;!function(t){t[t.ConstantProduct=0]="ConstantProduct",t[t.Stable=2]="Stable"}(Li||(Li={}));class Di{constructor(t,e,n){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.tokenAccounts=[],this.calculator=void 0,this.label=n,this.id=t.toBase58(),this.tokenSwapState=function(t,e){const n=e.owner,i=n.equals(xe)?Fi.decode(e.data):Ii.decode(e.data);if(!i.isInitialized)throw new Error("Invalid token swap state");const o=$e([t.toBuffer(),Buffer.from([i.bumpSeed])],n),r=new s(i.tokenPool),a=new s(i.feeAccount),u=new s(i.tokenAccountA),c=new s(i.tokenAccountB),m=new s(i.mintA),p=new s(i.mintB);return{address:t,programId:n,tokenProgramId:new s(i.tokenProgramId),poolToken:r,feeAccount:a,authority:o,tokenAccountA:u,tokenAccountB:c,mintA:m,mintB:p,tradeFeeNumerator:i.tradeFeeNumerator,tradeFeeDenominator:i.tradeFeeDenominator,ownerTradeFeeNumerator:i.ownerTradeFeeNumerator,ownerTradeFeeDenominator:i.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:i.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:i.ownerWithdrawFeeDenominator,curveType:i.curveType,curveParameters:i.curveParameters,poolNonce:"poolNonce"in i?i.poolNonce:void 0}}(t,e),this.curveType=this.tokenSwapState.curveType,!(this.curveType in Li))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);this.calculator=this.tokenSwapState.curveType===Li.ConstantProduct?new y(new A(I.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),I.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new A(I.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),I.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()))):new w(I.BigInt(this.tokenSwapState.curveParameters[0]),new A(I.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),I.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new A(I.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),I.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString())))}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(t){const e=oe(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=F(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new Y(this.tokenSwapState.tradeFeeNumerator.toString()).div(this.tokenSwapState.tradeFeeDenominator.toString()).add(new Y(this.tokenSwapState.ownerTradeFeeNumerator.toString()).div(this.tokenSwapState.ownerTradeFeeDenominator.toString()));const i=this.tokenAccounts[0].mint.equals(t)?1:0;let o=this.calculator.exchange(se(this.tokenAccounts),e,i);return{notEnoughLiquidity:!1,inAmount:e,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:t.toBase58(),feePct:n.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({tokenSwapState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s,isStep:r}){const[a,u]=n.equals(t.mintA)?[t.tokenAccountA,t.tokenAccountB]:[t.tokenAccountB,t.tokenAccountA];return[ln(r?{step:{}}:{tokenSwap:{}}),(r?fn.instruction.stepSwap:fn.instruction.tokenSwap)({accounts:{tokenSwapProgram:t.programId,tokenProgram:e,swap:t.address,authority:t.authority,userTransferAuthority:s,source:i,swapSource:a,swapDestination:u,destination:o,poolMint:t.poolToken,poolFee:t.feeAccount}}).keys]}({tokenSwapState:this.tokenSwapState,...t,isStep:this.tokenSwapState.programId.equals(xe)})}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}function qi(t){return t.reduce(((e,n)=>(t.forEach((t=>{n!==t&&e.push([n,t])})),e)),new Array)}const Ei=I.BigInt(100);class xi{constructor(t,e,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.portion1=0,this.portion2=0,this.firstAmm=t,this.secondAmm=e,this.reserveTokenMints=n,this.market=t instanceof bi?t.market:e instanceof bi?e.market:null}static getAmmIdsFromSplitTradeAmmId(t){const e=t.split("-");return e.length>1?e:[]}static create(t,e){if(!function(t,e){return!te(Yt,t.label,e.label)}(t,e))return;const n=qi(t.reserveTokenMints),i=qi(e.reserveTokenMints);for(const o of n)for(const n of i)if(o.every(((t,e)=>t.equals(n[e]))))return new xi(t,e,o)}setPortions(t,e){if(t+e!==100)throw new Error("Split trade portions must sum to 100");this.portion1=t,this.portion2=e}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((t,e)=>e.portion-t.portion)).map((({label:t,portion:e})=>`${t} (${e}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(t){}getQuote(t){const e=t.sourceMint.toBase58(),n=t.amount;let i={outAmount:M,portion:0,firstQuote:void 0,secondQuote:void 0};for(let e=100;e-=5;e>0){const o=I.divide(I.multiply(n,I.BigInt(e)),Ei),s=I.subtract(n,o),r=this.firstAmm.getQuote({...t,amount:o}),a=this.secondAmm.getQuote({...t,amount:s}),u=I.add(r.outAmount,a.outAmount);if(I.lessThan(u,i.outAmount))break;i={outAmount:u,portion:e,firstQuote:r,secondQuote:a}}if(!i.firstQuote||!i.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:o,portion:s,firstQuote:r,secondQuote:a}=i,u=s,c=100-u;this.portion1=u,this.portion2=c;let m={amount:r.feeAmount,mint:r.feeMint},p={amount:a.feeAmount,mint:a.feeMint};m.mint!==p.mint&&(m.mint!==e&&(m={amount:I.divide(I.divide(I.multiply(m.amount,I.multiply(n,I.BigInt(u))),Ei),i.outAmount),mint:e}),p.mint!==e&&(p={amount:I.divide(I.divide(I.multiply(I.multiply(p.amount,n),I.BigInt(c)),Ei),i.outAmount),mint:e}));const d=(u*r.feePct+c*a.feePct)/100,l=(u*r.priceImpactPct+c*a.priceImpactPct)/100;return{notEnoughLiquidity:!1,inAmount:t.amount,outAmount:o,feeAmount:I.add(m.amount,p.amount),feeMint:m.mint,feePct:d,priceImpactPct:l}}getSwapLegAndAccounts(t){let[e,n]=this.firstAmm.getSwapLegAndAccounts(t),[i,o]=this.secondAmm.getSwapLegAndAccounts(t),s=[gn(this.portion1,e),gn(this.portion2,i)],r=[...n,...o];return[dn(s),r]}}function Ci(t,e){const n=Ht(e);if(!n)throw new Error(`Failed to parse whirlpool ${t.toBase58()}`);return n}class Oi{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.hasDynamicAccounts=!0,this.whirlpoolData=void 0,this.tickArrays=new Map,this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.whirlpoolData=Ci(t,e.data),this.oracle=N([Buffer.from("oracle"),t.toBuffer()],Pe)[0],this.feePct=new Y(this.whirlpoolData.feeRate).div(1e6),this.tickPks=Kt(t,this.whirlpoolData)}getAccountsForUpdate(){return[this.address,...this.tickPks]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=Ci(this.address,e.data),this.tickPks=Kt(this.address,this.whirlpoolData),this.tickArrays.clear();for(const e of this.tickPks){const n=e.toBase58(),i=t.get(n);if(!i)continue;const o=Wt(i.data);if(!o)throw new Error(`Could not parse tick array ${n}`);this.tickArrays.set(n,o)}}getQuote({sourceMint:t,destinationMint:e,amount:n,swapMode:i}){const o=Qt({poolAddress:this.address,whirlpool:this.whirlpoolData,tickArrays:this.tickArrays,tokenMint:i===ie.ExactIn?t:e,tokenAmount:new X(n.toString()),isInput:i===ie.ExactIn}),s=I.BigInt(o.amountIn.toString()),r=I.BigInt(o.amountOut.toString()),a=I.BigInt(this.feePct.mul(s.toString()).floor().toString()),u=o.aToB?new Y(o.amountOut.toString()).div(o.amountIn.toString()):new Y(o.amountIn.toString()).div(o.amountOut.toString()),c=(m=this.whirlpoolData.sqrtPrice,new Y(m.toString()).mul(Y.pow(2,-64))).pow(2);var m;const p=c.minus(u).div(c).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:s,outAmount:r,feeAmount:a,feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:Number(p)}}getSwapLegAndAccounts(t){const n=t.sourceMint.equals(this.whirlpoolData.tokenMintA),i=zt(n),[o,s,r]=jt(this.whirlpoolData.tickCurrentIndex,i,this.whirlpoolData.tickSpacing,this.address,this.tickArrays,Pe,n);return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,r]=t.aToB?[n,i]:[i,n];return[ln(cn(t.aToB)),fn.instruction.whirlpoolSwap({accounts:{swapProgram:Pe,tokenProgram:e,tokenAuthority:o,whirlpool:t.whirlpool,tokenOwnerAccountA:s,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:r,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle}}).keys]}({additionalArgs:{aToB:n,whirlpool:this.address,tickArray0:o,tickArray1:s,tickArray2:r,oracle:this.oracle,...this.whirlpoolData},...t})}createExactOutSwapInstruction(t){const n=t.sourceMint.equals(this.whirlpoolData.tokenMintA),i=zt(n),[o,s,r]=jt(this.whirlpoolData.tickCurrentIndex,i,this.whirlpoolData.tickSpacing,this.address,this.tickArrays,Pe,n);return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,outAmount:s,inAmount:r,slippageBps:a,platformFee:u,overflowFeeAccount:c}){var m;const[p,d]=t.aToB?[n,i]:[i,n];return fn.instruction.whirlpoolSwapExactOutput(s,{amount:r,slippageBps:a},t.aToB,null!==(m=null==u?void 0:u.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:Pe,tokenProgram:e,tokenAuthority:o,whirlpool:t.whirlpool,tokenOwnerAccountA:p,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:d,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle},remainingAccounts:vn(null==u?void 0:u.feeAccount,c)})}({additionalArgs:{aToB:n,whirlpool:this.address,tickArray0:o,tickArray1:s,tickArray2:r,oracle:this.oracle,...this.whirlpoolData},...t,outAmount:new X(t.amount.toString()),inAmount:new X(t.inAmount.toString()),slippageBps:t.slippageBps,platformFee:t.platformFee,overflowFeeAccount:t.overflowFeeAccount})}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}const Vi=({amms:t,enforceSingleTx:e})=>{const[n,i]=t;return n.id!==i.id&&!te(e?_t:Yt,n.label,i.label)&&!(n instanceof xi||i instanceof xi)},Ni=new Map([[Ee.toString(),"Orca"],[xe.toString(),"Step"],[Ce.toString(),"Penguin"],[Oe.toString(),"Saros"],[qe.toString(),"Stepn"]]),Ui={};function Ri(t){const e=t._bn.toString(),n=Ui[e];if(n)return n;{const n=t.toBase58();return Ui[e]=n,n}}function Ki(t,e,n){return Boolean(t&&e>100&&!t.includes(n))}function Wi(t,e){if(t===ie.ExactOut)return!1;if(e.length>1){const[t,n]=e;if(t instanceof fi&&n instanceof fi)return!1}return!0}function Qi(t){return t.marketInfos.map((t=>`${t.amm.id}-${t.inputMint}`)).join("-")}const zi=()=>({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]}),ji=t=>m.setComputeUnitLimit({units:Math.min(t,14e5)});async function Hi({connection:t,amount:n,owner:{publicKey:s}}){const r={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},u=await o.getAssociatedTokenAddress(i,e,ue,s,!0);return null===await t.getAccountInfo(u)&&r.setupInstructions.push(Xi(s,u,s,ue)),r.setupInstructions.push(a.transfer({fromPubkey:s,toPubkey:u,lamports:I.toNumber(n)})),r.setupInstructions.push(o.createSyncNativeInstruction(e,u)),r.cleanupInstructions=[o.createCloseAccountInstruction(e,u,s,s,[])],{address:u,...r}}function Xi(t,n,o,s,r=e,u=i){return new p({keys:[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:a.programId,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1}],programId:u,data:Buffer.alloc(0)})}async function Gi({connection:t,marketInfos:n,owner:r,unwrapSOL:a}){const u=await Promise.all(n.map((({outputMint:n})=>async function({connection:t,payer:n,owner:{publicKey:r},mintAddress:a,unwrapSOL:u}){const c="string"==typeof a?new s(a):a,m=await o.getAssociatedTokenAddress(i,e,c,r,!0),p={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},d=await t.getAccountInfo(m);if(null===d)p.setupInstructions.push(Xi(n,m,r,c));else{const t=F(d.data);if(t&&!t.owner.equals(r))throw new Error(`/! ATA ${m.toBase58()} is not owned by ${r.toBase58()}`)}return c.equals(ue)&&u&&p.cleanupInstructions.push(o.createCloseAccountInstruction(e,m,r,r,[])),{address:m,...p}}({connection:t,payer:r.publicKey,owner:r,mintAddress:n,unwrapSOL:a})))),[c]=u.splice(u.length-1,1);return{userIntermediaryTokenAccountResults:u,userDestinationTokenAccountResult:c}}async function Yi(t,e,n,i){const o={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},s=n.address.toString();if(i){let e=i.get(s);if(e){let n=null;if(n=await t.getAccountInfo(e,"confirmed"),n)return{...o,address:e}}}const[r,c]=function(t,e){const[n]=N([Buffer.from("open_orders"),t.publicKey.toBuffer(),e.toBuffer()],hn);return[n,fn.instruction.createOpenOrders({accounts:{openOrders:n,payer:e,dexProgram:t.programId,systemProgram:a.programId,rent:u,market:t.publicKey}})]}(n,e);return await t.getAccountInfo(r)||(o.setupInstructions=[c]),null==i||i.set(n.address.toString(),r),{...o,address:r}}function Zi(t){return t.reduce(((t,e)=>e+t),0)}const Ji={feeBps:0,feeAccounts:new Map};async function _i(t,n){return(await t.getTokenAccountsByOwner(n,{programId:e})).value.reduce(((t,e)=>{const n=F(e.account.data);return n&&t.set(n.mint.toBase58(),e.pubkey),t}),new Map)}class $i{constructor(t,e,n){this.connection=void 0,this.feePayer=void 0,this.instructions=void 0,this.owner=void 0,this.connection=t,this.feePayer=e,this.instructions=[],this.owner=n}addInstruction(t){return this.instructions.push(t),this}async build(t){t||(t=await this.connection.getLatestBlockhash("confirmed"));const e={...t,feePayer:this.feePayer};let n=[],i=[],o=[],s=[];this.instructions.forEach((t=>{i=i.concat(t.setupInstructions),n=n.concat(t.instructions),o=o.concat(t.cleanupInstructions),s=s.concat(t.signers)}));const r=new d(e);return i.concat(n).concat(o).forEach((t=>r.add(t))),r.feePayer=this.feePayer,{transaction:r,signers:s,execute:this.owner.isKeyPair?()=>this.connection.sendTransaction(r,s):async()=>{throw new Error("Please use a Keypair for the owner parameter to enable the execute function")}}}}class to{constructor(t){this._owner=void 0,this._owner=t}get publicKey(){return to.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return to.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return to.isKeyPair(this._owner)}get isPublicKey(){return to.isPublicKey(this._owner)}static isKeyPair(t){return void 0!==t.secretKey}static isPublicKey(t){return!to.isKeyPair(t)}}const eo=t=>new Promise((e=>setTimeout(e,t)));function no(t,e,n){if(t)return function(t,e){var n,i,o,s;const r=null===(n=e.postTokenBalances)||void 0===n||null===(i=n.find((e=>e.accountIndex===t)))||void 0===i?void 0:i.uiTokenAmount.amount,a=null===(o=e.preTokenBalances)||void 0===o||null===(s=o.find((e=>e.accountIndex===t)))||void 0===s?void 0:s.uiTokenAmount.amount;if(r)return Math.abs(parseInt(r)-(void 0!==a?parseInt(a):0))}(e.message.accountKeys.findIndex((t=>t.equals(n))),t)}function io(t,e,n){let i=e.message.accountKeys.findIndex((t=>t.equals(n)));return-1!==i?Math.abs(t.postBalances[i]-t.preBalances[i]):0}function oo(){return(new Date).getTime()}const so={skipPreflight:!0,maxRetries:2};async function ro(t,e,n=12e4,i=500,o=2e3,s=40){const r=e.serialize(),a=await t.sendRawTransaction(r,so),u=oo();let c=oo(),m=0;for(;oo()-u<n;){const e=oo();m<s&&e-c>o&&(c=e,m+=1,await t.sendRawTransaction(r,so));const n=await Promise.any([t.getTransaction(a,{commitment:"confirmed"}),eo(5e3)]);if(n)return{txid:a,transactionResponse:n};await eo(i)}return{txid:a,transactionResponse:null}}function ao(t){const e=t.signature;if(!e)throw new Error("Transaction has no signature");return Gt.encode(e)}const uo=function(t){if(!Array.isArray(t))throw new TypeError(`Argument must be an array: ${t}`)},co=function(t,e){return t*e.length},mo={},po=function(t,e){return String(e)},lo=I.BigInt(1e4);function go({inputMint:t,outputMint:e}){return`${t}-${e}`}function ho({ammId:t,amount:e}){return`${t}-${e.toString()}`}function fo({inputRouteSegment:t,inputMint:e,outputMint:n,amount:i,getDepositAndFeeForRoute:o,platformFeeBps:r,slippageBps:a,filterTopNResult:u=2,onlyDirectRoutes:c,swapMode:m,enforceSingleTx:p}){const d=e.toBase58(),l=n.toBase58();if(!t.get(d))throw new Error("No routes found for the input and output mints");const g=c?0:2,h=new Map,f=[],S=new Map;return function e({inputMint:n,amount:i,level:o=0,walked:r=[n]}){const a=t.get(n);a&&a.forEach(((d,k)=>{const w=go({inputMint:n,outputMint:k}),A=function({amms:t,inputMint:e,outputMint:n,amount:i,swapMode:o}){return t.map((t=>{try{return{quote:t.getQuote({amount:i,sourceMint:new s(e),destinationMint:new s(n),swapMode:o}),amm:t}}catch(t){return}})).filter(Boolean).sort(((t,e)=>I.greaterThanOrEqual((null==e?void 0:e.quote.outAmount)||M,(null==t?void 0:t.quote.outAmount)||M)?1:-1))}({amms:d,inputMint:n,outputMint:k,amount:i,swapMode:m}),{filteredAmms:y,quoteMap:T}=A.reduce(((t,e,n)=>(n<u&&t.filteredAmms.push(e.amm),t.quoteMap.set(ho({ammId:e.amm.id,amount:i}),e.quote),t)),{filteredAmms:[],quoteMap:new Map}),v=[];if(k!==l||c||function(t,e){for(let n=0;n<t.length;n++)for(let i=n+1;i<t.length;i++)t[n].label!==t[i].label&&e(t[n],t[i])}(y.slice(),((t,e)=>{const n=(()=>{if(!p||!1!==Vi({amms:[t,e],enforceSingleTx:p}))return xi.create(t,e)})();n&&v.push(n)})),a.set(k,y.concat(v)),h.set(w,T),k!==l&&T.size&&!r.includes(k)&&o<g-1){var P;const t=T.values().next().value.outAmount,n=null!==(P=S.get(k))&&void 0!==P?P:M;I.greaterThan(t,n)&&(S.set(k,t),e({inputMint:k,amount:t,level:o+1,walked:r.concat(k)}))}else if(k===l){0===o&&a.set(k,A.map((t=>t.amm)).concat(v));const e=r.concat(k),n=e.map((t=>new s(t))),i=e.reduce(((n,i,o)=>{var s;return o<e.length-1&&n.push(null===(s=t.get(e[o]))||void 0===s?void 0:s.get(e[o+1])),n}),[]),u=function(t){if(function(t){if(!Array.isArray(t))throw new TypeError("Argument must be an array of arrays");t.forEach(uo),function({length:t}){if(t>=100)throw new TypeError(`Too many arrays (${t}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)}(t),function(t){const e=t.reduce(co,1);if(e>=4294967296){const t=Number.isFinite(e)?` (${e.toExponential(0)})`:"";throw new TypeError(`Too many combinations${t}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}}(t)}(t),0===t.length)return[];const e=[];return function(t){const e=mo[t];if(void 0!==e)return e;const n=function(t){const e=Array.from({length:t},po),n=e.map((t=>`for (const value${t} of arrays[${t}]) {`)).join("\n"),i=e.map((t=>`value${t}`)).join(", "),o="}\n".repeat(t);return new Function("arrays","result",`${n}\nresult.push([${i}])\n${o}`)}(t);return mo[t]=n,n}(t.length)(t,e),e}(i);for(let t of u)(1===t.length||Vi({amms:t,enforceSingleTx:p}))&&f.push({amms:t,mints:n})}}))}({inputMint:d,amount:i}),f.map((t=>{const{amms:e,mints:n}=t;let s=[],u=i,c=M;const p=Wi(m,e),d=n,l=e.length;for(const[t,n]of e.entries())try{var g;const e=d[t],o=d[t+1],f=go({inputMint:e.toBase58(),outputMint:o.toBase58()}),S=null===(g=h.get(f))||void 0===g?void 0:g.get(ho({ammId:n.id,amount:u}));if(I.equal(u,M))return;const k=S||n.getQuote({sourceMint:e,destinationMint:o,amount:u,swapMode:m}),w=l-1===t&&p?{amount:I.divide(I.multiply(k.outAmount,I.BigInt(r)),lo),mint:o.toBase58(),pct:r/100}:{amount:M,mint:o.toBase58(),pct:0},A=m===ie.ExactIn?k.outAmount:k.inAmount;let y=m===ie.ExactIn?I.subtract(A,w.amount):I.add(A,w.amount);I.lessThan(y,M)&&(y=M);const T=I.BigInt(m===ie.ExactIn?new Y(y.toString()).mul(1-a/I.toNumber(lo)).ceil():new Y(y.toString()).mul(1+a/I.toNumber(lo)).floor()),[v,P]=m===ie.ExactIn?[k.inAmount,y]:[y,u];s.push({amm:n,inputMint:e,outputMint:o,notEnoughLiquidity:k.notEnoughLiquidity,minInAmount:k.minInAmount,minOutAmount:k.minOutAmount,inAmount:v,outAmount:P,priceImpactPct:k.priceImpactPct,lpFee:{amount:k.feeAmount,mint:k.feeMint,pct:k.feePct},platformFee:w}),u=m===ie.ExactIn?y:i,c=T}catch(t){return}return{marketInfos:s,getDepositAndFee:()=>o({marketInfos:s}),inAmount:s[0].inAmount,outAmount:u,amount:i,otherAmountThreshold:c,swapMode:m,slippageBps:a,priceImpactPct:1-s.reduce(((t,e)=>t*(1-e.priceImpactPct)),1)}})).filter((t=>void 0!==t)).sort(((t,e)=>I.greaterThanOrEqual(e.outAmount,t.outAmount)?1:-1))}const So=Object.values(ze).reduce(((t,e)=>(t[e.code]=e,t)),{});async function ko({txid:t,transactionResponse:e}){var n;if(!e)return new L("Transaction was not confirmed",t);if(null!=e&&null!==(n=e.meta)&&void 0!==n&&n.err){let{message:n,programId:o,code:s}=D(e);var i;return o===hn.toBase58()&&s&&(n=null===(i=So[s])||void 0===i?void 0:i.msg),n||(n=q),new L(n||"",t,s)}return e}function wo(t,e){let n=e.get(t);return void 0===n&&(n=e.size,e.set(t,n)),n}function Ao(t){const{mintToIndexMap:e,indexedRouteMap:n}=Array.from(t).reduce((({mintToIndexMap:t,indexedRouteMap:e},[n,i])=>{const o=wo(n,t),s=[];for(const e of i){const n=wo(e,t);s.push(n)}return e[o]=s,{mintToIndexMap:t,indexedRouteMap:e}}),{mintToIndexMap:new Map,indexedRouteMap:{}});return{mintKeys:[...e.keys()],indexedRouteMap:n}}function yo(t){const e=e=>t.mintKeys[e],n=new Map;return Object.keys(t.indexedRouteMap).forEach((i=>{n.set(e(i),t.indexedRouteMap[i].map((t=>e(t))))})),n}class Mo{constructor(t,n,s,r,a,u,c=0,m=!0,p,d){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.getDepositAndFees=async({marketInfos:t,userPublicKey:e,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>(async({connection:t,owner:e,inputMint:n,marketInfos:i,feeCalculator:o,serumOpenOrdersPromise:s,wrapUnwrapSOL:r})=>{const a=n.equals(ue)&&r,u=await Promise.all(i.map((async n=>{const i=n.amm;if(i instanceof bi||i instanceof xi){if(!i.market)return;return await Yi(t,e.publicKey,i.market,await s)}}))),{userIntermediaryTokenAccountResults:c,userDestinationTokenAccountResult:m}=await Gi({connection:t,marketInfos:i,owner:e,unwrapSOL:r});return(({intermediates:t,destination:e,openOrders:n,hasWrapUnwrapSOL:i,feeCalculator:o})=>{const s=n.filter((t=>t&&t.instructions.length>0)).map((()=>23352760)),r=[...t,e].filter((t=>(null==t?void 0:t.instructions.length)&&0===t.cleanupInstructions.length)).map((()=>2039280)),a=([...null==n?void 0:n.map((t=>null==t?void 0:t.signers)),...null==t?void 0:t.map((t=>t.signers)),e.signers].flat().length+1)*o.lamportsPerSignature;return{signatureFee:a,openOrdersDeposits:s,ataDeposits:r,totalFeeAndDeposits:Zi([a,...s,...r]),minimumSOLForTransaction:Zi([a,...s,...r,i?2039280:0])}})({intermediates:c,destination:m,openOrders:u,hasWrapUnwrapSOL:a,feeCalculator:o})})({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:t[0].inputMint,marketInfos:t,serumOpenOrdersPromise:n,owner:new to(e),wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:t})=>{if(this.user&&this.serumOpenOrdersPromise){const e=new to(this.user);return this.getDepositAndFees({marketInfos:t,userPublicKey:e.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:t,userPublicKey:n,feeAccount:s,wrapUnwrapSOL:r,blockhashWithExpiryBlockHeight:a})=>{var u;const{connection:c,serumOpenOrdersPromise:m}=this,p=n||this.user;if(!p)throw new Error("user not found");const d=new to(p),l=t.marketInfos.length-1,g=t.marketInfos[0].inputMint,h=t.marketInfos[l].outputMint,f=null!=r?r:this.wrapUnwrapSOL,[S,k,w]=await Promise.all([g.equals(ue)&&f?Hi({connection:c,owner:d,amount:t.swapMode===ie.ExactIn?t.amount:t.otherAmountThreshold}):o.getAssociatedTokenAddress(i,e,g,d.publicKey,!0).then((t=>({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[],address:t}))),Gi({connection:c,marketInfos:t.marketInfos,owner:d,unwrapSOL:f}),Promise.all(t.marketInfos.map((async({amm:t})=>{if(t instanceof bi||t instanceof xi){if(!t.market)return;return await Yi(c,d.publicKey,t.market,await m)}})))]),A={intermediates:k.userIntermediaryTokenAccountResults,destination:k.userDestinationTokenAccountResult,openOrders:w},y=A.openOrders.filter(Boolean).length>0,M=(s=null!==(u=s)&&void 0!==u?u:this.platformFeeAndAccounts.feeAccounts.get(t.swapMode===ie.ExactIn?h.toBase58():g.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*t.marketInfos[l].platformFee.pct),feeAccount:s}:void 0,T=await async function({user:t,openOrdersAddresses:e,userSourceTokenAccountAddress:n,userIntermediateTokenAccountAddresses:i,userDestinationTokenAccountAddress:o,routeInfo:s,platformFee:r,quoteMintToReferrer:a}){if(s.marketInfos.length-1!==i.length)throw new Error("Missing intermediary token account address");const u=r&&function(t){if(t.length<2)return!1;const[e,n]=t.map((t=>t.amm));return e instanceof fi&&n instanceof bi||e instanceof bi&&n instanceof fi}(s.marketInfos)?void 0:a,c=[n,...i,o],m=!!r&&r.feeBps>0&&Wi(s.swapMode,s.marketInfos.map((t=>t.amm))),p=t.publicKey,d=[],l=[];if(s.swapMode===ie.ExactIn){const{requireComputeBudget:t,swapInstruction:n}=function(t,e,n,i,o,s,r,a){let u=!1;const c=[],m=[];for(const[e,i]of t.marketInfos.entries()){const a=i.amm,[p,d]=o.slice(e),[l,g]=a.getSwapLegAndAccounts({sourceMint:i.inputMint,destinationMint:i.outputMint,userSourceTokenAccount:p,userDestinationTokenAccount:d,userTransferAuthority:n,openOrdersAddress:s[e],quoteMintToReferrer:r,swapMode:t.swapMode,amount:t.amount});c.push(l),m.push(...g),!1===u&&(u=i.amm instanceof xi?te(Jt,i.amm.firstAmm.label,i.amm.secondAmm.label):te(Jt,i.amm.label))}return e&&a&&m.push({pubkey:a.feeAccount,isWritable:!0,isSigner:!1}),{requireComputeBudget:u,swapInstruction:kn(n,i,pn(c),m,new G(t.amount.toString()),new G(t.outAmount.toString()),t.slippageBps,e&&a?a.feeBps:0)}}(s,m,p,o,c,e,u,r);t&&d.push(ji(14e5)),l.push(n)}else if(s.swapMode===ie.ExactOut){const{requireComputeBudget:t,swapInstruction:e}=function(t,e,n,i,o,s){const r=t.marketInfos[0],a=r.amm;if(a.createExactOutSwapInstruction)return{requireComputeBudget:!1,swapInstruction:a.createExactOutSwapInstruction({sourceMint:r.inputMint,destinationMint:r.outputMint,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:e,quoteMintToReferrer:o,swapMode:t.swapMode,amount:t.amount,slippageBps:t.slippageBps,inAmount:t.inAmount,platformFee:s,overflowFeeAccount:null==o?void 0:o.get(r.inputMint.toBase58())})};throw new Error(`ExactOutInstruction missing for ${a.label}.`)}(s,p,n,o,u,r);t&&d.push(ji(14e5)),l.push(e)}const{signers:g,cleanupInstructions:h}={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]};return t.isKeyPair&&t.signer&&g.push(t.signer),{setupInstructions:d,signers:g,cleanupInstructions:h,instructions:l}}({user:d,openOrdersAddresses:A.openOrders.map((t=>null==t?void 0:t.address)),userSourceTokenAccountAddress:S.address,userIntermediateTokenAccountAddresses:A.intermediates.map((({address:t})=>t)),userDestinationTokenAccountAddress:A.destination.address,routeInfo:t,platformFee:M,quoteMintToReferrer:this.quoteMintToReferrer}),v=function(t,{hasSerumOpenOrderInstruction:e}){let n,i;if(1===t.length){const e=t[0].amm;if(!(e instanceof xi))return!1;n=e.firstAmm,i=e.secondAmm}else[n,i]=t.map((t=>t.amm));return!!e||!!te(Zt,n.label,i.label)}(t.marketInfos,{hasSerumOpenOrderInstruction:y}),P=new $i(c,d.publicKey,d),B=new $i(c,d.publicKey,d),b=new $i(c,d.publicKey,d),I=[...A.intermediates,S,!A.destination.address.equals(S.address)&&A.destination];B.addInstruction(T),v?(y&&A.openOrders.forEach((t=>{t&&P.addInstruction(t)})),I.forEach((t=>{t&&(P.addInstruction({...t,cleanupInstructions:[]}),t.cleanupInstructions.length)&&b.addInstruction({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[],cleanupInstructions:t.cleanupInstructions})}))):(y&&A.openOrders.forEach((t=>{t&&B.addInstruction(t)})),I.forEach((t=>{t&&B.addInstruction(t)}))),a=a||await this.connection.getLatestBlockhash("confirmed");const{transaction:F}=await P.build(a),{transaction:L}=await B.build(a),{transaction:D}=await b.build(a),[q,E,x]=[F.instructions.length?F:void 0,L,D.instructions.length?D:void 0],C=A;return{transactions:{setupTransaction:q,swapTransaction:E,cleanupTransaction:x},execute:({wallet:t,onTransaction:e}={})=>this.executeInternal({wallet:t,onTransaction:e,inputMint:g,outputMint:h,sourceInstruction:S,setupInstructions:C,setupTransaction:q,swapTransaction:E,cleanupTransaction:x,wrapUnwrapSOL:f,owner:d})}},this.connection=t,this.cluster=n,this.tokenRouteSegments=s,this.feeCalculator=r,this.platformFeeAndAccounts=a,this.quoteMintToReferrer=u,this.routeCacheDuration=c,this.wrapUnwrapSOL=m,this.intermediateTokens=p,this.shouldLoadSerumOpenOrders=d}static async load({connection:t,cluster:e,user:n,platformFeeAndAccounts:i=Ji,quoteMintToReferrer:o,routeCacheDuration:r=0,wrapUnwrapSOL:a=!0,marketUrl:u,restrictIntermediateTokens:c=!1,shouldLoadSerumOpenOrders:m=!0}){const[p,{value:{feeCalculator:d}},l,g]=await Promise.all([Mo.fetchTokenRouteSegments(t,e,u),t.getRecentBlockhashAndContext("processed"),null!=o?o:_i(t,new s(Te)),c?Mo.getIntermediateTokens():void 0]),h=new Mo(t,e,p,d,i,l,r,a,g,m);return n&&h.setUserPublicKey(n),h}getAccountToAmmIdsMap(){const t=new Map;return this.tokenRouteSegments.forEach((e=>{Array.from(e.values()).forEach((e=>{e.forEach((e=>{e.getAccountsForUpdate().forEach((n=>{const i=t.get(n.toBase58())||new Set;i.add(e.id),t.set(n.toBase58(),i)}))}))}))})),t}getAmmIdToAmmMap(){const t=new Map;return this.tokenRouteSegments.forEach((e=>{Array.from(e.values()).forEach((e=>{e.forEach((e=>{t.set(e.id,e)}))}))})),t}async computeRoutes({inputMint:t,outputMint:e,amount:n,slippageBps:i,feeBps:o=0,forceFetch:s,onlyDirectRoutes:r,swapMode:a=ie.ExactIn,filterTopNResult:u,enforceSingleTx:c}){const m=t.toBase58(),p=e.toBase58(),d=o||(this.platformFeeAndAccounts.feeAccounts.get(p)?this.platformFeeAndAccounts.feeBps:0),l=(new Date).getTime(),g=[m,p].sort(((t,e)=>t.localeCompare(e))).join(""),h=this.routeCache.get(g),f=function({inputMint:t,outputMint:e,tokenRouteSegments:n,swapMode:i,intermediateTokens:o,onlyDirectRoutes:s}){const r=new Map,a=n.get(t),u=n.get(e);if(a&&u){const n=Math.min(a.size,u.size),c=a.size<u.size,m=new Map,p=new Map;let[d,l,g,h]=c?[a,u,t,e]:[u,a,e,t];for(let[t,e]of d.entries()){let a=i===ie.ExactIn?e:e.filter((t=>t.exactOutputSupported));if(t===h){m.set(t,a),p.set(g,a);continue}if(s||i===ie.ExactOut||Ki(o,n,t))continue;const u=l.get(t);if(u){let e=i===ie.ExactIn?u:u.filter((t=>t.exactOutputSupported));r.set(t,new Map([[g,a],[h,e]])),m.set(t,a),p.set(t,e)}}r.set(g,m),r.set(h,p)}return r}({inputMint:m,outputMint:p,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens,onlyDirectRoutes:r,swapMode:a});let S=!1;if(-1===this.routeCacheDuration)S=!1;else if(0===this.routeCacheDuration)S=!0;else if(h){const{fetchTimestamp:t}=h;l-t>this.routeCacheDuration&&(S=!0)}else S=!0;(s||S)&&(await async function(t,e){const n=new Map,i=new Set,o=new Map;e.forEach((t=>{t.forEach((t=>{t.forEach((t=>{o.set(t.id,t),t.getAccountsForUpdate().forEach((t=>{i.add(t.toBase58())}))}))}))}));const s=Array.from(i);s.length>0&&((await ne(t,s)).forEach(((t,e)=>{t&&n.set(s[e],t)})),o.forEach((t=>{t.update(n)})))}(this.connection,f),this.routeCache.set(g,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:fo({inputRouteSegment:f,inputMint:t,outputMint:e,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:r,slippageBps:i,platformFeeBps:d,filterTopNResult:u,swapMode:a,enforceSingleTx:c}),cached:!(s||S)}}catch(t){throw t}finally{this.routeCache.forEach((({fetchTimestamp:t},e)=>{t-l>this.routeCacheDuration&&this.routeCache.delete(e)}))}}setUserPublicKey(t){this.user=t;const e=new to(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?Mo.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:e.publicKey}):Promise.resolve(new Map)}static async fetchTokenRouteSegments(t,e,n){const i=await(async t=>await(await Xt(t)).json())(n||pe[e]);return function(t){const e=new Map;return t.forEach((t=>{qi(t.reserveTokenMints).forEach((([n,i])=>{!function(t,e,n,i){let o=i.get(t);o||(o=new Map([[e,[]]]),i.set(t,o));let s=o.get(e);s||(s=[],o.set(e,s)),s.push(n)}(Ri(n),Ri(i),t,e)}))})),e}(await async function(t,e){const n=(t=>t.map((t=>{const{data:[e,n],pubkey:i,...o}=t;return{...o,pubkey:new s(i),data:Buffer.from(e,n),owner:new s(o.owner)}})))(e),i=[];if(i.length){const e=await async function(t,e){return await Promise.all((await ne(t,e.map((t=>t.toBase58())))).map((async(t,n)=>{const i=e[n];if(!t)throw new Error(`Failed to fetch pool ${i.toBase58()}`);return{pubkey:i,...t}})))}(t,i);n.push(...e)}const o=[],r=n.reduce(((t,e)=>{const n=function(t,e,n){const i=new s(e.owner);if(i.equals(ce)||i.equals(me)){const t=l.getLayout(i).decode(e.data);if(!t.accountFlags.initialized||!t.accountFlags.market)throw new Error("Invalid market");const n=new l(t,0,0,{},i);return new bi(n)}if(i.equals(he)){const i=new fi(t,e,n);if(1===i.status)return i}else{if(i.equals(ve))return new ci(t,e,n);if(i.equals(S)){const n=e.data.slice(2,3),i=k.loadWithData(t,e.data,$e([t.toBuffer(),n],S));if(i.state.isPaused||!i.state.isInitialized)return;return new yi(i)}if(i.equals(Me))return new Cn(t,e);if(i.equals(fe)||i.equals(Se))return new En(t,e,n);if([...Ni.keys()].includes(i.toBase58())){var o;const n=null!==(o=Ni.get(e.owner.toBase58()))&&void 0!==o?o:"Unknown";return new Di(t,e,n)}if(i.equals(we))return new On(t,e,n);if(i.equals(Ae)){const n=new Ti(t,e);if(n.isPaused)return;return n}if(i.equals(ye))return new Zn(t,e);if(i.equals(Pe))return new Oi(t,e);if(i.equals(Fe))return new Rn(t,e);if(i.equals(De))return new ii(t,e);if(i.equals(Ve))return new gi(t,e,n);if(i.equals(Ke))return new Hn(t,e);if(i.equals(Be))return new Yn(t,e)}}(e.pubkey,e,e.params);return n&&(t.push(n),n.shouldPrefetch&&o.push(n)),t}),new Array);return await Promise.all([re(o,t),Mt()]),r.push(...ki()),r}(t,i))}getRouteMap(t){return function(t,e,n,i){const o=new Map;for(const[i,u]of t){const c=new Set;for(const[o,m]of u){var s;if(c.add(o),n)continue;const p=null!==(s=t.get(o))&&void 0!==s?s:new Map;for(const[n,s]of p){var r,a;if(n===i)continue;const p=null!==(r=null===(a=t.get(n))||void 0===a?void 0:a.size)&&void 0!==r?r:0;if(Ki(e,Math.min(u.size,p),o))continue;let d=!1;for(const t of m){for(const e of s)if(Vi({amms:[t,e],enforceSingleTx:void 0})){c.add(n),d=!0;break}if(d)break}}}o.set(i,Array.from(c))}return o}(this.tokenRouteSegments,this.intermediateTokens,t)}static async getRemoteRouteMap({onlyDirectRoutes:t,restrictIntermediateTokens:e},n){let i=n||"https://cache.jup.ag/indexed-route-map";return t?i=i.concat("?onlyDirectRoutes=true"):e&&(i=i.concat("?restrictIntermediateTokens=true")),yo(await(await Xt(i)).json())}async executeInternal({wallet:t,onTransaction:e,inputMint:n,outputMint:i,sourceInstruction:o,setupInstructions:s,setupTransaction:r,swapTransaction:a,cleanupTransaction:u,owner:c,wrapUnwrapSOL:m}){let p,d;try{const l=[r,a,u].filter((t=>void 0!==t)),g=l.length;if(c.signer){const t=c.signer;l.forEach((e=>{e.sign(t)}))}else{if(!t)throw new Error("Signer wallet not found");if(g>1){const e=await t.signAllTransactions(l);let n=0;[r,a,u]=[r?e[n++]:void 0,e[n++],u?e[n++]:void 0]}else a=await t.signTransaction(a)}if(r){let t=ao(r);const n=(async()=>await ko(await ro(this.connection,r)))();if(null==e||e(t,g,"SETUP",n),await n instanceof Error)throw d}const h=ao(a);try{const t=(async()=>await ko(await ro(this.connection,a)))();null==e||e(h,g,"SWAP",t);const r=await t;if(r instanceof Error)throw r;const[p,l]=function({txid:t,inputMint:e,outputMint:n,user:i,sourceAddress:o,destinationAddress:s,transactionResponse:r,hasWrappedSOL:a}){let u,c;if(r){let{meta:t,transaction:m}=r;t&&(u=e.equals(ue)&&!a?io(t,m,i):no(t,m,o),c=n.equals(ue)&&!a?io(t,m,i):no(t,m,s))}if(!u||!c)throw new L("Cannot find source or destination token account balance change",t,ze.BalancesNotExtractedProperly.code);return[u,c]}({txid:h,inputMint:n,outputMint:i,user:c.publicKey,sourceAddress:o.address,destinationAddress:s.destination.address,transactionResponse:r,hasWrappedSOL:Boolean(u)||!m});d={txid:h,inputAddress:o.address,outputAddress:s.destination.address,inputAmount:p,outputAmount:l}}catch(t){p=t}finally{if(u){const t=ao(u),n=(async()=>ko(await ro(this.connection,u)))();null==e||e(t,g,"CLEANUP",n),await n}}if(p||!d)throw p||new Error("Swap failed");return d}catch(t){return{error:t}}finally{this.routeCache.clear()}}static async getIntermediateTokens(){const t=await async function(){const t=await(await Xt("https://cache.jup.ag/top-tokens")).json();return new Set(t.filter(((t,e)=>e<60)))}();for(const e of Qe)t.add(e);return ki().forEach((e=>{t.add(e.wrappedToken.addDecimals.mint.toBase58())})),Array.from(t)}}Mo.findSerumOpenOrdersForOwner=async({userPublicKey:t,cluster:e,connection:n})=>{const i=new Map;if(t){const o="mainnet-beta"===e?ce:me;(await g.findForOwner(n,t,o)).forEach((t=>{i.set(t.market.toString(),t.address)}))}return i};export{fe as ALDRIN_SWAP_PROGRAM_ID,Se as ALDRIN_SWAP_V2_PROGRAM_ID,En as AldrinAmm,Me as CREMA_PROGRAM_ID,we as CROPPER_PROGRAM_ID,Le as CYKURA_FACTORY_STATE_ADDRESS,Fe as CYKURA_PROGRAM_ID,Cn as CremaAmm,On as CropperAmm,Rn as CykuraAmm,Ue as DELTA_FI_PROGRAM_ID,Re as DELTA_FI_USER_ID,me as DEVNET_SERUM_DEX_PROGRAM,Qn as DeltaFiAmm,Xe as FAKE_PROVIDER,We as GOOSE_FX_CONTROLLER_ID,Ke as GOOSE_FX_PROGRAM_ID,Hn as GooseFXAmm,de as INDEXED_ROUTE_MAP_URL,Ie as INVARIANT_PROGRAM_AUTHORITY_ID,Be as INVARIANT_PROGRAM_ID,be as INVARIANT_STATE_ID,je as IS_DEV,Yn as InvariantAmm,ze as JUPITER_ERRORS,Te as JUPITER_WALLET,Mo as Jupiter,ge as LAMPORTS_PER_SIGNATURE,ye as LIFINITY_PROGRAM_ID,Zn as LifinityAmm,ce as MAINNET_SERUM_DEX_PROGRAM,De as MARINADE_PROGRAM_ID,pe as MARKETS_URL,ve as MERCURIAL_SWAP_PROGRAM_ID,Ve as METEORA_PROGRAM_ID,Ne as METEORA_VAULT_PROGRAM_ID,He as MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS,ii as MarinadeAmm,ci as MercurialAmm,gi as MeteoraAmm,Ee as ORCA_PROGRAM_ID,Ce as PENGUIN_PROGRAM_ID,he as RAYDIUM_AMM_V4_PROGRAM_ID,fi as RaydiumAmm,ke as SABER_ADD_DECIMALS_PROGRAM_ID,Oe as SAROS_PROGRAM_ID,Ae as SENCHA_PROGRAM_ID,qe as STEPN_PROGRAM_ID,xe as STEP_TOKEN_SWAP_PROGRAM_ID,Qe as SWAP_PROTOCOL_TOKENS,Ai as SaberAddDecimalsAmm,yi as SaberAmm,Ti as SenchaAmm,bi as SerumAmm,Di as SplTokenSwapAmm,xi as SplitTradeAmm,ie as SwapMode,le as TOKEN_LIST_URL,$i as TransactionBuilder,Pe as WHIRLPOOL_PROGRAM_ID,ue as WRAPPED_SOL_MINT,Oi as WhirlpoolAmm,ji as getComputeUnitLimitInstruction,zi as getEmptyInstruction,_i as getPlatformFeeAccounts,Qi as getRouteInfoUniqueId,ki as getSaberWrappedDecimalsAmms,yo as indexedRouteMapToRouteMap,Ao as routeMapToIndexedRouteMap,ro as transactionSenderAndConfirmationWaiter};
//# sourceMappingURL=core.esm.min.js.map
