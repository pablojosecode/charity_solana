"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@solana/spl-token"),t=require("@solana/web3.js"),n=require("@project-serum/serum"),i=require("@saberhq/stableswap-sdk"),o=require("@jup-ag/math"),s=require("jsbi"),a=require("@mercurial-finance/optimist"),r=require("fzstd"),u=require("@project-serum/anchor"),c=require("@project-serum/anchor/dist/cjs/utils/pubkey"),d=require("@solana/buffer-layout"),l=require("@noble/hashes/sha256"),m=require("bn.js"),p=require("decimal.js"),g=require("@jup-ag/crema-sdk"),h=require("@jup-ag/cykura-sdk"),f=require("@jup-ag/cykura-sdk-core"),S=require("@jup-ag/deltafi-sdk"),A=require("@pythnetwork/client"),k=require("bignumber.js"),w=require("@jup-ag/goosefx-ssl-sdk"),y=require("@project-serum/anchor/dist/cjs/utils/token"),M=require("@jup-ag/invariant"),T=require("@jup-ag/lifinity-sdk"),P=require("@mercurial-finance/dynamic-amm-sdk"),v=require("@jup-ag/whirlpool-sdk"),b=require("cross-fetch"),I=require("@project-serum/anchor/dist/cjs/utils/bytes");function B(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function D(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var i=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,i.get?i:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,t}var E=B(s),F=D(r),L=B(m),O=B(p),R=B(b);const q={Serum:{Meteora:!0,GooseFX:!0},Meteora:{Raydium:!0,Serum:!0,GooseFX:!0},Raydium:{Meteora:!0,GooseFX:!0},GooseFX:{Raydium:!0,Serum:!0,Meteora:!0},"Saber (Decimals)":{"Saber (Decimals)":!0}},x={Raydium:{"*":!0},GooseFX:{"*":!0},Meteora:{"*":!0}},N={GooseFX:!0,Meteora:!0,Raydium:!0,Lifinity:!0,Serum:!0,Invariant:!0},C={Raydium:!0,GooseFX:!0,Meteora:!0,Serum:!0},K=(e,t,n)=>{const i=e[t];if(i){if(!0===i||!0===i["*"])return!0;if(n)return!0===i[n]}return!1},U=(e,t,n)=>K(e,t,n)||!!n&&K(e,n,t);function _(e,t){return Array.apply(0,new Array(Math.ceil(e.length/t))).map(((n,i)=>e.slice(i*t,(i+1)*t)))}async function V(e,n,i=1e3,o=100){return(await Promise.all(_(n,i).map((async n=>{const i=_(n,o).map((t=>({methodName:"getMultipleAccounts",args:e._buildArgs([t],e.commitment,"base64+zstd")})));return e._rpcBatchRequest(i).then((e=>e.reduce(((e,n)=>(n.result.value.forEach((n=>{if(n){const i=n;i.data=Buffer.from(F.decompress(Buffer.from(n.data[0],"base64"))),i.owner=new t.PublicKey(n.owner),e.push(i)}else e.push(null)})),e)),[]))).catch((e=>n.map((()=>null))))})))).flat()}var W;exports.SwapMode=void 0,(W=exports.SwapMode||(exports.SwapMode={})).ExactIn="ExactIn",W.ExactOut="ExactOut";const G=(e,t)=>t.map((t=>{const n=e.get(t.toString());if(!n)throw new Error(`Account info ${t.toBase58()} missing`);return n})),Q=e=>e.map((e=>E.default.BigInt(e.amount))),z=async(e,t)=>{const n=e.map((e=>e.getAccountsForUpdate().map((e=>e.toBase58())))).flat(),i=new Map;(await V(t,n)).forEach(((e,t)=>{e&&i.set(n[t],e)}));for(let t of e)t.update(i)},j={version:"0.1.0",name:"jupiter",instructions:[{name:"route",accounts:[{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"destinationTokenAccount",isMut:!1,isSigner:!1}],args:[{name:"swapLeg",type:{defined:"SwapLeg"}},{name:"inAmount",type:"u64"},{name:"quotedOutAmount",type:"u64"},{name:"slippageBps",type:"u16"},{name:"platformFeeBps",type:"u8"}]},{name:"whirlpoolSwapExactOutput",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[{name:"outAmount",type:"u64"},{name:"inAmountWithSlippage",type:{defined:"AmountWithSlippage"}},{name:"aToB",type:"bool"},{name:"platformFeeBps",type:"u8"}]},{name:"createOpenOrders",accounts:[{name:"openOrders",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"market",isMut:!1,isSigner:!1}],args:[]},{name:"mercurialSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"poolAuthority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceTokenAccount",isMut:!0,isSigner:!1},{name:"destinationTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"cykuraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"signer",isMut:!1,isSigner:!0},{name:"factoryState",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"lastObservationState",isMut:!0,isSigner:!1},{name:"coreProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"serumSwap",accounts:[{name:"market",accounts:[{name:"market",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"requestQueue",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"coinVault",isMut:!0,isSigner:!1},{name:"pcVault",isMut:!0,isSigner:!1},{name:"vaultSigner",isMut:!1,isSigner:!1}]},{name:"authority",isMut:!1,isSigner:!0},{name:"orderPayerTokenAccount",isMut:!0,isSigner:!1},{name:"coinWallet",isMut:!0,isSigner:!1},{name:"pcWallet",isMut:!0,isSigner:!1},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"saberSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"saberAddDecimals",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"tokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"senchaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!0,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"inputFeesAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"outputFeesAccount",isMut:!0,isSigner:!1}],args:[]},{name:"stepSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"cropperSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"raydiumSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[]},{name:"cremaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolSourceTokenAccount",isMut:!0,isSigner:!1},{name:"poolDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolTicksAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"lifinitySwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"pythAccount",isMut:!1,isSigner:!1},{name:"pythPcAccount",isMut:!1,isSigner:!1},{name:"configAccount",isMut:!0,isSigner:!1}],args:[]},{name:"marinadeDeposit",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1},{name:"tempWsolTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!0,isSigner:!0},{name:"wsolMint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"marinadeUnstake",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"aldrinSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"aldrinV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"curve",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"whirlpoolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[]},{name:"invariantSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tickmap",isMut:!0,isSigner:!1},{name:"accountX",isMut:!0,isSigner:!1},{name:"accountY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"meteoraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"aVault",isMut:!0,isSigner:!1},{name:"bVault",isMut:!0,isSigner:!1},{name:"aTokenVault",isMut:!0,isSigner:!1},{name:"bTokenVault",isMut:!0,isSigner:!1},{name:"aVaultLpMint",isMut:!0,isSigner:!1},{name:"bVaultLpMint",isMut:!0,isSigner:!1},{name:"aVaultLp",isMut:!0,isSigner:!1},{name:"bVaultLp",isMut:!0,isSigner:!1},{name:"adminTokenFee",isMut:!0,isSigner:!1},{name:"user",isMut:!1,isSigner:!0},{name:"vaultProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"goosefxSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"controller",isMut:!1,isSigner:!1},{name:"pair",isMut:!0,isSigner:!1},{name:"sslIn",isMut:!0,isSigner:!1},{name:"sslOut",isMut:!0,isSigner:!1},{name:"liabilityVaultIn",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultIn",isMut:!0,isSigner:!1},{name:"liabilityVaultOut",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultOut",isMut:!0,isSigner:!1},{name:"userInAta",isMut:!0,isSigner:!1},{name:"userOutAta",isMut:!0,isSigner:!1},{name:"feeCollectorAta",isMut:!0,isSigner:!1},{name:"userWallet",isMut:!1,isSigner:!0},{name:"feeCollector",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"deltafiSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"marketConfig",isMut:!1,isSigner:!1},{name:"swapInfo",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"swapSourceToken",isMut:!0,isSigner:!1},{name:"swapDestinationToken",isMut:!0,isSigner:!1},{name:"deltafiUser",isMut:!0,isSigner:!1},{name:"adminDestinationToken",isMut:!0,isSigner:!1},{name:"pythPriceBase",isMut:!1,isSigner:!1},{name:"pythPriceQuote",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]}],types:[{name:"AmountWithSlippage",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"slippageBps",type:"u16"}]}},{name:"SplitLegDeeper",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegSwap"}}]}},{name:"SplitLeg",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegDeeper"}}]}},{name:"SwapInstrution",type:{kind:"enum",variants:[{name:"Swap",fields:[{defined:"Swap"}]}]}},{name:"Side",type:{kind:"enum",variants:[{name:"Bid"},{name:"Ask"}]}},{name:"SwapLegSwap",type:{kind:"enum",variants:[{name:"PlaceholderOne"},{name:"PlaceholderTwo"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLegDeeper",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegSwap"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLegDeeper"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLeg",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegDeeper"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLeg"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"Swap",type:{kind:"enum",variants:[{name:"Saber"},{name:"SaberAddDecimalsDeposit"},{name:"SaberAddDecimalsWithdraw"},{name:"TokenSwap"},{name:"Sencha"},{name:"Step"},{name:"Cropper"},{name:"Raydium"},{name:"Crema"},{name:"Lifinity"},{name:"Mercurial"},{name:"Cykura"},{name:"Serum",fields:[{name:"side",type:{defined:"Side"}}]},{name:"MarinadeDeposit"},{name:"MarinadeUnstake"},{name:"Aldrin",fields:[{name:"side",type:{defined:"Side"}}]},{name:"AldrinV2",fields:[{name:"side",type:{defined:"Side"}}]},{name:"Whirlpool",fields:[{name:"a_to_b",type:"bool"}]},{name:"Invariant",fields:[{name:"x_to_y",type:"bool"}]},{name:"Meteora"},{name:"GooseFX"},{name:"DeltaFi",fields:[{name:"stable",type:"bool"}]}]}},{name:"SwapAction",type:{kind:"enum",variants:[{name:"SetupSplit",fields:[{name:"percents",type:"bytes"}]},{name:"NextSplitLeg"},{name:"MergeSplit"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}}],errors:[{code:6e3,name:"EmptyRoute",msg:"Empty route"},{code:6001,name:"SlippageToleranceExceeded",msg:"Slippage tolerance exceeded"},{code:6002,name:"InvalidTokenLedger",msg:"Invalid token ledger"},{code:6003,name:"MissingTokenLedger",msg:"Missing token ledger"},{code:6004,name:"MissingMercurialSwapTokenAccount",msg:"Missing mercurial swap token account"},{code:6005,name:"LedgerTokenAccountDoesNotMatch",msg:"Ledger token account does not match"},{code:6006,name:"InvalidCalculation",msg:"Invalid calculation"},{code:6007,name:"MissingPlatformFeeAccount",msg:"Missing platform fee account"},{code:6008,name:"InvalidSlippage",msg:"Invalid slippage"},{code:6009,name:"NotEnoughPercent",msg:"Not enough percent to 100"},{code:6010,name:"InAmountsStackIsEmpty",msg:"In amounts stack is empty"},{code:6011,name:"OutAmountsStackIsEmpty",msg:"Out amounts stack is empty"}]},H=new t.PublicKey("So11111111111111111111111111111111111111112"),X=new t.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Y=new t.PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),Z={devnet:"https://api.jup.ag/api/markets/cache/devnet","mainnet-beta":"https://cache.jup.ag/markets?v=3",testnet:"https://api.jup.ag/api/markets/cache/devnet"},J=new t.PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),$=new t.PublicKey("AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6"),ee=new t.PublicKey("CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4"),te=new t.PublicKey("DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB"),ne=new t.PublicKey("CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh"),ie=new t.PublicKey("SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ"),oe=new t.PublicKey("EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S"),se=new t.PublicKey("6MLxLqiXaaSUpkgMnWDTuejNZEz3kE7k2woyHGVFw319"),ae=new t.PublicKey("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),re=new t.PublicKey("MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky"),ue=new t.PublicKey("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"),ce=new t.PublicKey("HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt"),de=new t.PublicKey("8NsPwRFYqob3FzYvHYTjFK6WVFJADFN8Hn7yNQKcVNW1"),le=new t.PublicKey("J4uBbeoWpZE8fH58PM1Fp9n9K6f1aThyeVCyRdJbaXqt"),me=new t.PublicKey("cysPXAjehMpVKUapzbMCCnpFxUFFryEWEaLgnb9NrR8"),pe=new t.PublicKey("DBsMwKfeoUHhxMi9x6wd2AsT12UwUCssjNbUzu1aKgqj"),ge=new t.PublicKey("MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"),he=new t.PublicKey("Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j"),fe=new t.PublicKey("9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP"),Se=new t.PublicKey("SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1"),Ae=new t.PublicKey("PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP"),ke=new t.PublicKey("SSwapUtytfBdBn1b9NUGG6foMVPtcWgpRU32HToDUZr"),we=new t.PublicKey("Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"),ye=new t.PublicKey("24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"),Me=new t.PublicKey("GNExJhNUhc9LN2DauuQAUJnXoy6DJ6zey3t9kT9A2PF3"),Te=new t.PublicKey("ziSPuDShwunW4xNrCfTnSHTPVT6FZDREtdofpf1BJwe"),Pe=new t.PublicKey("7WduLbRfYhTJktjLw5FDEyrqoEv61aTTCuGAetgLjzN5"),ve=new t.PublicKey("8CxKnuJeoeQXFwiG6XiGY2akBjvJA5k3bE52BfnuEmNQ"),be=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],Ie=Object.freeze({AlreadyInUse:{code:1,name:"AlreadyInUsed",msg:"Account already In Used"},InsufficientSOL:{code:1,name:"InsufficientSOL",msg:"Insufficient SOL"},TransactionNotConfirmed:{code:7e3,name:"TransactionNotConfirmed",msg:"Transaction was not confirmed"},BalancesNotExtractedProperly:{code:7001,name:"BalancesNotExtractedProperly",msg:"Balances cannot be extracted properly"},...j.errors.reduce(((e,t)=>({...e,[t.name]:t})),{})}),Be=new u.AnchorProvider(null,null,{skipPreflight:!1});class De extends d.Layout{constructor(e){const t=d.blob(32);super(t.span,e),this.layout=void 0,this.layout=t}getSpan(e,t){return this.layout.getSpan(e,t)}decode(e,n){return new t.PublicKey(this.layout.decode(e,n))}encode(e,t,n){return this.layout.encode(e.toBuffer(),t,n)}}const Ee=e=>new De(e);class Fe extends d.Layout{constructor(e=8,t){const n=d.blob(e);super(n.span,t),this.layout=void 0,this.layout=n}getSpan(e,t){return this.layout.getSpan(e,t)}decode(t,n){return new e.u64(this.layout.decode(t,n),10,"le")}encode(e,t,n){return this.layout.encode(e.toArrayLike(Buffer,"le",this.layout.span),t,n)}}const Le=e=>new Fe(8,e),Oe=e=>new Fe(16,e);function Re(e,n){let i=Buffer.alloc(0);e.forEach((function(e){if(e.length>t.MAX_SEED_LENGTH)throw new TypeError("Max seed length exceeded");var n;i=Buffer.concat([i,(n=e,Buffer.isBuffer(n)?n:n instanceof Uint8Array?Buffer.from(n.buffer,n.byteOffset,n.byteLength):Buffer.from(n))])})),i=Buffer.concat([i,n.toBuffer(),Buffer.from("ProgramDerivedAddress")]);let o=l.sha256(new Uint8Array(i)),s=new L.default(o,16).toArray(void 0,32);return new t.PublicKey(s)}const qe=d.struct([d.u8("version"),d.u8("isInitialized"),d.u8("nonce"),Ee("ammId"),Ee("serumProgramId"),Ee("serumMarket"),Ee("tokenProgramId"),Ee("tokenAAccount"),Ee("tokenBAccount"),Ee("poolMint"),Ee("mintA"),Ee("mintB")]),xe=d.struct([d.u8("isInitialized"),Ee("stateOwner"),Ee("feeOwner"),Le("initialSupply"),Le("returnFeeNumerator"),Le("fixedFeeNumerator"),Le("feeDenominator"),d.u8("curveType"),d.blob(32,"curveParameters")]),Ne=new t.PublicKey("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),Ce=(e,t)=>{const n=t.owner,i=qe.decode(t.data);return{programId:n,authority:Re([e.toBuffer(),Buffer.from([i.nonce])],n),version:i.version,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:i.ammId,serumProgramId:i.serumProgramId,tokenProgramId:i.tokenProgramId,tokenAAccount:i.tokenAAccount,tokenBAccount:i.tokenBAccount,serumMarket:i.serumMarket,poolMint:i.poolMint,mintA:i.mintA,mintB:i.mintB}},Ke={Bid:{bid:{}},Ask:{ask:{}}},Ue=e=>({serum:{side:e}}),_e=e=>({aldrin:{side:e}}),Ve=e=>({aldrinV2:{side:e}}),We=e=>({whirlpool:{aToB:e}}),Ge=e=>({invariant:{xToY:e}}),Qe=e=>({chain:{swapLegs:e}}),ze=e=>({split:{splitLegs:e}}),je=e=>({swap:{swap:e}}),He=(e,t)=>({percent:e,swapLeg:t}),Xe=new t.PublicKey("JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB"),Ye=new u.Program(j,Xe,{}),Ze={pubkey:Xe,isSigner:!1,isWritable:!1};function Je(t,n,i,o,s,a,r,u){return Ye.instruction.route(i,s,a,r,u,{accounts:{tokenProgram:e.TOKEN_PROGRAM_ID,userTransferAuthority:t,destinationTokenAccount:n},remainingAccounts:o})}function $e(t,n,i,o){return{swapProgram:re,swapState:t.ammId,tokenProgram:e.TOKEN_PROGRAM_ID,poolAuthority:t.authority,userTransferAuthority:o,sourceTokenAccount:n,destinationTokenAccount:i}}const[et]=c.findProgramAddressSync([new Uint8Array(Buffer.from("amm authority".replace(" "," "),"utf-8"))],J);function tt(t,n,i,o){if(!t.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:J,tokenProgram:e.TOKEN_PROGRAM_ID,ammId:t.ammId,ammAuthority:et,ammOpenOrders:t.ammOpenOrders,poolCoinTokenAccount:t.poolCoinTokenAccount,poolPcTokenAccount:t.poolPcTokenAccount,serumProgramId:t.serumProgramId,serumMarket:t.serumMarket,serumBids:t.serumMarketKeys.serumBids,serumAsks:t.serumMarketKeys.serumAsks,serumEventQueue:t.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:t.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:t.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:t.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:n,userDestinationTokenAccount:i,userSourceOwner:o}}function nt(n,i,o,s,a,r){const u=c.createProgramAddressSync([n.address.toBuffer(),n.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],n.programId);return{market:{market:n.address,openOrders:i,requestQueue:n.decoded.requestQueue,eventQueue:n.decoded.eventQueue,bids:n.bidsAddress,asks:n.asksAddress,coinVault:n.decoded.baseVault,pcVault:n.decoded.quoteVault,vaultSigner:u},authority:r,orderPayerTokenAccount:o,coinWallet:s,pcWallet:a,dexProgram:n.programId,tokenProgram:e.TOKEN_PROGRAM_ID,rent:t.SYSVAR_RENT_PUBKEY}}function it(t,n,i,o,s){const a=n.equals(t.state.tokenA.mint)?t.state.tokenB.adminFeeAccount:t.state.tokenA.adminFeeAccount,[r,u]=n.equals(t.state.tokenA.mint)?[t.state.tokenA.reserve,t.state.tokenB.reserve]:[t.state.tokenB.reserve,t.state.tokenA.reserve];return{swapProgram:t.config.swapProgramID,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.config.swapAccount,swapAuthority:t.config.authority,userAuthority:s,inputUserAccount:i,inputTokenAccount:r,outputUserAccount:o,outputTokenAccount:u,feesTokenAccount:a}}function ot(e,t){const n=[];return n.push(e?{pubkey:e,isSigner:!1,isWritable:!0}:t?{pubkey:t,isSigner:!1,isWritable:!0}:Ze),n}const st=new e.u64(0);class at{constructor(e,t){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=e,this.denominator=t}static fromDecimal(e){return at.fromFraction(e.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(t,n){const i="number"==typeof t?new e.u64(t.toString()):t,o="number"==typeof n?new e.u64(n.toString()):n;return new at(i,o)}toDecimal(){return this.denominator.eq(st)?new O.default(0):new O.default(this.numerator.toString()).div(new O.default(this.denominator.toString()))}add(t){const n=this.denominator.gcd(t.denominator),i=this.denominator.div(n).mul(t.denominator),o=i.div(this.denominator),s=i.div(t.denominator),a=this.numerator.mul(o),r=t.numerator.mul(s),u=a.add(r);return new at(new e.u64(u.toString()),new e.u64(i.toString()))}}const rt=d.struct([Le("tradeFeeNumerator"),Le("tradeFeeDenominator"),Le("ownerTradeFeeNumerator"),Le("ownerTradeFeeDenominator"),Le("ownerWithdrawFeeNumerator"),Le("ownerWithdrawFeeDenominator")],"fees"),ut=[d.blob(8,"padding"),Ee("lpTokenFreezeVault"),Ee("poolMint"),Ee("baseTokenVault"),Ee("baseTokenMint"),Ee("quoteTokenVault"),Ee("quoteTokenMint"),Ee("poolSigner"),d.u8("poolSignerNonce"),Ee("authority"),Ee("initializerAccount"),Ee("feeBaseAccount"),Ee("feeQuoteAccount"),Ee("feePoolTokenAccount"),rt],ct=d.struct(ut),dt=d.struct([...ut,d.u8("curveType"),Ee("curve")]),lt=d.struct([d.blob(8,"padding"),Le("amp")]);function mt(e,t){const n=!!t.owner.equals(ee),i=(n?dt:ct).decode(t.data),o="curveType"in i?{curveType:i.curveType,curve:i.curve}:{};return{isV2:n,address:e,poolMint:i.poolMint,baseTokenVault:i.baseTokenVault,baseTokenMint:i.baseTokenMint,quoteTokenVault:i.quoteTokenVault,quoteTokenMint:i.quoteTokenMint,poolSigner:i.poolSigner,feeBaseAccount:i.feeBaseAccount,feeQuoteAccount:i.feeQuoteAccount,feePoolTokenAccount:i.feePoolTokenAccount,fees:{traderFee:at.fromFraction(i.fees.tradeFeeNumerator,i.fees.tradeFeeDenominator),ownerFee:at.fromFraction(i.fees.ownerTradeFeeNumerator,i.fees.ownerTradeFeeDenominator)},...o}}class pt{constructor(e,t,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.poolState=mt(e,t),this.id=e.toBase58(),1===this.poolState.curveType){const{amp:e}=this.params;if(!e)throw new Error("Amp is required for a stable curve");this.calculator=new o.TokenSwapStable(E.default.BigInt(e),new o.Fraction(E.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),E.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new o.Fraction(E.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),E.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new o.TokenSwapConstantProduct(new o.Fraction(E.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),E.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new o.Fraction(E.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),E.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(e){const{amp:t}=lt.decode(e.data);return 2*t.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(e){const t=G(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=a.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new O.default(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new O.default(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const i=this.tokenAccounts[0].mint.equals(e)?1:0;let o=this.calculator.exchange(Q(this.tokenAccounts),t,i);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,curve:s,userTransferAuthority:a}){const[r,u,c]=n.equals(t.baseTokenMint)?[Ke.Ask,i,o]:[Ke.Bid,o,i];return[je(Ve(r)),Ye.instruction.aldrinV2Swap({accounts:{swapProgram:ee,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:a,userBaseTokenAccount:u,userQuoteTokenAccount:c,curve:s,tokenProgram:e.TOKEN_PROGRAM_ID}}).keys]}({poolState:this.poolState,curve:this.poolState.curve,...t})}return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r,u]=n.equals(t.baseTokenMint)?[Ke.Ask,i,o]:[Ke.Bid,o,i];return[je(_e(a)),Ye.instruction.aldrinSwap({accounts:{swapProgram:$,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:s,userBaseTokenAccount:r,userQuoteTokenAccount:u,tokenProgram:e.TOKEN_PROGRAM_ID}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.baseTokenMint,this.poolState.quoteTokenMint]}}pt.accountInfoToAldrinPoolState=mt;const gt=(e,t)=>{const n=t.owner,i=g.TokenSwapAccountLayout.decode(t.data);return{programId:n,authority:Re([e.toBuffer(),Buffer.from([i.nonce])],n),version:i.version,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:e,tokenProgramId:i.tokenProgramId,tokenAAccount:i.swapTokenA,tokenBAccount:i.swapTokenB,ticksKey:i.ticksKey,mintA:i.tokenAMint,mintB:i.tokenBMint,fee:i.fee,currentSqrtPrice:i.currentSqrtPrice,currentLiquity:i.currentLiquity}};class ht{constructor(e,t){this.id=void 0,this.label="Crema",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.ticks=void 0,this.poolState=void 0,this.poolState=gt(e,t),this.id=e.toBase58()}getAccountsForUpdate(){return[this.poolState.ammId,this.poolState.ticksKey]}update(e){const[t,n]=G(e,this.getAccountsForUpdate());this.poolState=gt(this.poolState.ammId,t);const i=g.parseTicksAccount(this.poolState.ticksKey,n);if(!i)throw new Error(`Ticks account invalid: ${this.poolState.ticksKey.toBase58()}`);this.ticks=i.data.ticks}getQuote({sourceMint:e,amount:t}){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");if(E.default.equal(t,o.ZERO))return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.ZERO,feeAmount:o.ZERO,feeMint:e.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:0};const n=this.poolState.mintA.equals(e)?this.preSwapA(new O.default(t.toString())):this.preSwapB(new O.default(t.toString()));if(n.revert)throw new Error("Crema error: insufficient liquidity");return{notEnoughLiquidity:!1,inAmount:t,outAmount:E.default.BigInt(n.amountOut.toString()),feeAmount:E.default.BigInt(n.feeUsed.toString()),feeMint:e.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:n.impact.toNumber()}}preSwapA(e){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");const t=g.calculateSwapA2B(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,e),n=this.poolState.currentSqrtPrice.pow(2),i=t.amountOut.div(t.amountUsed).sub(n).div(n).abs(),o=t.amountUsed.lessThan(e);return{...t,impact:i,revert:o}}preSwapB(e){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");const t=g.calculateSwapB2A(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,e),n=this.poolState.currentSqrtPrice.pow(2),i=new O.default(1).div(n),o=t.amountOut.div(t.amountUsed).sub(i).div(i).abs(),s=t.amountUsed.lessThan(e);return{...t,impact:o,revert:s}}getSwapLegAndAccounts(t){return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r]=n.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return[je({crema:{}}),Ye.instruction.cremaSwap({accounts:{swapProgram:t.programId,pool:t.ammId,poolSigner:t.authority,userSourceTokenAccount:i,userDestinationTokenAccount:o,poolSourceTokenAccount:a,poolDestinationTokenAccount:r,poolTicksAccount:t.ticksKey,walletAuthority:s,tokenProgram:e.TOKEN_PROGRAM_ID}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}class ft{static async getStateFromStateAccount(e){const t=await e.getAccountInfo(Ne);if(!t)throw new Error("State account not found");return(e=>{const t=xe.decode(e.data);return{isInitialized:Boolean(t.isInitialized),stateOwner:t.stateOwner,feeOwner:t.feeOwner,initialSupply:t.initialSupply,returnFeeNumerator:t.returnFeeNumerator.toNumber(),fixedFeeNumerator:t.fixedFeeNumerator.toNumber(),feeDenominator:t.feeDenominator.toNumber(),curveType:t.curveType,curveParameters:t.curveParameters}})(t)}constructor(e,n,i){this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.feePct=void 0,this.params=void 0,this.id=e.toBase58(),this.poolState=Ce(e,n),this.params={...i,tokenAFeeAccount:new t.PublicKey(i.tokenAFeeAccount),tokenBFeeAccount:new t.PublicKey(i.tokenBFeeAccount)},this.feePct=new O.default(this.params.fixedFeeNumerator).div(this.params.feeDenominator).add(new O.default(this.params.returnFeeNumerator).div(this.params.feeDenominator)),this.calculator=new o.TokenSwapConstantProduct(new o.Fraction(E.default.BigInt(this.params.fixedFeeNumerator),E.default.BigInt(this.params.feeDenominator)),new o.Fraction(E.default.BigInt(this.params.returnFeeNumerator),E.default.BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(e){const t=G(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=a.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(e)?1:0,i=this.calculator.exchange(Q(this.tokenAccounts),t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){const n=t.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return function({poolState:t,feeAccount:n,sourceMint:i,userSourceTokenAccount:o,userDestinationTokenAccount:s,userTransferAuthority:a}){const[r,u]=i.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return[je({cropper:{}}),Ye.instruction.cropperSwap({accounts:{tokenSwapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.ammId,swapState:Ne,authority:t.authority,userTransferAuthority:a,source:o,swapSource:r,swapDestination:u,destination:s,poolMint:t.poolMint,poolFee:n}}).keys]}({poolState:this.poolState,feeAccount:n,...t})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}ft.decodePoolState=Ce;class St{constructor(e,t){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=e,this.pool=t,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(e,t){const n=E.default.toNumber(E.default.divide(E.default.BigInt(e),E.default.BigInt(t))),{wordPos:i}=h.tickPosition(n);try{const e=[],{wordPos:n}=h.tickPosition(Math.floor(h.TickMath.MIN_TICK/t)),{wordPos:s}=h.tickPosition(Math.floor(h.TickMath.MAX_TICK/t)),a=Math.max(i-10,n),r=Math.min(i+10,s);for(let t=a;t<r;t++)e.push(this.getBitmapAddressSync(t));const c=await this.program.account.tickBitmapState.fetchMultiple(e),d=[];for(let n=0;n<r-a;n++){var o;const i=n+a,s=null===(o=c[n])||void 0===o?void 0:o.word,r=s?h.generateBitmapWord(s):new u.BN(0);if(this.bitmapCache.set(i,{address:e[n],word:r}),r&&!r.eqn(0))for(let e=0;e<256;e++)if(r.shrn(e).and(new u.BN(1)).eqn(1)){const n=this.getTickAddressSync(((i<<8)+e)*t);d.push(n)}}const l=await this.program.account.tickState.fetchMultiple(d);for(const e in d){const t=l[e];if(!t)continue;const{tick:n,liquidityNet:i}=t;this.tickCache.set(n,{address:d[e],liquidityNet:E.default.BigInt(i)})}}catch(e){}}lazyLoadAccountsToCache(e,t){const n=E.default.toNumber(E.default.divide(E.default.BigInt(e),E.default.BigInt(t))),{wordPos:i}=h.tickPosition(n),o=[],s=[],{wordPos:a}=h.tickPosition(Math.floor(h.TickMath.MIN_TICK/t)),{wordPos:r}=h.tickPosition(Math.floor(h.TickMath.MAX_TICK/t)),c=Math.max(i-10,a),d=Math.min(i+10,r);for(let e=c;e<d;e++){o.push(this.getBitmapAddressSync(e));const t=this.bitmapCache.get(e);s.push(t)}const l=[];for(let e=0;e<d-c;e++){var m,p;const n=e+c,i=null!==(m=null===(p=s[e])||void 0===p?void 0:p.word)&&void 0!==m?m:new u.BN(0);if(this.bitmapCache.set(n,{address:o[e],word:i}),i&&!i.eqn(0))for(let e=0;e<256;e++)if(i.shrn(e).and(new u.BN(1)).eqn(1)){const i=this.getTickAddressSync(((n<<8)+e)*t);l.push(i)}}return this.accountsToFetch={bitmaps:o,ticks:l},[...o,...l]}getTick(e){let t=this.tickCache.get(e);if(!t)throw new Error("Tick not cached");return{address:t.address,liquidityNet:t.liquidityNet}}async getTickAddress(e){return this.getTickAddressSync(e)}getTickAddressSync(e){return c.findProgramAddressSync([h.TICK_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),h.u32ToSeed(this.pool.fee),h.u32ToSeed(e)],this.program.programId)[0]}async getBitmapAddress(e){return this.getBitmapAddressSync(e)}getBitmapAddressSync(e){return c.findProgramAddressSync([h.BITMAP_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),h.u32ToSeed(this.pool.fee),h.u16ToSeed(e)],this.program.programId)[0]}getBitmap(e){let t=this.bitmapCache.get(e);if(!t)throw new Error("Bitmap not cached");return t}nextInitializedTickWithinOneWord(e,t,n){let i=E.default.toNumber(E.default.divide(E.default.BigInt(e),E.default.BigInt(n)));e<0&&e%n!=0&&(i-=1),t||(i+=1);const{wordPos:o,bitPos:s}=h.tickPosition(i),a=this.getBitmap(o),{next:r,initialized:u}=h.nextInitializedBit(a.word,s,t);return[h.buildTick(o,r,n),u,o,s,a.address]}updateCachedAccountInfos(e){for(const t of this.accountsToFetch.bitmaps){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(e.wordPos,{address:t,word:h.generateBitmapWord(e.word)})}}for(const t of this.accountsToFetch.ticks){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(e.tick,{address:t,liquidityNet:E.default.BigInt(e.liquidityNet)})}}}}const At=E.default.BigInt(1e6),kt=new u.Program(h.IDL,me,Be);class wt{constructor(t,n){let i;this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.feePct=void 0,this.fee=void 0,this.address=t,this.id=t.toBase58(),i="data"in n?kt.coder.accounts.decode("poolState",n.data):n,this.poolState=i;const{token0:o,token1:s,fee:a,sqrtPriceX32:r,liquidity:u,tick:d}=this.poolState;this.tickDataProvider=new St(kt,{token0:o,token1:s,fee:a}),this.tokens={token0:new f.Token(101,o,0,"",""),token1:new f.Token(101,s,0,"","")},this.pool=new h.Pool(this.tokens.token0,this.tokens.token1,a,E.default.BigInt(r.toString()),E.default.BigInt(u.toString()),d,this.tickDataProvider),this.vaults={vault0:c.findProgramAddressSync([this.address.toBuffer(),e.TOKEN_PROGRAM_ID.toBuffer(),o.toBuffer()],e.ASSOCIATED_TOKEN_PROGRAM_ID)[0],vault1:c.findProgramAddressSync([this.address.toBuffer(),e.TOKEN_PROGRAM_ID.toBuffer(),s.toBuffer()],e.ASSOCIATED_TOKEN_PROGRAM_ID)[0]},this.fee=E.default.BigInt(this.poolState.fee),this.feePct=this.poolState.fee/E.default.toNumber(At)}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=kt.coder.accounts.decode("poolState",t.data);const{fee:n,sqrtPriceX32:i,liquidity:o,tick:s}=this.poolState;this.pool=new h.Pool(this.tokens.token0,this.tokens.token1,n,E.default.BigInt(i.toString()),E.default.BigInt(o.toString()),s,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(e)}getQuote({sourceMint:e,amount:t}){const n=e.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[i,s,a]=this.pool.getOutputAmount(f.CurrencyAmount.fromRawAmount(n,t)),r=o.toDecimal(E.default.subtract(this.pool.sqrtRatioX32,s.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.quotient,feeAmount:E.default.divide(E.default.multiply(t,this.fee),At),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:r.toNumber()}}getSwapLegAndAccounts(t){const[n,i]=t.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],o=c.findProgramAddressSync([h.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),h.u32ToSeed(this.poolState.fee),h.u16ToSeed(this.poolState.observationIndex)],me)[0],s=t.sourceMint.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[,,a]=this.pool.getOutputAmount(f.CurrencyAmount.fromRawAmount(s,t.amount)),r=c.findProgramAddressSync([h.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),h.u32ToSeed(this.poolState.fee),h.u16ToSeed((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],me)[0],u={poolAddress:this.address,inputVault:n,outputVault:i,nextObservationState:r,lastObservationState:o,swapAccountMetas:a};return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[je({cykura:{}}),Ye.instruction.cykuraSwap({accounts:{swapProgram:me,signer:o,factoryState:pe,poolState:t.poolAddress,inputTokenAccount:n,outputTokenAccount:i,inputVault:t.inputVault,outputVault:t.outputVault,lastObservationState:t.lastObservationState,coreProgram:me,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:[...t.swapAccountMetas,{pubkey:t.nextObservationState,isSigner:!1,isWritable:!0},Ze]}).keys]}({...t,additionalArgs:u})}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}const yt={DkwiQyA2JfD8ARfvMbMqu2DD4XKRkewRZVDE94SZNxSS:{price:1}},Mt=S.getDeltafiDexV2(Me,Be),Tt=t=>e.u64.fromBuffer(t.data.slice(64,72)),Pt=t=>e.u64.fromBuffer(t.data.slice(36,44));class vt{constructor(e,t){this.address=void 0,this.id=void 0,this.label="GooseFX",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.pairLayout=void 0,this.quoter=void 0,this.gooseFxAccounts=void 0,this.fixedAccounts=void 0,this.oracleAccounts=[],this.quoteParams=void 0,this.isQuoteInvalid=!0,this.address=e,this.id=e.toBase58(),this.pairLayout=w.PAIR_LAYOUT.decode(t.data);const[n,i]=this.pairLayout.mints,o=new w.SyncSwap;this.quoter=o.getSyncQuoter(n,i),this.gooseFxAccounts=this.quoter.getAccounts();const{pairAddress:s,sslIn:a,sslOut:r,liabilityVaultIn:u,liabilityVaultOut:c,swappedLiabilityVaultIn:d,swappedLiabilityVaultOut:l}=this.gooseFxAccounts;this.fixedAccounts=[s,a,r,u,c,d,l],this.updateOracles()}updateOracles(){const e=Number(this.pairLayout.nOracle.toString()),t=this.pairLayout.oracles.slice(0,e).reduce(((e,t)=>{const n=Number(t.n);for(const i of t.elements.slice(0,n))e.push(i.address);return e}),[]);this.oracleAccounts=t}getAccountsForUpdate(){return[...this.fixedAccounts,...this.oracleAccounts]}update(e){var t;const[n,i,o,s,a,r,u]=G(e,this.fixedAccounts);if(!(n&&i&&o&&s&&a&&r&&u))throw new Error("Missing account data");const c=w.wasm.OracleRegistry;this.pairLayout=w.PAIR_LAYOUT.decode(n.data);const{oracles:d,nOracle:l}=this.pairLayout,m=Number(l.toString()),p=new c;this.updateOracles();for(const t of d.slice(0,m)){const n=Number(t.n);for(const i of t.elements.slice(0,n)){const t=e.get(i.address.toBase58());if(!t)return void(this.isQuoteInvalid=!0);p.add_oracle(i.address.toBuffer(),t.data)}}this.isQuoteInvalid&&(this.isQuoteInvalid=!1),null===(t=this.quoteParams)||void 0===t||t.registry.free(),this.quoteParams={liabilityIn:BigInt(Tt(s).toString()),liabilityOut:BigInt(Tt(a).toString()),pairData:n.data,sslInData:i.data,sslOutData:o.data,swappedLiabilityIn:BigInt(Tt(r).toString()),swappedLiabilityOut:BigInt(Tt(u).toString()),registry:p,suspended:new w.SSL(i).isSuspended()||new w.SSL(o).isSuspended()}}getQuote({sourceMint:e,amount:t}){if(!this.quoteParams||this.isQuoteInvalid)throw new Error("Missing quote data");const{quoteParams:n}=this,i=w.wasm.swap;let o;const s=e.equals(this.pairLayout.mints[0]);o=s?i(n.sslInData.slice(),n.sslOutData.slice(),n.pairData.slice(),n.liabilityIn,n.liabilityOut,n.swappedLiabilityIn,n.swappedLiabilityOut,n.registry,BigInt(t.toString())):i(n.sslOutData.slice(),n.sslInData.slice(),n.pairData.slice(),n.liabilityOut,n.liabilityIn,n.swappedLiabilityOut,n.swappedLiabilityIn,n.registry,BigInt(t.toString()));const a=this.pairLayout.feeRates[s?0:1],r={notEnoughLiquidity:!1,inAmount:E.default.BigInt(o.amount_in.toString()),outAmount:E.default.BigInt(o.amount_out.toString()),feeAmount:E.default.BigInt(o.fee_paid.toString()),feeMint:e.toBase58(),feePct:a/1e4,priceImpactPct:o.price_impact};return o.free(),r}findAssociatedTokenAddress(n,i){return t.PublicKey.findProgramAddressSync([n.toBuffer(),e.TOKEN_PROGRAM_ID.toBuffer(),i.toBuffer()],y.ASSOCIATED_PROGRAM_ID)[0]}getSwapLegAndAccounts(t){var n;if(!this.quoteParams)throw new Error("Missing quote data");const i=t.sourceMint.equals(this.pairLayout.mints[0]),{gooseFxAccounts:o}=this,[s,a,r,u,c,d]=i?[o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn,o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut]:[o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut,o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn];return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const s=[];return s.push(t.referrer?{pubkey:t.referrer,isSigner:!1,isWritable:!0}:Ze),t.oracles.forEach((e=>{s.push({pubkey:e,isSigner:!1,isWritable:!1})})),s.push(Ze),[je({gooseFx:{}}),Ye.instruction.goosefxSwap({accounts:{swapProgram:Pe,controller:ve,pair:t.pair,sslIn:t.sslIn,sslOut:t.sslOut,liabilityVaultIn:t.liabilityVaultIn,swappedLiabilityVaultIn:t.swappedLiabilityVaultIn,liabilityVaultOut:t.liabilityVaultOut,swappedLiabilityVaultOut:t.swappedLiabilityVaultOut,userInAta:n,userOutAta:i,feeCollectorAta:t.feeCollectorAta,userWallet:o,feeCollector:t.feeCollector,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:s}).keys]}({additionalArgs:{pair:this.gooseFxAccounts.pairAddress,sslIn:s,sslOut:u,liabilityVaultIn:a,swappedLiabilityVaultIn:r,liabilityVaultOut:c,swappedLiabilityVaultOut:d,feeCollectorAta:this.findAssociatedTokenAddress(this.pairLayout.feeCollector,t.sourceMint),feeCollector:this.pairLayout.feeCollector,oracles:this.oracleAccounts,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.sourceMint.toBase58())},...t})}get reserveTokenMints(){return this.pairLayout.mints}}const bt=new u.Program(M.IDL,ce,Be);class It{static parsePoolStructure(e){return bt.coder.accounts.decode("pool",e.data)}static parseTickmap(e){return bt.coder.accounts.decode("tickmap",e.data)}static parseTick(e){return{...bt.coder.accounts.decode("tick",e.data)}}static getQuote(e,t,n,i,o,s){const{currentTickIndex:a,fee:r,tickSpacing:u,tokenX:c,liquidity:d,sqrtPrice:l}=e,p={currentTickIndex:a,tickSpacing:u,liquidity:d,fee:r,sqrtPrice:l},g={xToY:i.equals(c),byAmountIn:s===exports.SwapMode.ExactIn,swapAmount:new m.BN(o.toString()),priceLimit:i.equals(c)?M.calculatePriceSqrt(M.MIN_TICK):M.calculatePriceSqrt(M.MAX_TICK),slippage:M.toDecimal(0),ticks:t,tickmap:n,pool:p};return M.simulateSwap(g)}static getTickIndexToTickPubkeyHash(e,t,n){if(!n){const{tickAddress:n}=this.getTickAddress(e,t.currentTickIndex),i=new Map;return i.set(t.currentTickIndex,n),i}const i=M.findClosestTicks(n.bitmap,t.currentTickIndex,t.tickSpacing,M.TICK_CROSSES_PER_IX,Infinity,"down"),o=M.findClosestTicks(n.bitmap,t.currentTickIndex,t.tickSpacing,M.TICK_CROSSES_PER_IX,Infinity,"up");return i.concat([t.currentTickIndex]).concat(o).reduce(((t,n)=>{const{tickAddress:i}=this.getTickAddress(e,n);return t.set(n,i),t}),new Map)}static getTickAddress(e,n){const i=Buffer.alloc(4);i.writeInt32LE(n);const[o,s]=t.PublicKey.findProgramAddressSync([Buffer.from(u.utils.bytes.utf8.encode("tickv1")),e.toBuffer(),i],bt.programId);return{tickAddress:o,tickBump:s}}}class Bt{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Invariant",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolStructure=void 0,this.tickmap=void 0,this.tickPkToTickIndexHash=void 0,this.ticks=new Map,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.poolStructure=It.parsePoolStructure(t),this.tickPkToTickIndexHash=It.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.feePct=new O.default(this.poolStructure.fee.v.toString()).div(M.DENOMINATOR.toString()).toNumber()}getAccountsForUpdate(){const e=this.tickPkToTickIndexHash.values();return[this.address,this.poolStructure.tickmap,...e]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing invariant pool data ${this.address.toBase58()}`);this.poolStructure=It.parsePoolStructure(t);const n=e.get(this.poolStructure.tickmap.toBase58());n&&(this.tickmap=It.parseTickmap(n)),this.tickPkToTickIndexHash=It.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.ticks.clear();for(const[t,n]of this.tickPkToTickIndexHash){const i=e.get(n.toBase58());if(!i)continue;const o=It.parseTick(i);this.ticks.set(t,o)}}getQuote({sourceMint:e,amount:t,swapMode:n}){if(!this.tickmap)throw new Error("Missing tickmap");const i=It.getQuote(this.poolStructure,this.ticks,this.tickmap,e,t,n),o=new O.default(i.priceImpact.toString()).div(M.DENOMINATOR.toString()).toNumber();if(0!==i.status)throw new Error(`Invariant simulation failed: ${this.address}`);return{notEnoughLiquidity:!1,inAmount:E.default.BigInt(i.accumulatedAmountIn.toString()),outAmount:E.default.BigInt(i.accumulatedAmountOut.toString()),feeAmount:E.default.BigInt(i.accumulatedFee.toString()),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:o}}getSwapLegAndAccounts(t){var n;if(!this.tickmap)throw new Error("Missing tickmap");const i=It.getQuote(this.poolStructure,this.ticks,this.tickmap,t.sourceMint,t.amount,t.swapMode),o={};this.tickPkToTickIndexHash.forEach(((e,t)=>{o[t]=e}));const s=i.crossedTicks.concat(this.poolStructure.currentTickIndex).map((e=>{const t=o[e];if(!t)throw new Error("Missing tick account.");return t})),a=t.sourceMint.equals(this.poolStructure.tokenX);return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a]=t.xToY?[n,i]:[i,n],r=t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[];return t.crossedTickAddresses.forEach((e=>{r.push({pubkey:e,isSigner:!1,isWritable:!0})})),r.push(Ze),[je(Ge(t.xToY)),Ye.instruction.invariantSwap({accounts:{swapProgram:ce,tokenProgram:e.TOKEN_PROGRAM_ID,owner:o,state:de,pool:t.pool,tickmap:t.tickmap,accountX:s,accountY:a,reserveX:t.reserveX,reserveY:t.reserveY,programAuthority:le},remainingAccounts:r}).keys]}({...t,additionalArgs:{xToY:a,pool:this.address,tickmap:this.poolStructure.tickmap,reserveX:this.poolStructure.tokenXReserve,reserveY:this.poolStructure.tokenYReserve,crossedTickAddresses:s,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.sourceMint.toBase58())}})}get reserveTokenMints(){return[this.poolStructure.tokenX,this.poolStructure.tokenY]}}class Dt{constructor(e,t){var n;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapState=void 0,this.poolInfo=void 0,this.accountInfos=[],this.ammAccountInfo=t,this.id=e.toBase58(),this.swapState=((e,t)=>{const n=t.owner,i=T.LIFINITY_AMM_LAYOUT.decode(t.data),[o]=c.findProgramAddressSync([e.toBuffer()],n);return{programId:n,authority:o,amm:e,tokenAMint:i.tokenAMint,tokenBMint:i.tokenBMint,poolMint:i.poolMint,feeAccount:i.poolFeeAccount,pythAccount:i.pythAccount,pythPcAccount:i.pythPcAccount,configAccount:i.configAccount,poolCoinTokenAccount:i.tokenAAccount,poolCoinMint:i.tokenAMint,poolPcTokenAccount:i.tokenBAccount,poolPcMint:i.tokenBMint}})(e,t),this.poolInfo={amm:(n=this.swapState).amm.toBase58(),configAccount:n.configAccount.toBase58(),feeAccount:n.feeAccount.toBase58(),pythAccount:n.pythAccount.toBase58(),pythPcAccount:n.pythPcAccount.toBase58(),poolCoinMint:n.poolCoinMint.toBase58(),poolCoinTokenAccount:n.poolCoinTokenAccount.toBase58(),poolMint:n.poolMint.toBase58(),poolPcTokenAccount:n.poolPcTokenAccount.toBase58(),poolPcMint:n.poolPcMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:0}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount]}update(e){this.getAccountsForUpdate().forEach(((t,n)=>{const i=e.get(t.toBase58());i&&(this.accountInfos[n]={publicKey:t,account:i})}))}getQuote({sourceMint:e,amount:t}){if(this.accountInfos.length!==this.getAccountsForUpdate().length)throw new Error("Accounts not loaded");const n=this.swapState.poolCoinMint.equals(e)?T.TradeDirection.AtoB:T.TradeDirection.BtoA,{amm:i,pyth:o,pythPc:s,fees:a,coinBalance:r,pcBalance:u,config:c}=T.getParsedData([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...this.accountInfos],this.poolInfo);if(!o.status.equals(1)||s&&!s.status.equals(1))throw new Error("Pyth accounts are outdated");const d=new O.default(t.toString()),l=T.getCurveAmount(d,o.publishSlot.toNumber(),i,a,r,u,c,o,s,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:E.default.BigInt(l.amountSwapped.toString()),feeAmount:E.default.BigInt(l.fee.ceil().toString()),feeMint:e.toBase58(),feePct:l.feePercent.toNumber(),priceImpactPct:l.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({swapState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r]=n.equals(t.tokenAMint)?[t.poolCoinTokenAccount,t.poolPcTokenAccount]:[t.poolPcTokenAccount,t.poolCoinTokenAccount];return[je({lifinity:{}}),Ye.instruction.lifinitySwap({accounts:{swapProgram:t.programId,authority:t.authority,amm:t.amm,userTransferAuthority:s,sourceInfo:i,destinationInfo:o,swapSource:a,swapDestination:r,poolMint:t.poolMint,feeAccount:t.feeAccount,tokenProgram:e.TOKEN_PROGRAM_ID,pythAccount:t.pythAccount,pythPcAccount:t.pythPcAccount,configAccount:t.configAccount}}).keys]}({swapState:this.swapState,...t})}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}}var Et="marinade_finance",Ft=[{name:"initialize",accounts:[{name:"creatorAuthority",isMut:!1,isSigner:!0},{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!1,isSigner:!1},{name:"liqPool",accounts:[{name:"lpMint",isMut:!1,isSigner:!1},{name:"solLegPda",isMut:!1,isSigner:!1},{name:"msolLeg",isMut:!1,isSigner:!1}]},{name:"treasuryMsolAccount",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"data",type:{defined:"InitializeData"}}]},{name:"changeAuthority",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"data",type:{defined:"ChangeAuthorityData"}}]},{name:"addValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!1,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"score",type:"u32"}]},{name:"removeValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"}]},{name:"setValidatorScore",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"},{name:"score",type:"u32"}]},{name:"configValidatorSystem",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0}],args:[{name:"extraRuns",type:"u32"}]},{name:"deposit",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"depositStakeAccount",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeAuthority",isMut:!1,isSigner:!0},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"msolMint",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"liquidUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"addLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"lpMintAuthority",isMut:!1,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!1,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"removeLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"burnFrom",isMut:!0,isSigner:!1},{name:"burnFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"transferMsolTo",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokens",type:"u64"}]},{name:"setLpParams",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"minFee",type:{defined:"Fee"}},{name:"maxFee",type:{defined:"Fee"}},{name:"liquidityTarget",type:"u64"}]},{name:"configMarinade",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigMarinadeParams"}}]},{name:"orderUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"burnMsolFrom",isMut:!0,isSigner:!1},{name:"burnMsolAuthority",isMut:!1,isSigner:!0},{name:"newTicketAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"claim",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"ticketAccount",isMut:!0,isSigner:!1},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"stakeReserve",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeConfig",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"updateActive",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"updateDeactivated",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"}]},{name:"deactivateStake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"emergencyUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"mergeStakes",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"destinationStake",isMut:!0,isSigner:!1},{name:"sourceStake",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"destinationStakeIndex",type:"u32"},{name:"sourceStakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]}],Lt=[{name:"State",type:{kind:"struct",fields:[{name:"msolMint",type:"publicKey"},{name:"adminAuthority",type:"publicKey"},{name:"operationalSolAccount",type:"publicKey"},{name:"treasuryMsolAccount",type:"publicKey"},{name:"reserveBumpSeed",type:"u8"},{name:"msolMintAuthorityBumpSeed",type:"u8"},{name:"rentExemptForTokenAcc",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"stakeSystem",type:{defined:"StakeSystem"}},{name:"validatorSystem",type:{defined:"ValidatorSystem"}},{name:"liqPool",type:{defined:"LiqPool"}},{name:"availableReserveBalance",type:"u64"},{name:"msolSupply",type:"u64"},{name:"msolPrice",type:"u64"},{name:"circulatingTicketCount",type:"u64"},{name:"circulatingTicketBalance",type:"u64"},{name:"lentFromReserve",type:"u64"},{name:"minDeposit",type:"u64"},{name:"minWithdraw",type:"u64"},{name:"stakingSolCap",type:"u64"},{name:"emergencyCoolingDown",type:"u64"}]}},{name:"TicketAccountData",type:{kind:"struct",fields:[{name:"stateAddress",type:"publicKey"},{name:"beneficiary",type:"publicKey"},{name:"lamportsAmount",type:"u64"},{name:"createdEpoch",type:"u64"}]}}],Ot=[{name:"Fee",type:{kind:"struct",fields:[{name:"basisPoints",type:"u32"}]}},{name:"InitializeData",type:{kind:"struct",fields:[{name:"adminAuthority",type:"publicKey"},{name:"validatorManagerAuthority",type:"publicKey"},{name:"minStake",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"liqPool",type:{defined:"LiqPoolInitializeData"}},{name:"additionalStakeRecordSpace",type:"u32"},{name:"additionalValidatorRecordSpace",type:"u32"},{name:"slotsForStakeDelta",type:"u64"}]}},{name:"LiqPoolInitializeData",type:{kind:"struct",fields:[{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"lpTreasuryCut",type:{defined:"Fee"}}]}},{name:"ChangeAuthorityData",type:{kind:"struct",fields:[{name:"admin",type:{option:"publicKey"}},{name:"validatorManager",type:{option:"publicKey"}},{name:"operationalSolAccount",type:{option:"publicKey"}},{name:"treasuryMsolAccount",type:{option:"publicKey"}}]}},{name:"ConfigMarinadeParams",type:{kind:"struct",fields:[{name:"rewardsFee",type:{option:{defined:"Fee"}}},{name:"slotsForStakeDelta",type:{option:"u64"}},{name:"minStake",type:{option:"u64"}},{name:"minDeposit",type:{option:"u64"}},{name:"minWithdraw",type:{option:"u64"}},{name:"stakingSolCap",type:{option:"u64"}},{name:"liquiditySolCap",type:{option:"u64"}},{name:"autoAddValidatorEnabled",type:{option:"bool"}}]}},{name:"LiqPool",type:{kind:"struct",fields:[{name:"lpMint",type:"publicKey"},{name:"lpMintAuthorityBumpSeed",type:"u8"},{name:"solLegBumpSeed",type:"u8"},{name:"msolLegAuthorityBumpSeed",type:"u8"},{name:"msolLeg",type:"publicKey"},{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"treasuryCut",type:{defined:"Fee"}},{name:"lpSupply",type:"u64"},{name:"lentFromSolLeg",type:"u64"},{name:"liquiditySolCap",type:"u64"}]}},{name:"List",type:{kind:"struct",fields:[{name:"account",type:"publicKey"},{name:"itemSize",type:"u32"},{name:"count",type:"u32"},{name:"newAccount",type:"publicKey"},{name:"copiedCount",type:"u32"}]}},{name:"StakeRecord",type:{kind:"struct",fields:[{name:"stakeAccount",type:"publicKey"},{name:"lastUpdateDelegatedLamports",type:"u64"},{name:"lastUpdateEpoch",type:"u64"},{name:"isEmergencyUnstaking",type:"u8"}]}},{name:"StakeSystem",type:{kind:"struct",fields:[{name:"stakeList",type:{defined:"List"}},{name:"delayedUnstakeCoolingDown",type:"u64"},{name:"stakeDepositBumpSeed",type:"u8"},{name:"stakeWithdrawBumpSeed",type:"u8"},{name:"slotsForStakeDelta",type:"u64"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"minStake",type:"u64"},{name:"extraStakeDeltaRuns",type:"u32"}]}},{name:"ValidatorRecord",type:{kind:"struct",fields:[{name:"validatorAccount",type:"publicKey"},{name:"activeBalance",type:"u64"},{name:"score",type:"u32"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"duplicationFlagBumpSeed",type:"u8"}]}},{name:"ValidatorSystem",type:{kind:"struct",fields:[{name:"validatorList",type:{defined:"List"}},{name:"managerAuthority",type:"publicKey"},{name:"totalValidatorScore",type:"u32"},{name:"totalActiveBalance",type:"u64"},{name:"autoAddValidatorEnabled",type:"u8"}]}},{name:"CommonError",type:{kind:"enum",variants:[{name:"InvalidProgramId",fields:["publicKey"]},{name:"UnexpectedAccount",fields:["publicKey"]},{name:"CalculationFailure"},{name:"AccountWithLockup"},{name:"NumberTooLow",fields:["u64","u64"]},{name:"NumberTooHigh",fields:["u64","u64"]},{name:"FeeTooHigh",fields:[{defined:"Fee"}]},{name:"FeesWrongWayRound",fields:[{defined:"Fee"},{defined:"Fee"}]},{name:"LiquidityTargetTooLow"},{name:"TicketNotDue",fields:["u64"]},{name:"TicketNotReady"},{name:"WrongBeneficiary"},{name:"InsufficientLiquidity"},{name:"InvalidValidator"}]}},{name:"InitializeError",type:{kind:"enum",variants:[{name:"WrongReserveOwner",fields:["publicKey"]},{name:"NonEmptyReserveData",fields:[{defined:"usize"}]},{name:"InvalidInitialReserveLamports",fields:["u64"]},{name:"ZeroValidatorChunkSize"},{name:"TooBigValidatorChunkSize",fields:["u32"]},{name:"ZeroCreditChunkSize"},{name:"TooBigCreditChunkSize",fields:["u32"]},{name:"TooLowCreditFee",fields:["u64"]},{name:"InvalidMintAuthority",fields:[{name:"expected",type:"publicKey"},{name:"got",type:"publicKey"}]},{name:"MintHasInitialSupply",fields:["u64"]},{name:"InvalidOwnerFeeState",fields:[{defined:"spl_token::state::AccountState"}]}]}}],Rt={__proto__:null,version:"0.0.0",name:Et,instructions:Ft,accounts:Lt,types:Ot,default:{version:"0.0.0",name:Et,instructions:Ft,accounts:Lt,types:Ot}};function qt(e,t,n){return n.isZero()?e:e.mul(t).div(n)}class xt{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Marinade",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.marinadeFinanceProgram=void 0,this.marinadeStateResponse=void 0,this.liqPoolSolLegPdaAddress=void 0,this.marinadeState=void 0,this.id=e.toBase58(),this.marinadeFinanceProgram=new u.Program(Rt,ge,{}),this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data),this.address=e,this.liqPoolSolLegPdaAddress=this.findProgramDerivedAddress("liq_sol")}getAccountsForUpdate(){return[this.address,this.liqPoolSolLegPdaAddress,this.marinadeStateResponse.liqPool.msolLeg]}update(e){const[t,n,i]=G(e,this.getAccountsForUpdate());this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data);const o=a.deserializeAccount(i.data);if(!o)throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);this.marinadeState=new Nt(this.marinadeStateResponse,new L.default(n.lamports),o.amount)}getQuote({sourceMint:t,amount:n}){if(!this.marinadeState)throw new Error("Update was not run to create a complete marinadeState");const i=new L.default(n.toString()),o=t.equals(e.NATIVE_MINT)?this.marinadeState.depositQuote(i):this.marinadeState.liquidUnstakeQuote(i);return{notEnoughLiquidity:!1,inAmount:n,outAmount:E.default.BigInt(o.outAmount.toString()),feeAmount:E.default.BigInt(o.feeAmount.toString()),feeMint:this.marinadeStateResponse.msolMint.toBase58(),feePct:o.feePct,priceImpactPct:0}}getSwapLegAndAccounts(n){return n.sourceMint.equals(e.NATIVE_MINT)?function({additionalArgs:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const a=s,r=c.findProgramAddressSync([Buffer.from("temp-wsol-token-account"),a.toBuffer()],Xe)[0],u=c.findProgramAddressSync([Buffer.from("temp-sol-pda"),s.toBuffer()],Xe)[0];return[je({marinadeDeposit:{}}),Ye.instruction.marinadeDeposit({accounts:{marinadeFinanceProgram:ge,state:n.address,userTransferAuthority:s,msolMint:n.marinadeStateResponse.msolMint,liqPoolSolLegPda:n.liqPoolSolLegPda,liqPoolMsolLeg:n.marinadeStateResponse.liqPool.msolLeg,liqPoolMsolLegAuthority:n.liqPoolMsolLegAuthority,reservePda:n.reservePda,transferFrom:u,mintTo:o,msolMintAuthority:n.msolMintAuthority,systemProgram:t.SystemProgram.programId,tokenProgram:e.TOKEN_PROGRAM_ID,userWsolTokenAccount:i,tempWsolTokenAccount:r,wsolMint:e.NATIVE_MINT,rent:t.SYSVAR_RENT_PUBKEY}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress,liqPoolMsolLegAuthority:this.findProgramDerivedAddress("liq_st_sol_authority"),reservePda:this.findProgramDerivedAddress("reserve"),msolMintAuthority:this.findProgramDerivedAddress("st_mint")},...n}):function({additionalArgs:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const a=c.findProgramAddressSync([Buffer.from("temp-sol-pda"),s.toBuffer()],Xe)[0];return[je({marinadeUnstake:{}}),Ye.instruction.marinadeUnstake({accounts:{marinadeFinanceProgram:ge,state:n.address,msolMint:n.marinadeStateResponse.msolMint,liqPoolSolLegPda:n.liqPoolSolLegPda,liqPoolMsolLeg:n.marinadeStateResponse.liqPool.msolLeg,treasuryMsolAccount:n.marinadeStateResponse.treasuryMsolAccount,getMsolFrom:i,getMsolFromAuthority:s,transferSolTo:a,systemProgram:t.SystemProgram.programId,tokenProgram:e.TOKEN_PROGRAM_ID,userWsolTokenAccount:o}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress},...n})}get reserveTokenMints(){return[e.NATIVE_MINT,this.marinadeStateResponse.msolMint]}findProgramDerivedAddress(e,t=[]){const n=[this.address.toBuffer(),Buffer.from(e),...t],[i]=c.findProgramAddressSync(n,this.marinadeFinanceProgram.programId);return i}}class Nt{constructor(e,t,n){this.state=void 0,this.liqPoolSolLegPdaLamports=void 0,this.liqPoolMSOLLegAmount=void 0,this.state=e,this.liqPoolSolLegPdaLamports=t,this.liqPoolMSOLLegAmount=n}depositQuote(e){let t=e;const n=this.calcMSOLFromLamports(t),i=L.default.min(n,this.liqPoolMSOLLegAmount);let o=new L.default(0);if(t=(()=>{if(i.gt(new L.default(0))){const e=n.eq(i)?t:this.calcLamportsFromMSOLAmount(i);return o=o.add(i),Ct(t,e)}return t})(),t.gt(new L.default(0))){this.checkStakingCap(t);const e=this.calcMSOLFromLamports(t);o=o.add(e)}return{outAmount:o,feeAmount:0,feePct:0,priceImpactPct:0}}checkStakingCap(e){if(this.totalLamportsUnderControl().add(e).gt(this.state.stakingSolCap))throw new Error("Staking cap reached")}calcMSOLFromLamports(e){return t=e,n=this.totalVirtualStakedLamports(),(i=this.state.msolSupply).eq(new L.default(0))?t:qt(t,i,n);var t,n,i}calcLamportsFromMSOLAmount(e){return qt(e,this.totalVirtualStakedLamports(),this.state.msolSupply)}totalVirtualStakedLamports(){return Ct(this.totalLamportsUnderControl(),this.state.circulatingTicketBalance)}totalLamportsUnderControl(){return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance)}totalCoolingDown(){return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown)}liquidUnstakeQuote(e){const t=Ct(this.liqPoolSolLegPdaLamports,this.state.rentExemptForTokenAcc),n=this.calcLamportsFromMSOLAmount(e),i=function(e,t,n,i,o){if(o.gte(i))return t;const s=i.sub(o);return s.gte(n)?e:t-qt(new L.default(t-e),s,n).toNumber()}(this.state.liqPool.lpMinFee.basisPoints,this.state.liqPool.lpMaxFee.basisPoints,this.state.liqPool.lpLiquidityTarget,t,n),o=e.mul(new L.default(i)).div(new L.default(1e4)),s=this.calcLamportsFromMSOLAmount(e.sub(o));if(s.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports))throw new Error("Insufficient liquidity");return{outAmount:s,feeAmount:o,feePct:i/1e4,priceImpactPct:0}}}function Ct(e,t){return e.gt(t)?e.sub(t):new L.default(0)}const Kt=Math.pow(10,10),Ut=d.struct([d.u8("version"),d.u8("isInitialized"),d.u8("nonce"),Le("amplificationCoefficient"),Le("feeNumerator"),Le("adminFeeNumerator"),d.u32("tokenAccountsLength"),Le("precisionFactor"),Le("precisionMultiplierA"),Le("precisionMultiplierB"),Le("precisionMultiplierC"),Le("precisionMultiplierD"),Ee("tokenAccountA"),Ee("tokenAccountB"),Ee("tokenAccountC"),Ee("tokenAccountD")]),_t=(e,t)=>{const n=t.owner,i=Ut.decode(t.data),o=i.tokenAccountsLength,s=Re([e.toBuffer(),Buffer.from([i.nonce])],n),a=[i.precisionMultiplierA.toNumber(),i.precisionMultiplierB.toNumber(),i.precisionMultiplierC.toNumber(),i.precisionMultiplierD.toNumber()].slice(0,o),r=[i.tokenAccountA,i.tokenAccountB,i.tokenAccountC,i.tokenAccountD].slice(0,o);return{programId:n,authority:s,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:e,amplificationCoefficient:i.amplificationCoefficient.toNumber(),feeNumerator:i.feeNumerator.toNumber(),tokenAccountsLength:o,precisionFactor:i.precisionFactor.toNumber(),precisionMultipliers:a,tokenAccounts:r}};class Vt{constructor(e,t,n){this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapLayout=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.id=e.toBase58(),this.swapLayout=_t(e,t),this.calculator=new o.Stable(E.default.BigInt(this.swapLayout.tokenAccountsLength),E.default.BigInt(this.swapLayout.amplificationCoefficient),this.swapLayout.precisionMultipliers.map((e=>E.default.BigInt(e))),new o.Fraction(E.default.BigInt(this.swapLayout.feeNumerator),E.default.BigInt(Kt)))}getAccountsForUpdate(){return this.swapLayout.tokenAccounts}update(e){let t=G(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>a.deserializeAccount(e.data))).filter((e=>null!==e))}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const i=this.tokenAccounts.findIndex((t=>t.mint.equals(e))),o=this.tokenAccounts.findIndex((e=>e.mint.equals(t))),s=this.calculator.exchange(Q(this.tokenAccounts),n,i,o),a=this.swapLayout.feeNumerator/Kt;return{notEnoughLiquidity:!1,inAmount:n,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:t.toBase58(),feePct:a,priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({swapLayout:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];for(const t of e.tokenAccounts)o.push({pubkey:t,isSigner:!1,isWritable:!0});return[je({mercurial:{}}),Ye.instruction.mercurialSwap({accounts:$e(e,t,n,i),remainingAccounts:o}).keys]}({swapLayout:this.swapLayout,...e})}get reserveTokenMints(){return this.params.tokenMints.map((e=>new t.PublicKey(e)))}}Vt.decodeSwapLayout=_t;const Wt=new u.Program(P.AmmIdl,P.PROGRAM_ID,Be),Gt=new u.Program(P.VaultIdl,P.PROGRAM_ID,Be),Qt=e=>Wt.coder.accounts.decode("pool",e.data),zt=e=>Gt.coder.accounts.decode("vault",e.data);class jt{constructor(e,n,i){this.address=void 0,this.id=void 0,this.label="Meteora",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.data=void 0,this.depegAccount=void 0,this.depegAccounts=new Map,this.vaultLpMint=void 0,this.vaultToken=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.poolState=Qt(n),this.vaultLpMint={a:new t.PublicKey(i.vaultLpMint.a),b:new t.PublicKey(i.vaultLpMint.b)},this.vaultToken={a:new t.PublicKey(i.vaultToken.a),b:new t.PublicKey(i.vaultToken.b)},i.depegAccount&&(this.depegAccount={...i.depegAccount,pubkey:new t.PublicKey(i.depegAccount.pubkey),data:Buffer.from(i.depegAccount.data[0],i.depegAccount.data[1]),owner:new t.PublicKey(i.depegAccount.owner)},this.depegAccounts=new Map([[this.depegAccount.pubkey.toBase58(),this.depegAccount]]));const{ownerTradeFeeDenominator:o,ownerTradeFeeNumerator:s,tradeFeeDenominator:a,tradeFeeNumerator:r}=this.poolState.fees;this.feePct=new O.default(s.toString()).div(o.toString()).add(new O.default(r.toString()).div(a.toString())).toNumber()}getAccountsForUpdate(){return[this.poolState.aVault,this.poolState.bVault,this.poolState.aVaultLp,this.poolState.bVaultLp,this.poolState.lpMint,this.vaultLpMint.a,this.vaultLpMint.b,this.vaultToken.a,this.vaultToken.b,t.SYSVAR_CLOCK_PUBKEY]}update(e){const[t,n,i,o,s,a,r,u,c,d]=G(e,this.getAccountsForUpdate());this.data={vaultA:zt(t),vaultB:zt(n),poolAVaultLpAmount:Tt(i),poolBVaultLpAmount:Tt(o),poolLpTotalSupply:Pt(s),vaultALpTotalSupply:Pt(a),vaultBLpTotalSupply:Pt(r),vaultAReserve:Tt(u),vaultBReserve:Tt(c),currentTime:new m.BN(d.data.readBigInt64LE(32).toString()).toNumber()}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(void 0===this.data)throw new Error("Unable to fetch accounts.");let i=new m.BN(n.toString());const o=P.calculateSwapQuote(e,i,{currentTime:this.data.currentTime,depegAccounts:this.depegAccounts,poolState:this.poolState,poolVaultALp:this.data.poolAVaultLpAmount,poolVaultBLp:this.data.poolBVaultLpAmount,vaultA:this.data.vaultA,vaultALpSupply:this.data.vaultALpTotalSupply,vaultB:this.data.vaultB,vaultBLpSupply:this.data.vaultBLpTotalSupply,vaultAReserve:this.data.vaultAReserve,vaultBReserve:this.data.vaultBReserve});return{notEnoughLiquidity:!1,inAmount:n,outAmount:E.default.BigInt(o.amountOut.toString()),feeAmount:E.default.BigInt(o.fee.toString()),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:0}}getSwapLegAndAccounts(t){var n,i;if(void 0===this.data)throw new Error("Unable to fetch accounts.");const o=t.sourceMint.equals(this.poolState.tokenAMint)?this.poolState.adminTokenAFee:this.poolState.adminTokenBFee;return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const s=[];return s.push(t.referrer?{pubkey:t.referrer,isSigner:!1,isWritable:!0}:Ze),s.push(t.depeg?{pubkey:t.depeg,isSigner:!1,isWritable:!1}:Ze),[je({meteora:{}}),Ye.instruction.meteoraSwap({accounts:{swapProgram:we,pool:t.pool,userSourceToken:n,userDestinationToken:i,aVault:t.aVault,bVault:t.bVault,aTokenVault:t.aTokenVault,bTokenVault:t.bTokenVault,aVaultLpMint:t.aVaultLpMint,bVaultLpMint:t.bVaultLpMint,aVaultLp:t.aVaultLp,bVaultLp:t.bVaultLp,adminTokenFee:t.adminTokenFee,user:o,vaultProgram:ye,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:s}).keys]}({additionalArgs:{pool:this.address,aVault:this.poolState.aVault,bVault:this.poolState.bVault,aTokenVault:this.vaultToken.a,bTokenVault:this.vaultToken.b,aVaultLpMint:this.vaultLpMint.a,bVaultLpMint:this.vaultLpMint.b,aVaultLp:this.poolState.aVaultLp,bVaultLp:this.poolState.bVaultLp,adminTokenFee:o,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.sourceMint.toBase58()),depeg:null===(i=this.depegAccount)||void 0===i?void 0:i.pubkey},...t})}get reserveTokenMints(){return[this.poolState.tokenAMint,this.poolState.tokenBMint]}}jt.accountInfoToMeteoraSwapLayout=Qt,jt.accountInfoToVaultLayout=zt;const Ht=d.struct([d.nu64("status"),d.nu64("nonce"),d.nu64("orderNum"),d.nu64("depth"),d.nu64("coinDecimals"),d.nu64("pcDecimals"),d.nu64("state"),d.nu64("resetFlag"),d.nu64("minSize"),d.nu64("volMaxCutRatio"),d.nu64("amountWaveRatio"),d.nu64("coinLotSize"),d.nu64("pcLotSize"),d.nu64("minPriceMultiplier"),d.nu64("maxPriceMultiplier"),d.nu64("systemDecimalsValue"),d.nu64("minSeparateNumerator"),d.nu64("minSeparateDenominator"),d.nu64("tradeFeeNumerator"),d.nu64("tradeFeeDenominator"),d.nu64("pnlNumerator"),d.nu64("pnlDenominator"),d.nu64("swapFeeNumerator"),d.nu64("swapFeeDenominator"),d.nu64("needTakePnlCoin"),d.nu64("needTakePnlPc"),d.nu64("totalPnlPc"),d.nu64("totalPnlCoin"),Oe("poolTotalDepositPc"),Oe("poolTotalDepositCoin"),Oe("swapCoinInAmount"),Oe("swapPcOutAmount"),d.nu64("swapCoin2PcFee"),Oe("swapPcInAmount"),Oe("swapCoinOutAmount"),d.nu64("swapPc2CoinFee"),Ee("poolCoinTokenAccount"),Ee("poolPcTokenAccount"),Ee("coinMintAddress"),Ee("pcMintAddress"),Ee("lpMintAddress"),Ee("ammOpenOrders"),Ee("serumMarket"),Ee("serumProgramId"),Ee("ammTargetOrders"),Ee("poolWithdrawQueue"),Ee("poolTempLpTokenAccount"),Ee("ammOwner"),Ee("pnlOwner")]);class Xt{constructor(e,n,i){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=e,this.id=e.toBase58();const s=Ht.decode(n.data);this.status=s.status,this.coinMint=new t.PublicKey(s.coinMintAddress),this.pcMint=new t.PublicKey(s.pcMintAddress),this.poolCoinTokenAccount=new t.PublicKey(s.poolCoinTokenAccount),this.poolPcTokenAccount=new t.PublicKey(s.poolPcTokenAccount),this.serumProgramId=new t.PublicKey(s.serumProgramId),this.serumMarket=new t.PublicKey(s.serumMarket),this.ammOpenOrders=new t.PublicKey(s.ammOpenOrders),this.ammTargetOrders=new t.PublicKey(s.ammTargetOrders),this.serumMarketKeys=Object.keys(i).reduce(((e,n)=>{if(!i[n])throw new Error(`Could not find ${n} in params`);return e[n]=new t.PublicKey(i[n]),e}),{});const a=s.swapFeeNumerator,r=s.swapFeeDenominator;this.feePct=new O.default(a.toString()).div(r.toString()),this.calculator=new o.TokenSwapConstantProduct(new o.Fraction(E.default.BigInt(a),E.default.BigInt(r)),o.ZERO_FRACTION)}static decodeSerumMarketKeysString(e,t,i){const o=n.Market.getLayout(e).decode(i.data),s=Re([t.toBuffer(),o.vaultSignerNonce.toArrayLike(Buffer,"le",8)],e);return{serumBids:o.bids.toBase58(),serumAsks:o.asks.toBase58(),serumEventQueue:o.eventQueue.toBase58(),serumCoinVaultAccount:o.baseVault.toBase58(),serumPcVaultAccount:o.quoteVault.toBase58(),serumVaultSigner:s.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(t){const[i,o,s,a]=G(t,this.getAccountsForUpdate()),[r,u]=[Tt(o),Tt(s)],c=n.OpenOrders.fromAccountInfo(this.ammOpenOrders,a,a.owner),d=Ht.decode(i.data);this.coinReserve=r.add(c.baseTokenTotal).sub(new e.u64(String(d.needTakePnlCoin))),this.pcReserve=u.add(c.quoteTokenTotal).sub(new e.u64(String(d.needTakePnlPc)))}getQuote({sourceMint:e,amount:t}){const{coinReserve:n,pcReserve:i}=this;if(!n||!i)throw new Error("Pool token accounts balances not refreshed or empty");const o=this.coinMint.equals(e)?1:0,s=this.calculator.exchange([E.default.BigInt(n),E.default.BigInt(i)],t,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({raydiumAmm:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){return[je({raydium:{}}),Ye.instruction.raydiumSwap({accounts:tt(e,t,n,i)}).keys]}({raydiumAmm:this,...e})}get reserveTokenMints(){return[this.coinMint,this.pcMint]}}var Yt=[{wrapper:"2B5Qedoo95Pjpv9xVPw82bbmcGDGCNHroKpzQE2CNHRZ",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"3YCGgStAV9H7TdPYdBnRP8yoH4Zqdmyt7xo6KB4Wa8xt",mint:"C9xqJe3gMTUDKidZsZ6jJ7tL9zSLimDUKVpgUbLZnNbi",decimals:9},{wrapper:"2ffwMLE4dxSv59eYXhfhfuS81kz6gzf6DZjdBxRHZz9A",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"H5tnZcfHCzHueNnfd6foeBBUUW4g7qXKt6rKzT7wg6oP",mint:"FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",decimals:9},{wrapper:"3A85wiQg2REhBVxVS1CjDaS333TBNM2g37BbdNGSMheg",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"764FaQrrREvNTpaH2yXyrPZgVBaXA7AXM8vyCaevXitD",mint:"BtX7AfzEJLnU8KQR1AgHrhGH5s2AHUTbfjhUQP8BhPvi",decimals:10},{wrapper:"7hWjnVC6FNkmmgjq88LEnRycrKvxVB1MsJ6FQcrvxe4n",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"B22gDMgN2tNWmvyzhb5tamJKanWcUUUw2zN3h3qjgQg8",mint:"9999j2A8sXUtHtDoQdk528oVzhaKBsXyRGZ67FKGoi7H",decimals:9},{wrapper:"8zooyPZrq2mth917VrHLtNTk6GvAhc2KgdB4DGBXYyke",underlying:"AUrMpCDYYcPuHhyNX8gEEqbmDPFUpBpHrNW3vPeCFn5Z",underlyingDecimals:9,wrapperUnderlyingTokens:"7ZZyhVde6ZmnVMuFnrg3mRPHhvfBixLdEo7RnwxTtpF7",mint:"EY3s4nXTzHDiiysmjvj7zWP6yAX3n4xHmXkJWD1w1tGP",decimals:15},{wrapper:"93qsLbASEG8DmtSB2MEVaa25KvEm2afh5rzbaAJHLi5A",underlying:"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",underlyingDecimals:8,wrapperUnderlyingTokens:"4fUL9yLbFZEuG32SaCjWqJXwDTBFNnipteBWxMvvFoC8",mint:"KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",decimals:9},{wrapper:"ACvLVgR3UKdDB3b1QapsbJsPXaUrBPdJGDfiFnMYMXoz",underlying:"F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W",underlyingDecimals:6,wrapperUnderlyingTokens:"AvqMJWHsZscPWTAUcj8dZi2ch6XQEHMpiCMprfFovaU",mint:"LUNGEjUXyP48nrC1GYY5o4eTAkwm4RdX8BxFUxWJBLB",decimals:9},{wrapper:"AnKLLfpMcceM6YXtJ9nGxYekVXqfWy8WNsMZXoQTCVQk",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"77XHXCWYQ76E9Q3uCuz1geTaxsqJZf9RfX5ZY7yyLDYt",mint:"JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",decimals:9},{wrapper:"CGxMr5UrTjApBjU656N9NBAsGby4fWs1KgVtueQ8WKt6",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"7dVPR6jx3hKyNfuHPo3WtWdUpH4eh4Up4rfFhLHZqwy3",mint:"FTT8cGNp3rfTC6c44uPTuEFLqmsVDhjd2BhH65v2uppr",decimals:8},{wrapper:"D231Uoh24bXtUtWN51ZbFAFSBmGT3zuuEAHZNuCmtRjN",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"C39Wq6X98TLcrnYCMkcHQhwUurkQMUdibUCpf2fVBDsm",mint:"FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",decimals:9},{wrapper:"EhQqUmkUXXnxmV7yA6PDrQWvLgSd9HkrwdDKk1B5m6Tc",underlying:"CbNYA9n3927uXUukee2Hf4tm3xxkffJPPZvGazc2EAH1",underlyingDecimals:8,wrapperUnderlyingTokens:"8YC5eCS99umbK9K9LnHnTMMjnr7EWg1gam5maNB6uf9d",mint:"EU9aLffrTckFCs16da6CppHy63fAxMPF9ih1erQTuuRt",decimals:9},{wrapper:"EwWpia5t9Twiwdi8ghK8e8JHaf6ShNU9jmoYpvdZhBwC",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"9YB1zRL4ETuQFG8ZK1yD4GHBVDmH81EzwuSj75zdnKhK",mint:"UST8SCn7jrqsq51odVLqcmvnC658HkqrKrPL3w2hHQ7",decimals:8},{wrapper:"F9TsAsh5RirU3LqyTJECLQEGXnF4RQT7ckvexCP1KNTu",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"BSTjdztBrsptuxfz9JHS31Wc9CknpLeL1wqZjeVs1Ths",mint:"AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",decimals:9},{wrapper:"FCgoT8RpsopdM5QT6AB98NUfUnDnu7y865MFpRx93JrS",underlying:"EzfgjvkSwthhgHaceR3LnKXUoRkP6NUhfghdaHAj1tUv",underlyingDecimals:8,wrapperUnderlyingTokens:"5yugfArBAUZJJBUCRWPuiLyi6CWp1f67H9xgg3hcgSkx",mint:"FTT9GrHBVHvDeUTgLU8FxVJouGqg9uiWGmmjETdm32Sx",decimals:9},{wrapper:"FDGtFWVhEb1zxnaW2FzogeGDxLoAV7Cu9XdNYPEVwqt",underlying:"8wv2KAykQstNAj2oW6AHANGBiFKVFhvMiyyzzjhkmGvE",underlyingDecimals:6,wrapperUnderlyingTokens:"4R6PmC8BJcPDBsEMGpXpLCnFFkUZhEgZy6pMNtc2LqA4",mint:"KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",decimals:9},{wrapper:"FPuYMuodknZuQKHA8Wp4PBbp52Qu8nK2oAuwedp2WfM3",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"GxpyQZi5VkZDSq5TUycMau11sCkQkVCa8xYhBgiPMsyK",mint:"UST98bfV6EASdTFQrRwCBczpehdMFwYCUdLT5tEbhpW",decimals:9},{wrapper:"Ffxi5TSpFV9NeV5KyNDCC7fWnFoFd2bDcL1eViSAE2M2",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"5s2et753hMXV945U3p5uz6RQqMkZGCPEjKjNPdUcCLLF",mint:"CASHedBw9NfhsLBXq1WNVfueVznx255j8LLTScto3S6s",decimals:8},{wrapper:"G4gRGymKo7MGzGZup12JS39YVCvy8YMM6KY9AmcKi5iw",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"AQhP39mE4o6BYNwnwYqnz7ZobkPBSLpCg8WvEESq1viZ",mint:"88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",decimals:8},{wrapper:"GiLSv94Wwyd6suH57Fu6HjEKsMxhNGfEwKn9vT22me1p",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"3cjAWoyDcco8UVCN17keNUNHoyz37ctgDa7G6zkeb81Y",mint:"T8KdT8hDzNhbGx5sjpEUxepnbDB1TZoCa7vtC5JjsMw",decimals:8},{wrapper:"GpkFF2nPfjUcsavgDGscxaUEQ2hYJ563AXXtU8ohiZ7c",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"6hYDFhZ5ddfzoqaAbzRHm8mzG2MQzYQV9295sQHsvNBV",mint:"SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",decimals:8},{wrapper:"fvSvtHNFuDHrAN82YEyBApRs3U6vUGCLzKGMuPmCaF8",underlying:"2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",underlyingDecimals:6,wrapperUnderlyingTokens:"4JWyJ4ZYsQ8uiYue2tTEqcHcFXrDuaQ1rsyjNFfrZm65",mint:"SL819j8K9FuFPL84UepVcFkEZqDUUvVzwDmJjCHySYj",decimals:8}];function Zt(){return Yt.map((e=>{const n={wrapper:new t.PublicKey(e.wrapper),underlying:new t.PublicKey(e.underlying),underlyingDecimals:e.underlyingDecimals,wrapperUnderlyingTokens:new t.PublicKey(e.wrapperUnderlyingTokens),mint:new t.PublicKey(e.mint),decimals:e.decimals};return new $t(new Jt(n))}))}class Jt{constructor(e){this.addDecimals=void 0,this.multiplier=void 0,this.addDecimals=e,this.multiplier=E.default.BigInt(10**(this.addDecimals.decimals-this.addDecimals.underlyingDecimals))}getOutputAmount(e,t){if(this.addDecimals.mint.equals(t))return this.calculateWithdrawOutputAmount(e);if(this.addDecimals.underlying.equals(t))return this.calculateDepositOutputAmount(e);throw new Error(`unknown input token: ${t.toString()}`)}calculateDepositOutputAmount(e){return E.default.multiply(e,this.multiplier)}calculateWithdrawOutputAmount(e){return E.default.divide(e,this.multiplier)}}class $t{constructor(e){this.wrappedToken=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.wrappedToken=e,this.id=this.wrappedToken.addDecimals.wrapper.toBase58()}getAccountsForUpdate(){return new Array}update(e){}getQuote({sourceMint:e,amount:t}){return{notEnoughLiquidity:!1,inAmount:t,outAmount:this.wrappedToken.getOutputAmount(t,e),feeAmount:o.ZERO,feeMint:e.toBase58(),feePct:0,priceImpactPct:0}}getSwapLegAndAccounts(t){return function({addDecimals:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,deposit:s}){return[je(s?{saberAddDecimalsDeposit:{}}:{saberAddDecimalsWithdraw:{}}),Ye.instruction.saberAddDecimals({accounts:{addDecimalsProgram:te,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:o,userUnderlyingTokens:s?n:i,userWrappedTokens:s?i:n,tokenProgram:e.TOKEN_PROGRAM_ID}}).keys]}({addDecimals:this.wrappedToken.addDecimals,...t,deposit:this.wrappedToken.addDecimals.underlying.equals(t.sourceMint)})}get reserveTokenMints(){return[this.wrappedToken.addDecimals.underlying,this.wrappedToken.addDecimals.mint]}}class en{constructor(e){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenAccounts=[],this.calculator=void 0,this.stableSwap=e,this.id=e.config.swapAccount.toBase58(),this.calculator=new o.Stable(o.TWO,i.calculateAmpFactor(this.stableSwap.state),[o.ONE,o.ONE],new o.Fraction(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(e){let t=G(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=a.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account data");return t}))}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const o=new O.default(this.stableSwap.state.fees.trade.asFraction.toFixed(4)),[s,a]=this.tokenAccounts[0].mint.equals(e)?[0,1]:[1,0];this.calculator.setAmp(i.calculateAmpFactor(this.stableSwap.state));const r=this.calculator.exchange(Q(this.tokenAccounts),n,s,a);return{notEnoughLiquidity:!1,inAmount:n,outAmount:r.expectedOutputAmount,feeAmount:r.fees,feeMint:t.toBase58(),feePct:o.toNumber(),priceImpactPct:r.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({stableSwap:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[je({saber:{}}),Ye.instruction.saberSwap({accounts:it(e,t,n,i,o)}).keys]}({stableSwap:this.stableSwap,...e})}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const tn=d.struct([d.blob(8,"discriminator"),Ee("factory"),d.u8("bump"),Le("index"),Ee("admin"),Ee("token0Reserves"),Ee("token0Mint"),Ee("token0Fees"),Ee("token1Reserves"),Ee("token1Mint"),Ee("token1Fees"),d.u8("isPaused"),Ee("poolMint"),Le("tradeFeeKbps"),Le("withdrawFeeKbps"),Le("adminTradeFeeKbps"),Le("adminWithdrawFeeKbps")]);class nn{constructor(e,t){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.calculator=void 0,this.tokenAccounts=[],this.id=e.toBase58(),this.poolState=((e,t)=>{const n=t.owner,i=tn.decode(t.data);return{programId:n,isPaused:Boolean(i.isPaused),bump:i.bump,ammId:e,token0Reserves:i.token0Reserves,token1Reserves:i.token1Reserves,token0Mint:i.token0Mint,token1Mint:i.token1Mint,token0Fees:i.token0Fees,token1Fees:i.token1Fees,poolMint:i.poolMint,tradeFeeKbps:i.tradeFeeKbps.toNumber()}})(e,t),this.calculator=new o.TokenSwapConstantProduct(new o.Fraction(E.default.BigInt(this.poolState.tradeFeeKbps),E.default.BigInt(1e7)),new o.Fraction(o.ZERO,o.ZERO),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(e){const t=G(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=a.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(e)?1:0;let i=this.calculator.exchange(Q(this.tokenAccounts),t,n),o=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:o,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({poolState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r]=n.equals(t.token0Mint)?[t.token0Reserves,t.token1Reserves]:[t.token1Reserves,t.token0Reserves],[u,c]=n.equals(t.token0Mint)?[t.token0Fees,t.token1Fees]:[t.token1Fees,t.token0Fees];return[je({sencha:{}}),Ye.instruction.senchaSwap({accounts:{swapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.ammId,userAuthority:s,inputUserAccount:i,inputTokenAccount:a,inputFeesAccount:u,outputUserAccount:o,outputTokenAccount:r,outputFeesAccount:c}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}const on=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"];function*sn(e){const t=e.isBids;for(const{key:n,quantity:i}of e.slab.items(t)){const e=E.default.BigInt(n.ushrn(64).toString());yield[e,E.default.BigInt(i.toString())]}}function an(e,t){const n=e._decoded.baseLotSize;return n.isZero()?new O.default(0):function(e,t){const n=new O.default(e.div(t).toString()),i=e.umod(t),o=i.gcd(t);return n.add(new O.default(i.div(o).toString()).div(new O.default(t.div(o).toString())))}(t.mul(e._decoded.quoteLotSize).mul(e._baseSplTokenMultiplier),n.mul(e._quoteSplTokenMultiplier))}class rn{constructor(e){this.market=void 0,this.id=void 0,this.label="Serum",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this._orderbooks=void 0,this.market=e,this.id=e.address.toBase58()}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(e){const[t,i]=G(e,this.getAccountsForUpdate()),o=n.Orderbook.decode(this.market,t.data),s=n.Orderbook.decode(this.market,i.data);this._orderbooks={asks:o,bids:s}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const i=function({market:e,asks:t,bids:n,fromAmount:i,fromMint:s,toMint:a}){const r=on.includes(e.address.toBase58())?1e-4:4e-4;return s.equals(e.quoteMintAddress)&&a.equals(e.baseMintAddress)?function(e,t,n,i){let s=o.ZERO,a=o.ZERO,r=o.ZERO,u=o.ZERO,c=o.ZERO;const d=e.quoteSizeLotsToNumber(new L.default(1));let l=d?E.default.BigInt(new O.default(n.toString()).div(1+i).div(d).floor()):o.ZERO;const m=E.default.BigInt(e.baseSizeLotsToNumber(new L.default(1)).toString());for(let[e,n]of sn(t)){E.default.equal(a,o.ZERO)&&(a=e),r=e;const t=E.default.multiply(n,m),i=E.default.multiply(n,e);if(c=E.default.add(c,t),E.default.greaterThanOrEqual(i,l)){const t=E.default.divide(l,e);u=E.default.add(u,E.default.multiply(e,t)),s=E.default.add(s,E.default.multiply(m,t)),l=o.ZERO;break}u=E.default.add(u,E.default.multiply(e,n)),s=E.default.add(s,t),l=E.default.subtract(l,i)}const p=new O.default(a.toString()),g=new O.default(r.toString()).sub(p).div(p).toNumber(),h=an(e,new L.default(a.toString())),f=an(e,new L.default(u.toString())),S=f.mul(m.toString()).ceil(),A=f.mul(m.toString()).mul(i).ceil();return{side:"buy",notEnoughLiquidity:E.default.lessThanOrEqual(c,s),minimum:{in:E.default.BigInt(h.mul(m.toString()).mul(1+i).ceil()),out:m},inAmount:E.default.BigInt(S.add(A)),outAmount:s,feeAmount:E.default.BigInt(A),priceImpactPct:g,feePct:i}}(e,t,i,r):function(e,t,n,i){let s=E.default.BigInt(0),a=E.default.BigInt(0),r=E.default.BigInt(0),u=E.default.BigInt(0),c=n,d=E.default.BigInt(0);const l=E.default.BigInt(e.baseSizeLotsToNumber(new L.default(1))),m=E.default.BigInt(e.quoteSizeLotsToNumber(new L.default(1)));for(const[e,n]of sn(t)){E.default.equal(a,o.ZERO)&&(a=e),r=e;const t=E.default.multiply(l,n),i=E.default.multiply(n,E.default.multiply(e,m));if(u=E.default.add(u,t),E.default.greaterThanOrEqual(t,c)){const t=E.default.divide(c,l),n=E.default.multiply(t,e);s=E.default.add(s,E.default.multiply(n,m)),c=E.default.subtract(c,n),d=E.default.add(d,E.default.multiply(t,l));break}s=E.default.add(s,i),c=E.default.subtract(c,t),d=E.default.add(d,t)}let p=new O.default(s.toString()).mul(1-i).floor();const g=an(e,new L.default(a.toString())),h=an(e,new L.default(r.toString())),f=g.minus(h).div(g).toNumber();return{side:"sell",notEnoughLiquidity:E.default.greaterThan(E.default.BigInt(n),u),minimum:{in:l,out:E.default.BigInt(g.mul(E.default.toNumber(l)).mul(1-i).floor().toString())},inAmount:d,outAmount:E.default.BigInt(p),feeAmount:E.default.BigInt(new O.default(s.toString()).mul(i).round()),priceImpactPct:f,feePct:i}}(e,n,i,r)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:e,toMint:t,fromAmount:n});return{notEnoughLiquidity:i.notEnoughLiquidity,minInAmount:i.minimum.in,minOutAmount:i.minimum.out,inAmount:i.inAmount,outAmount:i.outAmount,feeAmount:i.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:i.feePct,priceImpactPct:i.priceImpactPct}}getSwapLegAndAccounts(e){var t;if(!e.openOrdersAddress)throw new Error("Missing open orders");return function({market:e,sourceMint:t,openOrdersAddress:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s,referrer:a}){const{side:r,coinWallet:u,pcWallet:c}=t.equals(e.baseMintAddress)?{side:Ke.Ask,coinWallet:i,pcWallet:o}:{side:Ke.Bid,coinWallet:o,pcWallet:i};return[je(Ue(r)),Ye.instruction.serumSwap({accounts:nt(e,n,i,u,c,s),remainingAccounts:a?[{pubkey:a,isSigner:!1,isWritable:!0}]:[Ze]}).keys]}({market:this.market,openOrdersAddress:e.openOrdersAddress,referrer:null==e||null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(this.market.quoteMintAddress.toBase58()),...e})}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}rn.getL2=sn;const un=d.struct([d.u8("version"),d.u8("isInitialized"),d.u8("bumpSeed"),Ee("tokenProgramId"),Ee("tokenAccountA"),Ee("tokenAccountB"),Ee("tokenPool"),Ee("mintA"),Ee("mintB"),Ee("feeAccount"),Le("tradeFeeNumerator"),Le("tradeFeeDenominator"),Le("ownerTradeFeeNumerator"),Le("ownerTradeFeeDenominator"),Le("ownerWithdrawFeeNumerator"),Le("ownerWithdrawFeeDenominator"),Le("hostFeeNumerator"),Le("hostFeeDenominator"),d.u8("curveType"),d.blob(32,"curveParameters")]),cn=d.struct([d.u8("version"),d.u8("isInitialized"),d.u8("bumpSeed"),Ee("tokenProgramId"),Ee("tokenAccountA"),Ee("tokenAccountB"),Ee("tokenPool"),Ee("mintA"),Ee("mintB"),Ee("feeAccount"),Le("tradeFeeNumerator"),Le("tradeFeeDenominator"),Le("ownerTradeFeeNumerator"),Le("ownerTradeFeeDenominator"),Le("ownerWithdrawFeeNumerator"),Le("ownerWithdrawFeeDenominator"),d.u8("curveType"),d.blob(32,"curveParameters"),d.u8("poolNonce")]);var dn;!function(e){e[e.ConstantProduct=0]="ConstantProduct",e[e.Stable=2]="Stable"}(dn||(dn={}));class ln{constructor(e,n,i){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.tokenAccounts=[],this.calculator=void 0,this.label=i,this.id=e.toBase58(),this.tokenSwapState=function(e,n){const i=n.owner,o=i.equals(Se)?cn.decode(n.data):un.decode(n.data);if(!o.isInitialized)throw new Error("Invalid token swap state");const s=Re([e.toBuffer(),Buffer.from([o.bumpSeed])],i),a=new t.PublicKey(o.tokenPool),r=new t.PublicKey(o.feeAccount),u=new t.PublicKey(o.tokenAccountA),c=new t.PublicKey(o.tokenAccountB),d=new t.PublicKey(o.mintA),l=new t.PublicKey(o.mintB);return{address:e,programId:i,tokenProgramId:new t.PublicKey(o.tokenProgramId),poolToken:a,feeAccount:r,authority:s,tokenAccountA:u,tokenAccountB:c,mintA:d,mintB:l,tradeFeeNumerator:o.tradeFeeNumerator,tradeFeeDenominator:o.tradeFeeDenominator,ownerTradeFeeNumerator:o.ownerTradeFeeNumerator,ownerTradeFeeDenominator:o.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:o.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:o.ownerWithdrawFeeDenominator,curveType:o.curveType,curveParameters:o.curveParameters,poolNonce:"poolNonce"in o?o.poolNonce:void 0}}(e,n),this.curveType=this.tokenSwapState.curveType,!(this.curveType in dn))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);this.calculator=this.tokenSwapState.curveType===dn.ConstantProduct?new o.TokenSwapConstantProduct(new o.Fraction(E.default.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),E.default.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new o.Fraction(E.default.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),E.default.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()))):new o.TokenSwapStable(E.default.BigInt(this.tokenSwapState.curveParameters[0]),new o.Fraction(E.default.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),E.default.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new o.Fraction(E.default.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),E.default.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString())))}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(e){const t=G(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=a.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new O.default(this.tokenSwapState.tradeFeeNumerator.toString()).div(this.tokenSwapState.tradeFeeDenominator.toString()).add(new O.default(this.tokenSwapState.ownerTradeFeeNumerator.toString()).div(this.tokenSwapState.ownerTradeFeeDenominator.toString()));const i=this.tokenAccounts[0].mint.equals(e)?1:0;let o=this.calculator.exchange(Q(this.tokenAccounts),t,i);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({tokenSwapState:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s,isStep:a}){const[r,u]=n.equals(t.mintA)?[t.tokenAccountA,t.tokenAccountB]:[t.tokenAccountB,t.tokenAccountA];return[je(a?{step:{}}:{tokenSwap:{}}),(a?Ye.instruction.stepSwap:Ye.instruction.tokenSwap)({accounts:{tokenSwapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.address,authority:t.authority,userTransferAuthority:s,source:i,swapSource:r,swapDestination:u,destination:o,poolMint:t.poolToken,poolFee:t.feeAccount}}).keys]}({tokenSwapState:this.tokenSwapState,...t,isStep:this.tokenSwapState.programId.equals(Se)})}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}function mn(e){return e.reduce(((t,n)=>(e.forEach((e=>{n!==e&&t.push([n,e])})),t)),new Array)}const pn=E.default.BigInt(100);class gn{constructor(e,t,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.portion1=0,this.portion2=0,this.firstAmm=e,this.secondAmm=t,this.reserveTokenMints=n,this.market=e instanceof rn?e.market:t instanceof rn?t.market:null}static getAmmIdsFromSplitTradeAmmId(e){const t=e.split("-");return t.length>1?t:[]}static create(e,t){if(!function(e,t){return!U(q,e.label,t.label)}(e,t))return;const n=mn(e.reserveTokenMints),i=mn(t.reserveTokenMints);for(const o of n)for(const n of i)if(o.every(((e,t)=>e.equals(n[t]))))return new gn(e,t,o)}setPortions(e,t){if(e+t!==100)throw new Error("Split trade portions must sum to 100");this.portion1=e,this.portion2=t}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((e,t)=>t.portion-e.portion)).map((({label:e,portion:t})=>`${e} (${t}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(e){}getQuote(e){const t=e.sourceMint.toBase58(),n=e.amount;let i={outAmount:o.ZERO,portion:0,firstQuote:void 0,secondQuote:void 0};for(let t=100;t-=5;t>0){const o=E.default.divide(E.default.multiply(n,E.default.BigInt(t)),pn),s=E.default.subtract(n,o),a=this.firstAmm.getQuote({...e,amount:o}),r=this.secondAmm.getQuote({...e,amount:s}),u=E.default.add(a.outAmount,r.outAmount);if(E.default.lessThan(u,i.outAmount))break;i={outAmount:u,portion:t,firstQuote:a,secondQuote:r}}if(!i.firstQuote||!i.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:s,portion:a,firstQuote:r,secondQuote:u}=i,c=a,d=100-c;this.portion1=c,this.portion2=d;let l={amount:r.feeAmount,mint:r.feeMint},m={amount:u.feeAmount,mint:u.feeMint};l.mint!==m.mint&&(l.mint!==t&&(l={amount:E.default.divide(E.default.divide(E.default.multiply(l.amount,E.default.multiply(n,E.default.BigInt(c))),pn),i.outAmount),mint:t}),m.mint!==t&&(m={amount:E.default.divide(E.default.divide(E.default.multiply(E.default.multiply(m.amount,n),E.default.BigInt(d)),pn),i.outAmount),mint:t}));const p=(c*r.feePct+d*u.feePct)/100,g=(c*r.priceImpactPct+d*u.priceImpactPct)/100;return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:s,feeAmount:E.default.add(l.amount,m.amount),feeMint:l.mint,feePct:p,priceImpactPct:g}}getSwapLegAndAccounts(e){let[t,n]=this.firstAmm.getSwapLegAndAccounts(e),[i,o]=this.secondAmm.getSwapLegAndAccounts(e),s=[He(this.portion1,t),He(this.portion2,i)],a=[...n,...o];return[ze(s),a]}}function hn(e,t){const n=v.parseWhirlpool(t);if(!n)throw new Error(`Failed to parse whirlpool ${e.toBase58()}`);return n}class fn{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.hasDynamicAccounts=!0,this.whirlpoolData=void 0,this.tickArrays=new Map,this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.whirlpoolData=hn(e,t.data),this.oracle=c.findProgramAddressSync([Buffer.from("oracle"),e.toBuffer()],ue)[0],this.feePct=new O.default(this.whirlpoolData.feeRate).div(1e6),this.tickPks=v.getTickArrayPks(e,this.whirlpoolData)}getAccountsForUpdate(){return[this.address,...this.tickPks]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=hn(this.address,t.data),this.tickPks=v.getTickArrayPks(this.address,this.whirlpoolData),this.tickArrays.clear();for(const t of this.tickPks){const n=t.toBase58(),i=e.get(n);if(!i)continue;const o=v.parseTickArray(i.data);if(!o)throw new Error(`Could not parse tick array ${n}`);this.tickArrays.set(n,o)}}getQuote({sourceMint:e,destinationMint:t,amount:n,swapMode:i}){const o=v.getSwapQuote({poolAddress:this.address,whirlpool:this.whirlpoolData,tickArrays:this.tickArrays,tokenMint:i===exports.SwapMode.ExactIn?e:t,tokenAmount:new L.default(n.toString()),isInput:i===exports.SwapMode.ExactIn}),s=E.default.BigInt(o.amountIn.toString()),a=E.default.BigInt(o.amountOut.toString()),r=E.default.BigInt(this.feePct.mul(s.toString()).floor().toString()),u=o.aToB?new O.default(o.amountOut.toString()).div(o.amountIn.toString()):new O.default(o.amountIn.toString()).div(o.amountOut.toString()),c=(d=this.whirlpoolData.sqrtPrice,new O.default(d.toString()).mul(O.default.pow(2,-64))).pow(2);var d;const l=c.minus(u).div(c).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:s,outAmount:a,feeAmount:r,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:Number(l)}}getSwapLegAndAccounts(t){const n=t.sourceMint.equals(this.whirlpoolData.tokenMintA),i=v.getDefaultSqrtPriceLimit(n),[o,s,a]=v.getTickArrayPublicKeysForSwap(this.whirlpoolData.tickCurrentIndex,i,this.whirlpoolData.tickSpacing,this.address,this.tickArrays,ue,n);return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a]=t.aToB?[n,i]:[i,n];return[je(We(t.aToB)),Ye.instruction.whirlpoolSwap({accounts:{swapProgram:ue,tokenProgram:e.TOKEN_PROGRAM_ID,tokenAuthority:o,whirlpool:t.whirlpool,tokenOwnerAccountA:s,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:a,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle}}).keys]}({additionalArgs:{aToB:n,whirlpool:this.address,tickArray0:o,tickArray1:s,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...t})}createExactOutSwapInstruction(t){const n=t.sourceMint.equals(this.whirlpoolData.tokenMintA),i=v.getDefaultSqrtPriceLimit(n),[o,s,a]=v.getTickArrayPublicKeysForSwap(this.whirlpoolData.tickCurrentIndex,i,this.whirlpoolData.tickSpacing,this.address,this.tickArrays,ue,n);return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,outAmount:s,inAmount:a,slippageBps:r,platformFee:u,overflowFeeAccount:c}){var d;const[l,m]=t.aToB?[n,i]:[i,n];return Ye.instruction.whirlpoolSwapExactOutput(s,{amount:a,slippageBps:r},t.aToB,null!==(d=null==u?void 0:u.feeBps)&&void 0!==d?d:0,{accounts:{swapProgram:ue,tokenProgram:e.TOKEN_PROGRAM_ID,tokenAuthority:o,whirlpool:t.whirlpool,tokenOwnerAccountA:l,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:m,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle},remainingAccounts:ot(null==u?void 0:u.feeAccount,c)})}({additionalArgs:{aToB:n,whirlpool:this.address,tickArray0:o,tickArray1:s,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...t,outAmount:new L.default(t.amount.toString()),inAmount:new L.default(t.inAmount.toString()),slippageBps:t.slippageBps,platformFee:t.platformFee,overflowFeeAccount:t.overflowFeeAccount})}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}const Sn=({amms:e,enforceSingleTx:t})=>{const[n,i]=e;return n.id!==i.id&&!U(t?C:q,n.label,i.label)&&!(n instanceof gn||i instanceof gn)},An=new Map([[fe.toString(),"Orca"],[Se.toString(),"Step"],[Ae.toString(),"Penguin"],[ke.toString(),"Saros"],[he.toString(),"Stepn"]]),kn={};function wn(e){const t=e._bn.toString(),n=kn[t];if(n)return n;{const n=e.toBase58();return kn[t]=n,n}}function yn(e,t,n){return Boolean(e&&t>100&&!e.includes(n))}function Mn(e,t){if(e===exports.SwapMode.ExactOut)return!1;if(t.length>1){const[e,n]=t;if(e instanceof Xt&&n instanceof Xt)return!1}return!0}const Tn=e=>t.ComputeBudgetProgram.setComputeUnitLimit({units:Math.min(e,14e5)});async function Pn({connection:n,amount:i,owner:{publicKey:o}}){const s={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},a=await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,H,o,!0);return null===await n.getAccountInfo(a)&&s.setupInstructions.push(vn(o,a,o,H)),s.setupInstructions.push(t.SystemProgram.transfer({fromPubkey:o,toPubkey:a,lamports:E.default.toNumber(i)})),s.setupInstructions.push(e.Token.createSyncNativeInstruction(e.TOKEN_PROGRAM_ID,a)),s.cleanupInstructions=[e.Token.createCloseAccountInstruction(e.TOKEN_PROGRAM_ID,a,o,o,[])],{address:a,...s}}function vn(n,i,o,s,a=e.TOKEN_PROGRAM_ID,r=e.ASSOCIATED_TOKEN_PROGRAM_ID){return new t.TransactionInstruction({keys:[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:t.SystemProgram.programId,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}],programId:r,data:Buffer.alloc(0)})}async function bn({connection:n,marketInfos:i,owner:o,unwrapSOL:s}){const r=await Promise.all(i.map((({outputMint:i})=>async function({connection:n,payer:i,owner:{publicKey:o},mintAddress:s,unwrapSOL:r}){const u="string"==typeof s?new t.PublicKey(s):s,c=await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,u,o,!0),d={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},l=await n.getAccountInfo(c);if(null===l)d.setupInstructions.push(vn(i,c,o,u));else{const e=a.deserializeAccount(l.data);if(e&&!e.owner.equals(o))throw new Error(`/! ATA ${c.toBase58()} is not owned by ${o.toBase58()}`)}return u.equals(H)&&r&&d.cleanupInstructions.push(e.Token.createCloseAccountInstruction(e.TOKEN_PROGRAM_ID,c,o,o,[])),{address:c,...d}}({connection:n,payer:o.publicKey,owner:o,mintAddress:i,unwrapSOL:s})))),[u]=r.splice(r.length-1,1);return{userIntermediaryTokenAccountResults:r,userDestinationTokenAccountResult:u}}async function In(e,n,i,o){const s={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},a=i.address.toString();if(o){let t=o.get(a);if(t){let n=null;if(n=await e.getAccountInfo(t,"confirmed"),n)return{...s,address:t}}}const[r,u]=function(e,n){const[i]=c.findProgramAddressSync([Buffer.from("open_orders"),e.publicKey.toBuffer(),n.toBuffer()],Xe);return[i,Ye.instruction.createOpenOrders({accounts:{openOrders:i,payer:n,dexProgram:e.programId,systemProgram:t.SystemProgram.programId,rent:t.SYSVAR_RENT_PUBKEY,market:e.publicKey}})]}(i,n);return await e.getAccountInfo(r)||(s.setupInstructions=[u]),null==o||o.set(i.address.toString(),r),{...s,address:r}}function Bn(e){return e.reduce(((e,t)=>t+e),0)}const Dn={feeBps:0,feeAccounts:new Map};async function En(t,n){return(await t.getTokenAccountsByOwner(n,{programId:e.TOKEN_PROGRAM_ID})).value.reduce(((e,t)=>{const n=a.deserializeAccount(t.account.data);return n&&e.set(n.mint.toBase58(),t.pubkey),e}),new Map)}class Fn{constructor(e,t,n){this.connection=void 0,this.feePayer=void 0,this.instructions=void 0,this.owner=void 0,this.connection=e,this.feePayer=t,this.instructions=[],this.owner=n}addInstruction(e){return this.instructions.push(e),this}async build(e){e||(e=await this.connection.getLatestBlockhash("confirmed"));const n={...e,feePayer:this.feePayer};let i=[],o=[],s=[],a=[];this.instructions.forEach((e=>{o=o.concat(e.setupInstructions),i=i.concat(e.instructions),s=s.concat(e.cleanupInstructions),a=a.concat(e.signers)}));const r=new t.Transaction(n);return o.concat(i).concat(s).forEach((e=>r.add(e))),r.feePayer=this.feePayer,{transaction:r,signers:a,execute:this.owner.isKeyPair?()=>this.connection.sendTransaction(r,a):async()=>{throw new Error("Please use a Keypair for the owner parameter to enable the execute function")}}}}class Ln{constructor(e){this._owner=void 0,this._owner=e}get publicKey(){return Ln.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ln.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ln.isKeyPair(this._owner)}get isPublicKey(){return Ln.isPublicKey(this._owner)}static isKeyPair(e){return void 0!==e.secretKey}static isPublicKey(e){return!Ln.isKeyPair(e)}}const On=e=>new Promise((t=>setTimeout(t,e)));function Rn(e,t,n){if(e)return function(e,t){var n,i,o,s;const a=null===(n=t.postTokenBalances)||void 0===n||null===(i=n.find((t=>t.accountIndex===e)))||void 0===i?void 0:i.uiTokenAmount.amount,r=null===(o=t.preTokenBalances)||void 0===o||null===(s=o.find((t=>t.accountIndex===e)))||void 0===s?void 0:s.uiTokenAmount.amount;if(a)return Math.abs(parseInt(a)-(void 0!==r?parseInt(r):0))}(t.message.accountKeys.findIndex((e=>e.equals(n))),e)}function qn(e,t,n){let i=t.message.accountKeys.findIndex((e=>e.equals(n)));return-1!==i?Math.abs(e.postBalances[i]-e.preBalances[i]):0}function xn(){return(new Date).getTime()}const Nn={skipPreflight:!0,maxRetries:2};async function Cn(e,t,n=12e4,i=500,o=2e3,s=40){const a=t.serialize(),r=await e.sendRawTransaction(a,Nn),u=xn();let c=xn(),d=0;for(;xn()-u<n;){const t=xn();d<s&&t-c>o&&(c=t,d+=1,await e.sendRawTransaction(a,Nn));const n=await Promise.any([e.getTransaction(r,{commitment:"confirmed"}),On(5e3)]);if(n)return{txid:r,transactionResponse:n};await On(i)}return{txid:r,transactionResponse:null}}function Kn(e){const t=e.signature;if(!t)throw new Error("Transaction has no signature");return I.bs58.encode(t)}const Un=function(e){if(!Array.isArray(e))throw new TypeError(`Argument must be an array: ${e}`)},_n=function(e,t){return e*t.length},Vn={},Wn=function(e,t){return String(t)},Gn=E.default.BigInt(1e4);function Qn({inputMint:e,outputMint:t}){return`${e}-${t}`}function zn({ammId:e,amount:t}){return`${e}-${t.toString()}`}function jn({inputRouteSegment:e,inputMint:n,outputMint:i,amount:s,getDepositAndFeeForRoute:a,platformFeeBps:r,slippageBps:u,filterTopNResult:c=2,onlyDirectRoutes:d,swapMode:l,enforceSingleTx:m}){const p=n.toBase58(),g=i.toBase58();if(!e.get(p))throw new Error("No routes found for the input and output mints");const h=d?0:2,f=new Map,S=[],A=new Map;return function n({inputMint:i,amount:s,level:a=0,walked:r=[i]}){const u=e.get(i);u&&u.forEach(((p,k)=>{const w=Qn({inputMint:i,outputMint:k}),y=function({amms:e,inputMint:n,outputMint:i,amount:s,swapMode:a}){return e.map((e=>{try{return{quote:e.getQuote({amount:s,sourceMint:new t.PublicKey(n),destinationMint:new t.PublicKey(i),swapMode:a}),amm:e}}catch(e){return}})).filter(Boolean).sort(((e,t)=>E.default.greaterThanOrEqual((null==t?void 0:t.quote.outAmount)||o.ZERO,(null==e?void 0:e.quote.outAmount)||o.ZERO)?1:-1))}({amms:p,inputMint:i,outputMint:k,amount:s,swapMode:l}),{filteredAmms:M,quoteMap:T}=y.reduce(((e,t,n)=>(n<c&&e.filteredAmms.push(t.amm),e.quoteMap.set(zn({ammId:t.amm.id,amount:s}),t.quote),e)),{filteredAmms:[],quoteMap:new Map}),P=[];if(k!==g||d||function(e,t){for(let n=0;n<e.length;n++)for(let i=n+1;i<e.length;i++)e[n].label!==e[i].label&&t(e[n],e[i])}(M.slice(),((e,t)=>{const n=(()=>{if(!m||!1!==Sn({amms:[e,t],enforceSingleTx:m}))return gn.create(e,t)})();n&&P.push(n)})),u.set(k,M.concat(P)),f.set(w,T),k!==g&&T.size&&!r.includes(k)&&a<h-1){var v;const e=T.values().next().value.outAmount,t=null!==(v=A.get(k))&&void 0!==v?v:o.ZERO;E.default.greaterThan(e,t)&&(A.set(k,e),n({inputMint:k,amount:e,level:a+1,walked:r.concat(k)}))}else if(k===g){0===a&&u.set(k,y.map((e=>e.amm)).concat(P));const n=r.concat(k),i=n.map((e=>new t.PublicKey(e))),o=n.reduce(((t,i,o)=>{var s;return o<n.length-1&&t.push(null===(s=e.get(n[o]))||void 0===s?void 0:s.get(n[o+1])),t}),[]),s=function(e){if(function(e){if(!Array.isArray(e))throw new TypeError("Argument must be an array of arrays");e.forEach(Un),function({length:e}){if(e>=100)throw new TypeError(`Too many arrays (${e}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)}(e),function(e){const t=e.reduce(_n,1);if(t>=4294967296){const e=Number.isFinite(t)?` (${t.toExponential(0)})`:"";throw new TypeError(`Too many combinations${e}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}}(e)}(e),0===e.length)return[];const t=[];return function(e){const t=Vn[e];if(void 0!==t)return t;const n=function(e){const t=Array.from({length:e},Wn),n=t.map((e=>`for (const value${e} of arrays[${e}]) {`)).join("\n"),i=t.map((e=>`value${e}`)).join(", "),o="}\n".repeat(e);return new Function("arrays","result",`${n}\nresult.push([${i}])\n${o}`)}(e);return Vn[e]=n,n}(e.length)(e,t),t}(o);for(let e of s)(1===e.length||Sn({amms:e,enforceSingleTx:m}))&&S.push({amms:e,mints:i})}}))}({inputMint:p,amount:s}),S.map((e=>{const{amms:t,mints:n}=e;let i=[],c=s,d=o.ZERO;const m=Mn(l,t),p=n,g=t.length;for(const[e,n]of t.entries())try{var h;const t=p[e],a=p[e+1],S=Qn({inputMint:t.toBase58(),outputMint:a.toBase58()}),A=null===(h=f.get(S))||void 0===h?void 0:h.get(zn({ammId:n.id,amount:c}));if(E.default.equal(c,o.ZERO))return;const k=A||n.getQuote({sourceMint:t,destinationMint:a,amount:c,swapMode:l}),w=g-1===e&&m?{amount:E.default.divide(E.default.multiply(k.outAmount,E.default.BigInt(r)),Gn),mint:a.toBase58(),pct:r/100}:{amount:o.ZERO,mint:a.toBase58(),pct:0},y=l===exports.SwapMode.ExactIn?k.outAmount:k.inAmount;let M=l===exports.SwapMode.ExactIn?E.default.subtract(y,w.amount):E.default.add(y,w.amount);E.default.lessThan(M,o.ZERO)&&(M=o.ZERO);const T=E.default.BigInt(l===exports.SwapMode.ExactIn?new O.default(M.toString()).mul(1-u/E.default.toNumber(Gn)).ceil():new O.default(M.toString()).mul(1+u/E.default.toNumber(Gn)).floor()),[P,v]=l===exports.SwapMode.ExactIn?[k.inAmount,M]:[M,c];i.push({amm:n,inputMint:t,outputMint:a,notEnoughLiquidity:k.notEnoughLiquidity,minInAmount:k.minInAmount,minOutAmount:k.minOutAmount,inAmount:P,outAmount:v,priceImpactPct:k.priceImpactPct,lpFee:{amount:k.feeAmount,mint:k.feeMint,pct:k.feePct},platformFee:w}),c=l===exports.SwapMode.ExactIn?M:s,d=T}catch(e){return}return{marketInfos:i,getDepositAndFee:()=>a({marketInfos:i}),inAmount:i[0].inAmount,outAmount:c,amount:s,otherAmountThreshold:d,swapMode:l,slippageBps:u,priceImpactPct:1-i.reduce(((e,t)=>e*(1-t.priceImpactPct)),1)}})).filter((e=>void 0!==e)).sort(((e,t)=>E.default.greaterThanOrEqual(t.outAmount,e.outAmount)?1:-1))}const Hn=Object.values(Ie).reduce(((e,t)=>(e[t.code]=t,e)),{});async function Xn({txid:e,transactionResponse:t}){var n;if(!t)return new a.TransactionError("Transaction was not confirmed",e);if(null!=t&&null!==(n=t.meta)&&void 0!==n&&n.err){let{message:n,programId:o,code:s}=a.parseErrorForTransaction(t);var i;return o===Xe.toBase58()&&s&&(n=null===(i=Hn[s])||void 0===i?void 0:i.msg),n||(n=a.UNKNOWN_ERROR),new a.TransactionError(n||"",e,s)}return t}function Yn(e,t){let n=t.get(e);return void 0===n&&(n=t.size,t.set(e,n)),n}function Zn(e){const t=t=>e.mintKeys[t],n=new Map;return Object.keys(e.indexedRouteMap).forEach((i=>{n.set(t(i),e.indexedRouteMap[i].map((e=>t(e))))})),n}class Jn{constructor(t,n,i,o,s,a,r=0,u=!0,c,d){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.getDepositAndFees=async({marketInfos:e,userPublicKey:t,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>(async({connection:e,owner:t,inputMint:n,marketInfos:i,feeCalculator:o,serumOpenOrdersPromise:s,wrapUnwrapSOL:a})=>{const r=n.equals(H)&&a,u=await Promise.all(i.map((async n=>{const i=n.amm;if(i instanceof rn||i instanceof gn){if(!i.market)return;return await In(e,t.publicKey,i.market,await s)}}))),{userIntermediaryTokenAccountResults:c,userDestinationTokenAccountResult:d}=await bn({connection:e,marketInfos:i,owner:t,unwrapSOL:a});return(({intermediates:e,destination:t,openOrders:n,hasWrapUnwrapSOL:i,feeCalculator:o})=>{const s=n.filter((e=>e&&e.instructions.length>0)).map((()=>23352760)),a=[...e,t].filter((e=>(null==e?void 0:e.instructions.length)&&0===e.cleanupInstructions.length)).map((()=>2039280)),r=([...null==n?void 0:n.map((e=>null==e?void 0:e.signers)),...null==e?void 0:e.map((e=>e.signers)),t.signers].flat().length+1)*o.lamportsPerSignature;return{signatureFee:r,openOrdersDeposits:s,ataDeposits:a,totalFeeAndDeposits:Bn([r,...s,...a]),minimumSOLForTransaction:Bn([r,...s,...a,i?2039280:0])}})({intermediates:c,destination:d,openOrders:u,hasWrapUnwrapSOL:r,feeCalculator:o})})({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:e[0].inputMint,marketInfos:e,serumOpenOrdersPromise:n,owner:new Ln(t),wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:e})=>{if(this.user&&this.serumOpenOrdersPromise){const t=new Ln(this.user);return this.getDepositAndFees({marketInfos:e,userPublicKey:t.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:t,userPublicKey:n,feeAccount:i,wrapUnwrapSOL:o,blockhashWithExpiryBlockHeight:s})=>{var a;const{connection:r,serumOpenOrdersPromise:u}=this,c=n||this.user;if(!c)throw new Error("user not found");const d=new Ln(c),l=t.marketInfos.length-1,p=t.marketInfos[0].inputMint,g=t.marketInfos[l].outputMint,h=null!=o?o:this.wrapUnwrapSOL,[f,S,A]=await Promise.all([p.equals(H)&&h?Pn({connection:r,owner:d,amount:t.swapMode===exports.SwapMode.ExactIn?t.amount:t.otherAmountThreshold}):e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,p,d.publicKey,!0).then((e=>({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[],address:e}))),bn({connection:r,marketInfos:t.marketInfos,owner:d,unwrapSOL:h}),Promise.all(t.marketInfos.map((async({amm:e})=>{if(e instanceof rn||e instanceof gn){if(!e.market)return;return await In(r,d.publicKey,e.market,await u)}})))]),k={intermediates:S.userIntermediaryTokenAccountResults,destination:S.userDestinationTokenAccountResult,openOrders:A},w=k.openOrders.filter(Boolean).length>0,y=(i=null!==(a=i)&&void 0!==a?a:t.swapMode===exports.SwapMode.ExactIn?this.platformFeeAndAccounts.feeAccounts.get(g.toBase58()):this.platformFeeAndAccounts.feeAccounts.get(p.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*t.marketInfos[l].platformFee.pct),feeAccount:i}:void 0,M=await async function({user:e,openOrdersAddresses:t,userSourceTokenAccountAddress:n,userIntermediateTokenAccountAddresses:i,userDestinationTokenAccountAddress:o,routeInfo:s,platformFee:a,quoteMintToReferrer:r}){if(s.marketInfos.length-1!==i.length)throw new Error("Missing intermediary token account address");const u=a&&function(e){if(e.length<2)return!1;const[t,n]=e.map((e=>e.amm));return t instanceof Xt&&n instanceof rn||t instanceof rn&&n instanceof Xt}(s.marketInfos)?void 0:r,c=[n,...i,o],d=!!a&&a.feeBps>0&&Mn(s.swapMode,s.marketInfos.map((e=>e.amm))),l=e.publicKey,p=[],g=[];if(s.swapMode===exports.SwapMode.ExactIn){const{requireComputeBudget:e,swapInstruction:n}=function(e,t,n,i,o,s,a,r){let u=!1;const c=[],d=[];for(const[t,i]of e.marketInfos.entries()){const r=i.amm,[l,m]=o.slice(t),[p,g]=r.getSwapLegAndAccounts({sourceMint:i.inputMint,destinationMint:i.outputMint,userSourceTokenAccount:l,userDestinationTokenAccount:m,userTransferAuthority:n,openOrdersAddress:s[t],quoteMintToReferrer:a,swapMode:e.swapMode,amount:e.amount});c.push(p),d.push(...g),!1===u&&(u=i.amm instanceof gn?U(N,i.amm.firstAmm.label,i.amm.secondAmm.label):U(N,i.amm.label))}return t&&r&&d.push({pubkey:r.feeAccount,isWritable:!0,isSigner:!1}),{requireComputeBudget:u,swapInstruction:Je(n,i,Qe(c),d,new m.BN(e.amount.toString()),new m.BN(e.outAmount.toString()),e.slippageBps,t&&r?r.feeBps:0)}}(s,d,l,o,c,t,u,a);e&&p.push(Tn(14e5)),g.push(n)}else if(s.swapMode===exports.SwapMode.ExactOut){const{requireComputeBudget:e,swapInstruction:t}=function(e,t,n,i,o,s){const a=e.marketInfos[0],r=a.amm;if(r.createExactOutSwapInstruction)return{requireComputeBudget:!1,swapInstruction:r.createExactOutSwapInstruction({sourceMint:a.inputMint,destinationMint:a.outputMint,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:t,quoteMintToReferrer:o,swapMode:e.swapMode,amount:e.amount,slippageBps:e.slippageBps,inAmount:e.inAmount,platformFee:s,overflowFeeAccount:null==o?void 0:o.get(a.inputMint.toBase58())})};throw new Error(`ExactOutInstruction missing for ${r.label}.`)}(s,l,n,o,u,a);e&&p.push(Tn(14e5)),g.push(t)}const{signers:h,cleanupInstructions:f}={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]};return e.isKeyPair&&e.signer&&h.push(e.signer),{setupInstructions:p,signers:h,cleanupInstructions:f,instructions:g}}({user:d,openOrdersAddresses:k.openOrders.map((e=>null==e?void 0:e.address)),userSourceTokenAccountAddress:f.address,userIntermediateTokenAccountAddresses:k.intermediates.map((({address:e})=>e)),userDestinationTokenAccountAddress:k.destination.address,routeInfo:t,platformFee:y,quoteMintToReferrer:this.quoteMintToReferrer}),T=function(e,{hasSerumOpenOrderInstruction:t}){let n,i;if(1===e.length){const t=e[0].amm;if(!(t instanceof gn))return!1;n=t.firstAmm,i=t.secondAmm}else[n,i]=e.map((e=>e.amm));return!!t||!!U(x,n.label,i.label)}(t.marketInfos,{hasSerumOpenOrderInstruction:w}),P=new Fn(r,d.publicKey,d),v=new Fn(r,d.publicKey,d),b=new Fn(r,d.publicKey,d),I=[...k.intermediates,f,!k.destination.address.equals(f.address)&&k.destination];v.addInstruction(M),T?(w&&k.openOrders.forEach((e=>{e&&P.addInstruction(e)})),I.forEach((e=>{e&&(P.addInstruction({...e,cleanupInstructions:[]}),e.cleanupInstructions.length)&&b.addInstruction({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[],cleanupInstructions:e.cleanupInstructions})}))):(w&&k.openOrders.forEach((e=>{e&&v.addInstruction(e)})),I.forEach((e=>{e&&v.addInstruction(e)}))),s=s||await this.connection.getLatestBlockhash("confirmed");const{transaction:B}=await P.build(s),{transaction:D}=await v.build(s),{transaction:E}=await b.build(s),[F,L,O]=[B.instructions.length?B:void 0,D,E.instructions.length?E:void 0],R=k;return{transactions:{setupTransaction:F,swapTransaction:L,cleanupTransaction:O},execute:({wallet:e,onTransaction:t}={})=>this.executeInternal({wallet:e,onTransaction:t,inputMint:p,outputMint:g,sourceInstruction:f,setupInstructions:R,setupTransaction:F,swapTransaction:L,cleanupTransaction:O,wrapUnwrapSOL:h,owner:d})}},this.connection=t,this.cluster=n,this.tokenRouteSegments=i,this.feeCalculator=o,this.platformFeeAndAccounts=s,this.quoteMintToReferrer=a,this.routeCacheDuration=r,this.wrapUnwrapSOL=u,this.intermediateTokens=c,this.shouldLoadSerumOpenOrders=d}static async load({connection:e,cluster:n,user:i,platformFeeAndAccounts:o=Dn,quoteMintToReferrer:s,routeCacheDuration:a=0,wrapUnwrapSOL:r=!0,marketUrl:u,restrictIntermediateTokens:c=!1,shouldLoadSerumOpenOrders:d=!0}){const[l,{value:{feeCalculator:m}},p,g]=await Promise.all([Jn.fetchTokenRouteSegments(e,n,u),e.getRecentBlockhashAndContext("processed"),null!=s?s:En(e,new t.PublicKey(ae)),c?Jn.getIntermediateTokens():void 0]),h=new Jn(e,n,l,m,o,p,a,r,g,d);return i&&h.setUserPublicKey(i),h}getAccountToAmmIdsMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{t.getAccountsForUpdate().forEach((n=>{const i=e.get(n.toBase58())||new Set;i.add(t.id),e.set(n.toBase58(),i)}))}))}))})),e}getAmmIdToAmmMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{e.set(t.id,t)}))}))})),e}async computeRoutes({inputMint:e,outputMint:t,amount:n,slippageBps:i,feeBps:o=0,forceFetch:s,onlyDirectRoutes:a,swapMode:r=exports.SwapMode.ExactIn,filterTopNResult:u,enforceSingleTx:c}){const d=e.toBase58(),l=t.toBase58(),m=o||(this.platformFeeAndAccounts.feeAccounts.get(l)?this.platformFeeAndAccounts.feeBps:0),p=(new Date).getTime(),g=[d,l].sort(((e,t)=>e.localeCompare(t))).join(""),h=this.routeCache.get(g),f=function({inputMint:e,outputMint:t,tokenRouteSegments:n,swapMode:i,intermediateTokens:o,onlyDirectRoutes:s}){const a=new Map,r=n.get(e),u=n.get(t);if(r&&u){const n=Math.min(r.size,u.size),c=r.size<u.size,d=new Map,l=new Map;let[m,p,g,h]=c?[r,u,e,t]:[u,r,t,e];for(let[e,t]of m.entries()){let r=i===exports.SwapMode.ExactIn?t:t.filter((e=>e.exactOutputSupported));if(e===h){d.set(e,r),l.set(g,r);continue}if(s||i===exports.SwapMode.ExactOut||yn(o,n,e))continue;const u=p.get(e);if(u){let t=i===exports.SwapMode.ExactIn?u:u.filter((e=>e.exactOutputSupported));a.set(e,new Map([[g,r],[h,t]])),d.set(e,r),l.set(e,t)}}a.set(g,d),a.set(h,l)}return a}({inputMint:d,outputMint:l,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens,onlyDirectRoutes:a,swapMode:r});let S=!1;if(-1===this.routeCacheDuration)S=!1;else if(0===this.routeCacheDuration)S=!0;else if(h){const{fetchTimestamp:e}=h;p-e>this.routeCacheDuration&&(S=!0)}else S=!0;(s||S)&&(await async function(e,t){const n=new Map,i=new Set,o=new Map;t.forEach((e=>{e.forEach((e=>{e.forEach((e=>{o.set(e.id,e),e.getAccountsForUpdate().forEach((e=>{i.add(e.toBase58())}))}))}))}));const s=Array.from(i);s.length>0&&((await V(e,s)).forEach(((e,t)=>{e&&n.set(s[t],e)})),o.forEach((e=>{e.update(n)})))}(this.connection,f),this.routeCache.set(g,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:jn({inputRouteSegment:f,inputMint:e,outputMint:t,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:a,slippageBps:i,platformFeeBps:m,filterTopNResult:u,swapMode:r,enforceSingleTx:c}),cached:!(s||S)}}catch(e){throw e}finally{this.routeCache.forEach((({fetchTimestamp:e},t)=>{e-p>this.routeCacheDuration&&this.routeCache.delete(t)}))}}setUserPublicKey(e){this.user=e;const t=new Ln(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?Jn.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:t.publicKey}):Promise.resolve(new Map)}static async fetchTokenRouteSegments(e,o,s){const a=await(async e=>await(await R.default(e)).json())(s||Z[o]);return function(e){const t=new Map;return e.forEach((e=>{mn(e.reserveTokenMints).forEach((([n,i])=>{!function(e,t,n,i){let o=i.get(e);o||(o=new Map([[t,[]]]),i.set(e,o));let s=o.get(t);s||(s=[],o.set(t,s)),s.push(n)}(wn(n),wn(i),e,t)}))})),t}(await async function(e,o){const s=(e=>e.map((e=>{const{data:[n,i],pubkey:o,...s}=e;return{...s,pubkey:new t.PublicKey(o),data:Buffer.from(n,i),owner:new t.PublicKey(s.owner)}})))(o),a=[];if(a.length){const t=await async function(e,t){const n=await Promise.all((await V(e,t.map((e=>e.toBase58())))).map((async(e,n)=>{const i=t[n];if(!e)throw new Error(`Failed to fetch pool ${i.toBase58()}`);return{pubkey:i,...e}})));return n}(e,a);s.push(...t)}const r=[],u=s.reduce(((e,o)=>{const s=function(e,o,s){const a=new t.PublicKey(o.owner);if(a.equals(X)||a.equals(Y)){const e=n.Market.getLayout(a).decode(o.data);if(!e.accountFlags.initialized||!e.accountFlags.market)throw new Error("Invalid market");const t=new n.Market(e,0,0,{},a);return new rn(t)}if(a.equals(J)){const t=new Xt(e,o,s);if(1===t.status)return t}else{if(a.equals(re))return new Vt(e,o,s);if(a.equals(i.SWAP_PROGRAM_ID)){const t=o.data.slice(2,3),n=i.StableSwap.loadWithData(e,o.data,Re([e.toBuffer(),t],i.SWAP_PROGRAM_ID));if(n.state.isPaused||!n.state.isInitialized)return;return new en(n)}if(a.equals(se))return new ht(e,o);if(a.equals($)||a.equals(ee))return new pt(e,o,s);if([...An.keys()].includes(a.toBase58())){var r;const t=null!==(r=An.get(o.owner.toBase58()))&&void 0!==r?r:"Unknown";return new ln(e,o,t)}if(a.equals(ne))return new ft(e,o,s);if(a.equals(ie)){const t=new nn(e,o);if(t.isPaused)return;return t}if(a.equals(oe))return new Dt(e,o);if(a.equals(ue))return new fn(e,o);if(a.equals(me))return new wt(e,o);if(a.equals(ge))return new xt(e,o);if(a.equals(we))return new jt(e,o,s);if(a.equals(Pe))return new vt(e,o);if(a.equals(ce))return new Bt(e,o)}}(o.pubkey,o,o.params);return s&&(e.push(s),s.shouldPrefetch&&r.push(s)),e}),new Array);return await Promise.all([z(r,e),w.loadWasm()]),u.push(...Zt()),u}(e,a))}getRouteMap(e){return function(e,t,n,i){const o=new Map;for(const[i,u]of e){const c=new Set;for(const[o,d]of u){var s;if(c.add(o),n)continue;const l=null!==(s=e.get(o))&&void 0!==s?s:new Map;for(const[n,s]of l){var a,r;if(n===i)continue;const l=null!==(a=null===(r=e.get(n))||void 0===r?void 0:r.size)&&void 0!==a?a:0;if(yn(t,Math.min(u.size,l),o))continue;let m=!1;for(const e of d){for(const t of s)if(Sn({amms:[e,t],enforceSingleTx:void 0})){c.add(n),m=!0;break}if(m)break}}}o.set(i,Array.from(c))}return o}(this.tokenRouteSegments,this.intermediateTokens,e)}static async getRemoteRouteMap({onlyDirectRoutes:e,restrictIntermediateTokens:t},n){let i=n||"https://cache.jup.ag/indexed-route-map";return e?i=i.concat("?onlyDirectRoutes=true"):t&&(i=i.concat("?restrictIntermediateTokens=true")),Zn(await(await R.default(i)).json())}async executeInternal({wallet:e,onTransaction:t,inputMint:n,outputMint:i,sourceInstruction:o,setupInstructions:s,setupTransaction:r,swapTransaction:u,cleanupTransaction:c,owner:d,wrapUnwrapSOL:l}){let m,p;try{const g=[r,u,c].filter((e=>void 0!==e)),h=g.length;if(d.signer){const e=d.signer;g.forEach((t=>{t.sign(e)}))}else{if(!e)throw new Error("Signer wallet not found");if(h>1){const t=await e.signAllTransactions(g);let n=0;[r,u,c]=[r?t[n++]:void 0,t[n++],c?t[n++]:void 0]}else u=await e.signTransaction(u)}if(r){let e=Kn(r);const n=(async()=>await Xn(await Cn(this.connection,r)))();if(null==t||t(e,h,"SETUP",n),await n instanceof Error)throw p}const f=Kn(u);try{const e=(async()=>await Xn(await Cn(this.connection,u)))();null==t||t(f,h,"SWAP",e);const r=await e;if(r instanceof Error)throw r;const[m,g]=function({txid:e,inputMint:t,outputMint:n,user:i,sourceAddress:o,destinationAddress:s,transactionResponse:r,hasWrappedSOL:u}){let c,d;if(r){let{meta:e,transaction:a}=r;e&&(c=t.equals(H)&&!u?qn(e,a,i):Rn(e,a,o),d=n.equals(H)&&!u?qn(e,a,i):Rn(e,a,s))}if(!c||!d)throw new a.TransactionError("Cannot find source or destination token account balance change",e,Ie.BalancesNotExtractedProperly.code);return[c,d]}({txid:f,inputMint:n,outputMint:i,user:d.publicKey,sourceAddress:o.address,destinationAddress:s.destination.address,transactionResponse:r,hasWrappedSOL:Boolean(c)||!l});p={txid:f,inputAddress:o.address,outputAddress:s.destination.address,inputAmount:m,outputAmount:g}}catch(e){m=e}finally{if(c){const e=Kn(c),n=(async()=>Xn(await Cn(this.connection,c)))();null==t||t(e,h,"CLEANUP",n),await n}}if(m||!p)throw m||new Error("Swap failed");return p}catch(e){return{error:e}}finally{this.routeCache.clear()}}static async getIntermediateTokens(){const e=await async function(){const e=await(await R.default("https://cache.jup.ag/top-tokens")).json();return new Set(e.filter(((e,t)=>t<60)))}();for(const t of be)e.add(t);return Zt().forEach((t=>{e.add(t.wrappedToken.addDecimals.mint.toBase58())})),Array.from(e)}}Jn.findSerumOpenOrdersForOwner=async({userPublicKey:e,cluster:t,connection:i})=>{const o=new Map;if(e){const s="mainnet-beta"===t?X:Y;(await n.OpenOrders.findForOwner(i,e,s)).forEach((e=>{o.set(e.market.toString(),e.address)}))}return o},Object.defineProperty(exports,"TransactionError",{enumerable:!0,get:function(){return a.TransactionError}}),exports.ALDRIN_SWAP_PROGRAM_ID=$,exports.ALDRIN_SWAP_V2_PROGRAM_ID=ee,exports.AldrinAmm=pt,exports.CREMA_PROGRAM_ID=se,exports.CROPPER_PROGRAM_ID=ne,exports.CYKURA_FACTORY_STATE_ADDRESS=pe,exports.CYKURA_PROGRAM_ID=me,exports.CremaAmm=ht,exports.CropperAmm=ft,exports.CykuraAmm=wt,exports.DELTA_FI_PROGRAM_ID=Me,exports.DELTA_FI_USER_ID=Te,exports.DEVNET_SERUM_DEX_PROGRAM=Y,exports.DeltaFiAmm=class{constructor(e,n){this.address=void 0,this.id=void 0,this.label="DeltaFi",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapInfo=void 0,this.feePct=void 0,this.prices=void 0,this.pythAddresses=void 0,this.address=e,this.id=e.toBase58(),this.swapInfo=Mt.coder.accounts.decode("SwapInfo",n.data);const{swapConfig:i}=this.swapInfo;this.feePct=i.tradeFeeNumerator/i.tradeFeeDenominator,this.pythAddresses=[this.swapInfo.pythPriceBase,this.swapInfo.pythPriceQuote].filter((e=>!t.SystemProgram.programId.equals(e)))}getAccountsForUpdate(){return[this.address,...this.pythAddresses]}getPriceData(e,t){const{id:n}=this,i=e.get(t.toBase58())||yt[n];if(!i)throw new Error(`Missing pyth account info for ${t.toBase58()}`);return"data"in i?A.parsePriceData(i.data):i}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.swapInfo=Mt.coder.accounts.decode("SwapInfo",t.data);try{const t=this.getPriceData(e,this.swapInfo.pythPriceBase),n=this.getPriceData(e,this.swapInfo.pythPriceQuote);if(t.price&&n.price){const e=new k.BigNumber(t.price).dividedBy(new k.BigNumber(n.price)),i=new k.BigNumber(t.price+t.confidence).dividedBy(new k.BigNumber(n.price-n.confidence)),o=new k.BigNumber(t.price-t.confidence).dividedBy(new k.BigNumber(n.price+n.confidence));this.prices={marketPrice:e,highPrice:i,lowPrice:o}}else this.prices=void 0}catch(e){this.prices=void 0}}getQuote({destinationMint:e,amount:t}){if(!this.prices)throw new Error("Missing price data from pyth");const{swapInfo:n}=this,{amountIn:i,amountOut:o,priceImpact:s}=S.getSwappedAmountsAndPriceImpactFromRawValue(n,e.equals(n.mintQuote)?{sellBase:{}}:{sellQuote:{}},new k.BigNumber(t.toString()),this.prices.marketPrice,this.prices.highPrice,this.prices.lowPrice),a=o.multipliedBy(n.swapConfig.tradeFeeNumerator.toString()).dividedBy(n.swapConfig.tradeFeeDenominator.toString()).decimalPlaces(0),r=o.minus(a);return{notEnoughLiquidity:!1,inAmount:E.default.BigInt(i),outAmount:E.default.BigInt(r),feeAmount:E.default.BigInt(a),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:Number(s)}}getSwapLegAndAccounts(t){var n;if(!this.prices)throw new Error("Missing price data from pyth");const{swapSourceToken:i,swapDestinationToken:o,adminDestinationToken:s}=this.swapInfo.mintBase.equals(t.sourceMint)?{swapSourceToken:this.swapInfo.tokenBase,swapDestinationToken:this.swapInfo.tokenQuote,adminDestinationToken:this.swapInfo.adminFeeTokenQuote}:{swapSourceToken:this.swapInfo.tokenQuote,swapDestinationToken:this.swapInfo.tokenBase,adminDestinationToken:this.swapInfo.adminFeeTokenBase};return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[je((s=t.stable,{deltaFi:{stable:s}})),Ye.instruction.deltafiSwap({accounts:{swapProgram:Me,marketConfig:t.marketConfig,swapInfo:t.swapInfo,userSourceToken:n,userDestinationToken:i,swapSourceToken:t.swapSourceToken,swapDestinationToken:t.swapDestinationToken,deltafiUser:Te,adminDestinationToken:t.adminDestinationToken,pythPriceBase:t.pythPriceBase,pythPriceQuote:t.pythPriceQuote,userAuthority:o,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[Ze]}).keys];var s}({additionalArgs:{stable:!!this.swapInfo.swapType.stableSwap,marketConfig:this.swapInfo.configKey,swapInfo:this.address,swapSourceToken:i,swapDestinationToken:o,adminDestinationToken:s,pythPriceBase:this.swapInfo.pythPriceBase,pythPriceQuote:this.swapInfo.pythPriceQuote,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.destinationMint.toBase58())},...t})}get reserveTokenMints(){return[this.swapInfo.mintQuote,this.swapInfo.mintBase]}},exports.FAKE_PROVIDER=Be,exports.GOOSE_FX_CONTROLLER_ID=ve,exports.GOOSE_FX_PROGRAM_ID=Pe,exports.GooseFXAmm=vt,exports.INDEXED_ROUTE_MAP_URL="https://cache.jup.ag/indexed-route-map",exports.INVARIANT_PROGRAM_AUTHORITY_ID=le,exports.INVARIANT_PROGRAM_ID=ce,exports.INVARIANT_STATE_ID=de,exports.IS_DEV=!1,exports.InvariantAmm=Bt,exports.JUPITER_ERRORS=Ie,exports.JUPITER_WALLET=ae,exports.Jupiter=Jn,exports.LAMPORTS_PER_SIGNATURE=5e3,exports.LIFINITY_PROGRAM_ID=oe,exports.LifinityAmm=Dt,exports.MAINNET_SERUM_DEX_PROGRAM=X,exports.MARINADE_PROGRAM_ID=ge,exports.MARKETS_URL=Z,exports.MERCURIAL_SWAP_PROGRAM_ID=re,exports.METEORA_PROGRAM_ID=we,exports.METEORA_VAULT_PROGRAM_ID=ye,exports.MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS=100,exports.MarinadeAmm=xt,exports.MercurialAmm=Vt,exports.MeteoraAmm=jt,exports.ORCA_PROGRAM_ID=fe,exports.PENGUIN_PROGRAM_ID=Ae,exports.RAYDIUM_AMM_V4_PROGRAM_ID=J,exports.RaydiumAmm=Xt,exports.SABER_ADD_DECIMALS_PROGRAM_ID=te,exports.SAROS_PROGRAM_ID=ke,exports.SENCHA_PROGRAM_ID=ie,exports.STEPN_PROGRAM_ID=he,exports.STEP_TOKEN_SWAP_PROGRAM_ID=Se,exports.SWAP_PROTOCOL_TOKENS=be,exports.SaberAddDecimalsAmm=$t,exports.SaberAmm=en,exports.SenchaAmm=nn,exports.SerumAmm=rn,exports.SplTokenSwapAmm=ln,exports.SplitTradeAmm=gn,exports.TOKEN_LIST_URL={devnet:"https://api.jup.ag/api/tokens/devnet",testnet:"https://api.jup.ag/api/markets/devnet","mainnet-beta":"https://cache.jup.ag/tokens"},exports.TransactionBuilder=Fn,exports.WHIRLPOOL_PROGRAM_ID=ue,exports.WRAPPED_SOL_MINT=H,exports.WhirlpoolAmm=fn,exports.getComputeUnitLimitInstruction=Tn,exports.getEmptyInstruction=()=>({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]}),exports.getPlatformFeeAccounts=En,exports.getRouteInfoUniqueId=function(e){return e.marketInfos.map((e=>`${e.amm.id}-${e.inputMint}`)).join("-")},exports.getSaberWrappedDecimalsAmms=Zt,exports.indexedRouteMapToRouteMap=Zn,exports.routeMapToIndexedRouteMap=function(e){const{mintToIndexMap:t,indexedRouteMap:n}=Array.from(e).reduce((({mintToIndexMap:e,indexedRouteMap:t},[n,i])=>{const o=Yn(n,e),s=[];for(const t of i){const n=Yn(t,e);s.push(n)}return t[o]=s,{mintToIndexMap:e,indexedRouteMap:t}}),{mintToIndexMap:new Map,indexedRouteMap:{}});return{mintKeys:[...t.keys()],indexedRouteMap:n}},exports.transactionSenderAndConfirmationWaiter=Cn;
//# sourceMappingURL=core.cjs.production.min.js.map
