import { Market } from '@project-serum/serum';
import { AccountMeta, PublicKey, TransactionInstruction } from '@solana/web3.js';
import BN from 'bn.js';
import type { RaydiumAmm } from './amms';
import { StableSwap } from '@saberhq/stableswap-sdk';
import { AldrinPoolState } from './amms/aldrin/poolState';
import type { TokenSwapState } from './amms/spl-token-swap/tokenSwapLayout';
import { PlatformFee } from './types';
import type { AddDecimals } from './amms/saber/saberAddDecimalsAmm';
import { CropperPoolState } from './amms/cropper/swapLayout';
import { SenchaPoolState } from './amms/sencha/swapLayout';
import { CremaPoolState } from './amms/crema/swapLayout';
import { MercurialSwapLayoutState } from './amms/mercurial/swapLayout';
import { LifinitySwapLayoutState } from './amms/lifinity/swapLayout';
import { MarinadeStateResponse } from './amms/marinade/marinade-state.types';
import { SwapLegType } from './jupiterEnums';
import { SwapLegAndAccounts } from './amm';
export declare const JUPITER_PROGRAM_ID_STAGING: PublicKey;
export declare const JUPITER_PROGRAM_ID_PRODUCTION: PublicKey;
export declare const JUPITER_PROGRAM_ID: PublicKey;
export declare function createRoutesSwapInstruction(userTransferAuthority: PublicKey, destinationTokenAccount: PublicKey, swapLeg: SwapLegType, accounts: AccountMeta[], amount: BN, quotedOutAmount: BN, slippageBps: number, platformFeeBps: number): TransactionInstruction;
interface CreateSwapInstructionParams {
    sourceMint: PublicKey;
    userSourceTokenAccount: PublicKey;
    userDestinationTokenAccount: PublicKey;
    userTransferAuthority: PublicKey;
}
interface CreateSwapExactOutputInstructionParams extends CreateSwapInstructionParams {
    outAmount: BN;
}
export declare function createMercurialSwapLegAndAccounts({ swapLayout, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    swapLayout: MercurialSwapLayoutState;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createSerumSwapLegAndAccounts({ market, sourceMint, openOrdersAddress, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, referrer, }: {
    market: Market;
    openOrdersAddress: PublicKey;
    referrer: PublicKey | undefined;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createTokenSwapLegAndAccounts({ tokenSwapState, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, isStep, }: {
    tokenSwapState: TokenSwapState;
    isStep: boolean;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createSenchaSwapLegAndAccounts({ poolState, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    poolState: SenchaPoolState;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createCropperSwapLegAndAccounts({ poolState, feeAccount, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    poolState: CropperPoolState;
    feeAccount: PublicKey;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createRaydiumSwapLegAndAccounts({ raydiumAmm, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    raydiumAmm: RaydiumAmm;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createAldrinSwapLegAndAccounts({ poolState, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    poolState: AldrinPoolState;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createAldrinV2SwapLegAndAccounts({ poolState, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, curve, userTransferAuthority, }: {
    poolState: AldrinPoolState;
    curve: PublicKey;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createCremaSwapLegAndAccounts({ poolState, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    poolState: CremaPoolState;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createSaberSwapLegAndAccounts({ stableSwap, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    stableSwap: StableSwap;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createSaberAddDecimalsSwapLegAndAccounts({ addDecimals, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, deposit, }: {
    deposit: boolean;
    addDecimals: AddDecimals;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createLifinitySwapLegAndAccounts({ swapState, sourceMint, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    swapState: LifinitySwapLayoutState;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type CykuraSwapInstructionArgs = {
    poolAddress: PublicKey;
    inputVault: PublicKey;
    outputVault: PublicKey;
    nextObservationState: PublicKey;
    lastObservationState: PublicKey;
    swapAccountMetas: AccountMeta[];
};
export declare function createCykuraSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: CykuraSwapInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type WhirlpoolSwapInstructionArgs = {
    aToB: boolean;
    whirlpool: PublicKey;
    tokenVaultA: PublicKey;
    tokenVaultB: PublicKey;
    tickArray0: PublicKey;
    tickArray1: PublicKey;
    tickArray2: PublicKey;
    oracle: PublicKey;
};
export declare function createWhirlpoolSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: WhirlpoolSwapInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type MarinadeFinanceDepositInstructionArgs = {
    address: PublicKey;
    marinadeStateResponse: MarinadeStateResponse;
    liqPoolSolLegPda: PublicKey;
    liqPoolMsolLegAuthority: PublicKey;
    reservePda: PublicKey;
    msolMintAuthority: PublicKey;
};
export declare function createMarinadeDepositSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: MarinadeFinanceDepositInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type MarinadeFinanceLiquidUnstakeInstructionArgs = {
    address: PublicKey;
    marinadeStateResponse: MarinadeStateResponse;
    liqPoolSolLegPda: PublicKey;
};
export declare function createMarinadeUnstakeSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: MarinadeFinanceLiquidUnstakeInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type InvariantSwapInstructionArgs = {
    xToY: boolean;
    pool: PublicKey;
    tickmap: PublicKey;
    reserveX: PublicKey;
    reserveY: PublicKey;
    crossedTickAddresses: PublicKey[];
    referrer?: PublicKey;
};
export declare function createInvariantSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: InvariantSwapInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type MeteoraSwapInstructionArgs = {
    pool: PublicKey;
    aVault: PublicKey;
    bVault: PublicKey;
    aTokenVault: PublicKey;
    bTokenVault: PublicKey;
    aVaultLpMint: PublicKey;
    bVaultLpMint: PublicKey;
    aVaultLp: PublicKey;
    bVaultLp: PublicKey;
    adminTokenFee: PublicKey;
    referrer?: PublicKey;
    depeg?: PublicKey;
};
export declare function createMeteoraSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: MeteoraSwapInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type GooseFxSwapInstructionArgs = {
    pair: PublicKey;
    sslIn: PublicKey;
    sslOut: PublicKey;
    liabilityVaultIn: PublicKey;
    swappedLiabilityVaultIn: PublicKey;
    liabilityVaultOut: PublicKey;
    swappedLiabilityVaultOut: PublicKey;
    feeCollectorAta: PublicKey;
    feeCollector: PublicKey;
    oracles: PublicKey[];
    referrer?: PublicKey;
};
export declare function createGooseFxSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: GooseFxSwapInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
declare type DeltaFiSwapInstructionArgs = {
    stable: boolean;
    marketConfig: PublicKey;
    swapInfo: PublicKey;
    swapSourceToken: PublicKey;
    swapDestinationToken: PublicKey;
    adminDestinationToken: PublicKey;
    pythPriceBase: PublicKey;
    pythPriceQuote: PublicKey;
    referrer?: PublicKey;
};
export declare function createDeltaFiSwapLegAndAccounts({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, }: {
    additionalArgs: DeltaFiSwapInstructionArgs;
} & CreateSwapInstructionParams): SwapLegAndAccounts;
export declare function createWhirlpoolSwapExactOutputInstruction({ additionalArgs, userSourceTokenAccount, userDestinationTokenAccount, userTransferAuthority, outAmount, inAmount, slippageBps, platformFee, overflowFeeAccount, }: {
    inAmount: BN;
    slippageBps: number;
    platformFee?: PlatformFee;
    overflowFeeAccount?: PublicKey;
    additionalArgs: WhirlpoolSwapInstructionArgs;
} & CreateSwapExactOutputInstructionParams): TransactionInstruction;
export declare function createOpenOrdersInstruction(market: Market, userTransferAuthority: PublicKey): [PublicKey, TransactionInstruction];
export {};
