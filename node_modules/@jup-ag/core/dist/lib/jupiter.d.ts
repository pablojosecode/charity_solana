import { BlockhashWithExpiryBlockHeight, Cluster, Connection, FeeCalculator, Keypair, PublicKey, Transaction, TransactionResponse, TransactionSignature } from '@solana/web3.js';
import { RouteInfo } from './routes';
import { MarketInfo } from './market';
import type { SignerWalletAdapter } from '@solana/wallet-adapter-base';
import { TokenRouteSegments, PlatformFeeAndAccounts, QuoteMintToReferrer } from './types';
import { TokenMintAddress } from './types';
import { Amm, SwapMode } from './amm';
import { TransactionError } from '@mercurial-finance/optimist';
import JSBI from 'jsbi';
import { getSaberWrappedDecimalsAmms } from './amms/saber/saberAddDecimalsAmm';
export declare type SerumOpenOrdersMap = Map<string, PublicKey>;
export { MarketInfo } from './market';
export { getPlatformFeeAccounts } from './fee';
export * from './types';
export { transactionSenderAndConfirmationWaiter } from '../utils/transactionHelpers';
export { routeMapToIndexedRouteMap, indexedRouteMapToRouteMap, IndexedRouteMap } from '../utils/indexedRouteMap';
export { RouteInfo, TransactionFeeInfo, getRouteInfoUniqueId } from './routes';
export { TransactionError, getSaberWrappedDecimalsAmms, Amm, SwapMode };
export * from './amms';
export declare type SwapResult = {
    txid: string;
    inputAddress: PublicKey;
    outputAddress: PublicKey;
    inputAmount: number;
    outputAmount: number;
} | {
    error?: TransactionError;
};
export declare type JupiterLoadParams = {
    connection: Connection;
    cluster: Cluster;
    user?: PublicKey | Keypair;
    platformFeeAndAccounts?: PlatformFeeAndAccounts;
    /** See {@link Jupiter.quoteMintToReferrer} */
    quoteMintToReferrer?: Map<TokenMintAddress, PublicKey>;
    /** See {@link Jupiter.routeCacheDuration} */
    routeCacheDuration?: number;
    /** See {@link Jupiter.wrapUnwrapSOL} */
    wrapUnwrapSOL?: boolean;
    /** A markets cache URL, default to jupiter markets cache */
    marketUrl?: string;
    /**
     * On multi-leg trades, the intermediate tokens is restricted to X top tokens in volume and certain utility tokens (Saber wrapped decimal tokens)
     * This is to reduce the load by having to compute trades through routes that are not so liquid
     */
    restrictIntermediateTokens?: boolean;
    /** See {@link Jupiter.shouldLoadSerumOpenOrders}, default to true */
    shouldLoadSerumOpenOrders?: boolean;
};
export declare type OnTransaction = (txid: TransactionSignature, totalTxs: number, txDescription: IConfirmationTxDescription, awaiter: Promise<TransactionResponse | TransactionError | null>) => void;
export declare type IConfirmationTxDescription = 'SETUP' | 'SWAP' | 'CLEANUP';
declare type ExecuteParams = {
    wallet?: Pick<SignerWalletAdapter, 'sendTransaction' | 'signAllTransactions' | 'signTransaction'>;
    /**
     * Allows to customize control of sending and awaiting confirmation in the single/multi transaction flow
     */
    onTransaction?: OnTransaction;
};
export declare class Jupiter {
    private connection;
    private cluster;
    tokenRouteSegments: TokenRouteSegments;
    private feeCalculator;
    private platformFeeAndAccounts;
    /** Referrer account to collect Serum referrer fees for each given quote mint, the referrer fee is 20% of the Serum protocol fee */
    private quoteMintToReferrer;
    /**
     * -1, it will not fetch when shouldFetch == false
     * 0, it will fetch everytime
     * A duration in ms, the time interval between AMM accounts refetch, recommendation for a UI 20 seconds,
     */
    private routeCacheDuration;
    /** When set to true (default) native SOL is wrapped and wSOL unwrapped in each swap, otherwise it assumes wSOL is funded when it exists */
    private wrapUnwrapSOL;
    private intermediateTokens;
    /** Perform a getProgramAccounts on user's serum open orders. Recomended to turn off if RPC is slow to perform a gPA */
    private shouldLoadSerumOpenOrders;
    private serumOpenOrdersPromise;
    private user;
    private routeCache;
    constructor(connection: Connection, cluster: Cluster, tokenRouteSegments: TokenRouteSegments, feeCalculator: FeeCalculator, platformFeeAndAccounts: PlatformFeeAndAccounts, 
    /** Referrer account to collect Serum referrer fees for each given quote mint, the referrer fee is 20% of the Serum protocol fee */
    quoteMintToReferrer: QuoteMintToReferrer, 
    /**
     * -1, it will not fetch when shouldFetch == false
     * 0, it will fetch everytime
     * A duration in ms, the time interval between AMM accounts refetch, recommendation for a UI 20 seconds,
     */
    routeCacheDuration: number, 
    /** When set to true (default) native SOL is wrapped and wSOL unwrapped in each swap, otherwise it assumes wSOL is funded when it exists */
    wrapUnwrapSOL: boolean, intermediateTokens: TokenMintAddress[] | undefined, 
    /** Perform a getProgramAccounts on user's serum open orders. Recomended to turn off if RPC is slow to perform a gPA */
    shouldLoadSerumOpenOrders: boolean);
    /**
     * load performs the necessary async scaffolding of the Jupiter object
     */
    static load({ connection, cluster, user, platformFeeAndAccounts, quoteMintToReferrer, routeCacheDuration, wrapUnwrapSOL, marketUrl, restrictIntermediateTokens, shouldLoadSerumOpenOrders, }: JupiterLoadParams): Promise<Jupiter>;
    getAccountToAmmIdsMap(): Map<string, Set<string>>;
    getAmmIdToAmmMap(): Map<string, Amm>;
    getDepositAndFees: ({ marketInfos, userPublicKey, serumOpenOrdersPromise, }: {
        marketInfos: MarketInfo[];
        userPublicKey: PublicKey;
        serumOpenOrdersPromise?: Promise<SerumOpenOrdersMap> | undefined;
    }) => Promise<import("./routes").TransactionFeeInfo>;
    private getDepositAndFeesForUser;
    computeRoutes({ inputMint, outputMint, amount, slippageBps, feeBps, forceFetch, onlyDirectRoutes, swapMode, filterTopNResult, enforceSingleTx, }: {
        inputMint: PublicKey;
        outputMint: PublicKey;
        amount: JSBI;
        slippageBps: number;
        feeBps?: number;
        forceFetch?: boolean;
        onlyDirectRoutes?: boolean;
        swapMode?: SwapMode;
        enforceSingleTx?: boolean;
        /**
         * filter how many top individual route to be used to compared
         */
        filterTopNResult?: number;
    }): Promise<{
        routesInfos: RouteInfo[];
        cached: boolean;
    }>;
    setUserPublicKey(userPublicKey: Keypair | PublicKey): void;
    /**
     * The token route segments contains all the routes and the market meta information.
     */
    static fetchTokenRouteSegments(connection: Connection, cluster: Cluster, marketUrl?: string): Promise<TokenRouteSegments>;
    /**
     * This generate a routeMap which represents every possible output token mint for a given input token mint.
     * For example, we have SOL to USDC and this pairs have many routings like
     * SOL => USDT
     * USDT => USDC
     * SOL => USDC
     *
     * From here we know that we can have 2 different routing of SOL => USDC.
     * We do single level routing map but for all coins which result in the route map below:
     * SOL => USDT, USDC
     * USDT => SOL
     * USDC => SOL, USDT
     *
     * From this route map we can map out all possible route from one to another by checking the intersection.
     */
    getRouteMap(onlyDirectRoutes?: boolean): Map<string, string[]>;
    static getRemoteRouteMap({ onlyDirectRoutes, restrictIntermediateTokens, }: {
        onlyDirectRoutes?: boolean;
        restrictIntermediateTokens?: boolean;
    }, indexedRouteMapUrl?: string): Promise<Map<string, string[]>>;
    /**
     * Query existing open order account, this query is slow.
     * We suggest to fetch this in the background.
     */
    static findSerumOpenOrdersForOwner: ({ userPublicKey, cluster, connection, }: {
        userPublicKey: PublicKey;
        cluster: Cluster;
        connection: Connection;
    }) => Promise<SerumOpenOrdersMap>;
    exchange: (params: {
        routeInfo: RouteInfo;
        /**
         * This will overwrite the default Jupiter.setUser, useful for stateless usage like API
         */
        userPublicKey?: PublicKey;
        /**
         * This will overwrite the default fee account, useful for stateless usage like API
         */
        feeAccount?: PublicKey;
        /**
         * This will overwrite the default wrapUnwrapSOL, useful for stateless usage like API
         */
        wrapUnwrapSOL?: boolean;
        /**
         * The transaction will use the blockhash and valid blockheight to create transaction
         */
        blockhashWithExpiryBlockHeight?: BlockhashWithExpiryBlockHeight;
    }) => Promise<{
        transactions: {
            setupTransaction?: Transaction;
            swapTransaction: Transaction;
            cleanupTransaction?: Transaction;
        };
        execute: (params?: ExecuteParams) => Promise<SwapResult>;
    }>;
    /** sign, send and await confirmation for an exchange */
    private executeInternal;
    static getIntermediateTokens(): Promise<string[]>;
}
