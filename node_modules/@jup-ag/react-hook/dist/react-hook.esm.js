import React,{useState,useEffect,useMemo,useContext,useRef,useCallback,createContext}from"react";import{Jupiter,SwapMode,INDEXED_ROUTE_MAP_URL}from"@jup-ag/core";export*from"@jup-ag/core";export{JUPITER_ERRORS,MARKETS_URL,TOKEN_LIST_URL}from"@jup-ag/core";import JSBI from"jsbi";const Errors={INITIALIZE_ERROR:"INITIALIZE_ERROR",ROUTES_ERROR:"ROUTES_ERROR"};function useDebounce(t,r){const[e,o]=useState(t);return useEffect(()=>{const e=setTimeout(()=>{o(t)},r);return()=>{clearTimeout(e)}},[t,r]),e}const JupiterContext=createContext(null),JupiterProvider=({onlyDirectRoutes:r,userPublicKey:e,children:t,...o})=>{const[n,u]=useState(),[i,a]=useState(new Map),[s,c]=useState();useEffect(()=>{(async()=>{try{c(void 0);var e=await Jupiter.load({...o});u(e)}catch(e){throw console.error(e),c(Errors.INITIALIZE_ERROR),e}})()},Object.values(o)),useEffect(()=>{n&&e&&n.setUserPublicKey(e)},[n,e]),useEffect(()=>{!async function(){new Map;let e=new URL(INDEXED_ROUTE_MAP_URL);o.marketUrl&&(e.hostname=new URL(o.marketUrl).hostname);var t=e.toString(),t=await Jupiter.getRemoteRouteMap({onlyDirectRoutes:r,restrictIntermediateTokens:o.restrictIntermediateTokens},t);a(t)}()},[o.restrictIntermediateTokens,r]);var l=useMemo(()=>Array.from(i.keys()),[i]);return React.createElement(JupiterContext.Provider,{value:{jupiter:n,allTokenMints:l,connection:o.connection,cluster:o.cluster,routeCacheDuration:o.routeCacheDuration,routeMap:i,error:s,setError:c,onlyDirectRoutes:r}},t)},useJupiterRouteMap=()=>{var e=useContext(JupiterContext);if(e)return e.routeMap;throw new Error("JupiterProvider is required")},useJupiter=({amount:e,inputMint:t,outputMint:r,slippage:o,debounceTime:n=250,swapMode:u=SwapMode.ExactIn,enforceSingleTx:i})=>{var a=useContext(JupiterContext);const[s,c]=useState(!1),[l,R]=useState(),[p,E]=useState(0),f=useRef(p),[I,m,d]=useDebounce(React.useMemo(()=>[e,t,r],[e.toString(),null==t?void 0:t.toBase58(),null==r?void 0:r.toBase58()]),n),T=useRef(0),w=useRef(0);if(!a)throw new Error("JupiterProvider is required");const{routeMap:M,allTokenMints:S,jupiter:h,error:v,setError:J,routeCacheDuration:g=0,onlyDirectRoutes:x}=a;useEffect(()=>{f.current=-1},[[null===m||void 0===m?void 0:m.toString(),null===d||void 0===d?void 0:d.toString()].sort().join("-"),o]),useEffect(()=>{T.current&&(new Date).getTime()-T.current>=g&&(f.current=-1),JSBI.greaterThan(I,JSBI.BigInt(0))&&p!==f.current&&c(!0)},[p,I,o,m,d,x]),useEffect(()=>{if(h)if(JSBI.equal(I,JSBI.BigInt(0))||v===Errors.INITIALIZE_ERROR)R(void 0);else if(I&&m&&d&&M){let r=(new Date).getTime();w.current=r,h.computeRoutes({inputMint:m,outputMint:d,amount:I,slippageBps:Math.ceil(100*o),forceFetch:p!==f.current,onlyDirectRoutes:x,swapMode:u,enforceSingleTx:i}).then(({routesInfos:e,cached:t})=>{w.current===r&&(R(e),J(void 0),t||(T.current=(new Date).getTime()))}).catch(e=>{console.error(e),w.current===r&&(R(void 0),J(Errors.ROUTES_ERROR))}).finally(()=>{w.current===r&&(f.current=p,c(!1))})}},[h,I,m,d,o,p,x,i]);n=useCallback(async({wallet:e,routeInfo:t,onTransaction:r,...o})=>{if(v)throw new Error(v);if(!h)throw new Error("Jupiter not initialized");if(!t)throw new Error("Invalid state, impossible to build transaction");const n=(await h.exchange({routeInfo:t,...o}))["execute"];return await n({wallet:e,onTransaction:r})},[h]);return{allTokenMints:S,routeMap:M,exchange:n,refresh:()=>{!s&&T.current&&E(e=>e+1)},lastRefreshTimestamp:T.current,loading:s,routes:l,error:v}};export{Errors,JupiterProvider,useJupiter,useJupiterRouteMap};
//# sourceMappingURL=react-hook.esm.js.map
