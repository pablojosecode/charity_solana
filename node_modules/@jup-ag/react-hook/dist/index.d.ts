import React from 'react';
import { PublicKey } from '@solana/web3.js';
import { Errors } from './error';
import { RouteInfo, Jupiter, SwapResult, TOKEN_LIST_URL, MARKETS_URL, JUPITER_ERRORS, JupiterLoadParams, SwapMode } from '@jup-ag/core';
import JSBI from 'jsbi';
export declare type JupiterError = typeof Errors[keyof typeof Errors];
interface UseJupiterResult {
    /** routes that are possible, sorted decending based on outAmount */
    routes?: RouteInfo[];
    /** exchange function to submit transaction */
    exchange: (params: Parameters<Jupiter['exchange']>[0] & Parameters<Awaited<ReturnType<Jupiter['exchange']>>['execute']>[0]) => Promise<SwapResult>;
    /** refresh function to refetch the prices */
    refresh: () => void;
    /** last refresh timestamp */
    lastRefreshTimestamp: number;
    /** all possible token mints to be chosen from */
    allTokenMints: string[];
    /** route map input mint with output mints */
    routeMap: Map<string, string[]>;
    /** loading state */
    loading: boolean;
    error: JupiterError | undefined;
}
interface JupiterProps extends Omit<JupiterLoadParams, 'user'> {
    onlyDirectRoutes?: boolean;
    userPublicKey?: PublicKey;
    routeCacheDuration?: number;
    children?: React.ReactNode;
    enforceSingleTx?: boolean;
}
export declare const JupiterProvider: React.FC<JupiterProps>;
interface UseJupiterProps {
    amount: JSBI;
    inputMint: PublicKey | undefined;
    outputMint: PublicKey | undefined;
    slippage: number;
    debounceTime?: number;
    swapMode?: SwapMode;
    enforceSingleTx?: boolean;
}
export declare const useJupiterRouteMap: () => Map<string, string[]>;
export declare const useJupiter: ({ amount, inputMint, outputMint, slippage, debounceTime, swapMode, enforceSingleTx, }: UseJupiterProps) => UseJupiterResult;
export { TOKEN_LIST_URL, JUPITER_ERRORS, MARKETS_URL, Errors };
export * from '@jup-ag/core';
