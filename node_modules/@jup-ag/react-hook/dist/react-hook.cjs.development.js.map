{"version":3,"file":"react-hook.cjs.development.js","sources":["../src/error.tsx","../src/utils/useDebounce.ts","../src/index.tsx"],"sourcesContent":["export const Errors = {\n  INITIALIZE_ERROR: 'INITIALIZE_ERROR' as 'INITIALIZE_ERROR',\n  ROUTES_ERROR: 'ROUTES_ERROR' as 'ROUTES_ERROR',\n};\n","import { useEffect, useState } from 'react';\n\nexport default function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(\n    () => {\n      // Update debounced value after delay\n      const handler = setTimeout(() => {\n        setDebouncedValue(value);\n      }, delay);\n      // Cancel the timeout if value changes (also on delay change or unmount)\n      return () => {\n        clearTimeout(handler);\n      };\n    },\n    [value, delay], // Only re-call effect if value or delay changes\n  );\n  return debouncedValue;\n}\n","import React, { useEffect, useState, useMemo, useCallback, useRef, createContext, useContext } from 'react';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport { Errors } from './error';\nimport useDebounce from './utils/useDebounce';\nimport {\n  RouteInfo,\n  Jupiter,\n  SwapResult,\n  TOKEN_LIST_URL,\n  MARKETS_URL,\n  JUPITER_ERRORS,\n  JupiterLoadParams,\n  SwapMode,\n  INDEXED_ROUTE_MAP_URL,\n} from '@jup-ag/core';\nimport JSBI from 'jsbi';\n\nexport type JupiterError = typeof Errors[keyof typeof Errors];\n\ninterface UseJupiterResult {\n  /** routes that are possible, sorted decending based on outAmount */\n  routes?: RouteInfo[];\n  /** exchange function to submit transaction */\n  exchange: (\n    params: Parameters<Jupiter['exchange']>[0] & Parameters<Awaited<ReturnType<Jupiter['exchange']>>['execute']>[0],\n  ) => Promise<SwapResult>;\n  /** refresh function to refetch the prices */\n  refresh: () => void;\n  /** last refresh timestamp */\n  lastRefreshTimestamp: number;\n  /** all possible token mints to be chosen from */\n  allTokenMints: string[];\n  /** route map input mint with output mints */\n  routeMap: Map<string, string[]>;\n  /** loading state */\n  loading: boolean;\n  error: JupiterError | undefined;\n}\n\ninterface JupiterProps extends Omit<JupiterLoadParams, 'user'> {\n  onlyDirectRoutes?: boolean;\n  userPublicKey?: PublicKey;\n  routeCacheDuration?: number;\n  children?: React.ReactNode;\n  enforceSingleTx?: boolean;\n}\n\nconst JupiterContext = createContext<\n  | (Pick<UseJupiterResult, 'allTokenMints' | 'routeMap'> & {\n      connection: Connection;\n      cluster: string;\n      jupiter: Jupiter | undefined;\n      error: JupiterError | undefined;\n      setError: (error?: JupiterError) => void;\n      routeCacheDuration?: number;\n      onlyDirectRoutes?: boolean;\n    })\n  | null\n>(null);\n\nexport const JupiterProvider: React.FC<JupiterProps> = ({\n  onlyDirectRoutes,\n  userPublicKey,\n  children,\n  ...jupiterLoadProps\n}) => {\n  const [jupiter, setJupiter] = useState<Jupiter>();\n  const [routeMap, setRouteMap] = useState(new Map<string, string[]>());\n  const [error, setError] = useState<JupiterError>();\n\n  useEffect(() => {\n    (async () => {\n      try {\n        setError(undefined);\n        const _jupiter = await Jupiter.load({\n          ...jupiterLoadProps,\n        });\n\n        setJupiter(_jupiter);\n      } catch (e) {\n        console.error(e);\n        setError(Errors.INITIALIZE_ERROR);\n        throw e;\n      }\n    })();\n  }, Object.values(jupiterLoadProps));\n\n  useEffect(() => {\n    if (jupiter && userPublicKey) {\n      jupiter.setUserPublicKey(userPublicKey);\n    }\n  }, [jupiter, userPublicKey]);\n\n  useEffect(() => {\n    async function update() {\n      let routeMap = new Map<string, string[]>();\n\n      // so that we follow the marketUrl host name and get preprod and prod\n      let _url = new URL(INDEXED_ROUTE_MAP_URL);\n      if (jupiterLoadProps.marketUrl) {\n        _url.hostname = new URL(jupiterLoadProps.marketUrl).hostname;\n      }\n\n      let url = _url.toString();\n\n      routeMap = await Jupiter.getRemoteRouteMap(\n        { onlyDirectRoutes, restrictIntermediateTokens: jupiterLoadProps.restrictIntermediateTokens },\n        url,\n      );\n\n      setRouteMap(routeMap);\n    }\n    update();\n  }, [jupiterLoadProps.restrictIntermediateTokens, onlyDirectRoutes]);\n\n  const allTokenMints = useMemo(() => {\n    return Array.from(routeMap.keys());\n  }, [routeMap]);\n\n  return (\n    <JupiterContext.Provider\n      value={{\n        jupiter,\n        allTokenMints,\n        connection: jupiterLoadProps.connection,\n        cluster: jupiterLoadProps.cluster,\n        routeCacheDuration: jupiterLoadProps.routeCacheDuration,\n        routeMap,\n        error,\n        setError,\n        onlyDirectRoutes,\n      }}\n    >\n      {children}\n    </JupiterContext.Provider>\n  );\n};\n\ninterface UseJupiterProps {\n  amount: JSBI;\n  inputMint: PublicKey | undefined;\n  outputMint: PublicKey | undefined;\n  slippage: number;\n  /* inputAmount is being debounced, debounceTime 0 to disable debounce */\n  debounceTime?: number;\n  swapMode?: SwapMode;\n  enforceSingleTx?: boolean;\n}\n\nexport const useJupiterRouteMap = () => {\n  const context = useContext(JupiterContext);\n  if (!context) {\n    throw new Error('JupiterProvider is required');\n  }\n  return context.routeMap;\n};\n\nexport const useJupiter = ({\n  amount,\n  inputMint,\n  outputMint,\n  slippage,\n  debounceTime = 250,\n  swapMode = SwapMode.ExactIn,\n  enforceSingleTx,\n}: UseJupiterProps): UseJupiterResult => {\n  const context = useContext(JupiterContext);\n  const [loading, setLoading] = useState(false);\n  const [routes, setRoutes] = useState<RouteInfo[]>();\n  const [refreshCount, setRefreshCount] = useState<number>(0);\n  // lastRefreshCount indicate when the last refresh was triggered on which refreshCount\n  const lastRefreshCount = useRef<number>(refreshCount);\n\n  const [debouncedAmount, debouncedInputMint, debouncedOutputMint] = useDebounce(\n    React.useMemo(\n      () => [amount, inputMint, outputMint],\n      [amount.toString(), inputMint?.toBase58(), outputMint?.toBase58()],\n    ),\n    debounceTime,\n  );\n\n  const lastRefreshTimestamp = useRef<number>(0);\n  const lastQueryTimestamp = useRef<number>(0);\n\n  if (!context) {\n    throw new Error('JupiterProvider is required');\n  }\n\n  const { routeMap, allTokenMints, jupiter, error, setError, routeCacheDuration = 0, onlyDirectRoutes } = context;\n\n  // lastRefreshCount to determine when the last refresh was triggered, reset this to -1 to trigger a re-fetch\n  useEffect(() => {\n    lastRefreshCount.current = -1;\n  }, [[debouncedInputMint?.toString(), debouncedOutputMint?.toString()].sort().join('-'), slippage]);\n\n  useEffect(() => {\n    // if now - lastRefreshTimestamp > routeCacheDuration, then we need to refresh\n    if (lastRefreshTimestamp.current && new Date().getTime() - lastRefreshTimestamp.current >= routeCacheDuration) {\n      lastRefreshCount.current = -1;\n    }\n\n    if (JSBI.greaterThan(debouncedAmount, JSBI.BigInt(0)) && refreshCount !== lastRefreshCount.current) {\n      // don't set loading if there is no input amount\n      setLoading(true);\n    }\n  }, [refreshCount, debouncedAmount, slippage, debouncedInputMint, debouncedOutputMint, onlyDirectRoutes]);\n\n  useEffect(() => {\n    if (!jupiter) {\n      return;\n    }\n\n    if (JSBI.equal(debouncedAmount, JSBI.BigInt(0)) || error === Errors.INITIALIZE_ERROR) {\n      setRoutes(undefined);\n    } else if (debouncedAmount) {\n      if (!debouncedInputMint || !debouncedOutputMint || !routeMap) return;\n      let lastUpdatedTime = new Date().getTime();\n      lastQueryTimestamp.current = lastUpdatedTime;\n\n      jupiter\n        .computeRoutes({\n          inputMint: debouncedInputMint,\n          outputMint: debouncedOutputMint,\n          amount: debouncedAmount,\n          slippageBps: Math.ceil(slippage * 100),\n          forceFetch: refreshCount !== lastRefreshCount.current,\n          onlyDirectRoutes,\n          swapMode,\n          enforceSingleTx,\n        })\n        .then(({ routesInfos, cached }) => {\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          setRoutes(routesInfos);\n          setError(undefined);\n\n          if (!cached) {\n            lastRefreshTimestamp.current = new Date().getTime();\n          }\n        })\n        .catch((e) => {\n          console.error(e);\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          // Clear routes when erring to avoid bad pricing\n          setRoutes(undefined);\n          setError(Errors.ROUTES_ERROR);\n        })\n        .finally(() => {\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          lastRefreshCount.current = refreshCount;\n          setLoading(false);\n        });\n    }\n  }, [\n    jupiter,\n    debouncedAmount,\n    debouncedInputMint,\n    debouncedOutputMint,\n    slippage,\n    refreshCount,\n    onlyDirectRoutes,\n    enforceSingleTx,\n  ]);\n\n  const exchange: UseJupiterResult['exchange'] = useCallback(\n    async ({ wallet, routeInfo, onTransaction, ...restExchangeProps }): Promise<SwapResult> => {\n      if (error) {\n        throw new Error(error);\n      }\n\n      if (!jupiter) {\n        throw new Error('Jupiter not initialized');\n      }\n\n      if (!routeInfo) {\n        throw new Error('Invalid state, impossible to build transaction');\n      }\n\n      const { execute } = await jupiter.exchange({ routeInfo, ...restExchangeProps });\n\n      const result = await execute({ wallet, onTransaction });\n\n      return result;\n    },\n    [jupiter],\n  );\n\n  return {\n    allTokenMints,\n    routeMap,\n    exchange,\n    refresh: () => {\n      if (!loading && lastRefreshTimestamp.current) {\n        setRefreshCount((refreshCount) => refreshCount + 1);\n      }\n    },\n    lastRefreshTimestamp: lastRefreshTimestamp.current,\n    loading,\n    routes,\n    error,\n  };\n};\n\nexport { TOKEN_LIST_URL, JUPITER_ERRORS, MARKETS_URL, Errors };\nexport * from '@jup-ag/core';\n"],"names":["Errors","INITIALIZE_ERROR","ROUTES_ERROR","useDebounce","value","delay","debouncedValue","setDebouncedValue","useState","useEffect","handler","setTimeout","clearTimeout","JupiterContext","createContext","JupiterProvider","onlyDirectRoutes","userPublicKey","children","jupiterLoadProps","jupiter","setJupiter","routeMap","setRouteMap","Map","error","setError","undefined","_jupiter","Jupiter","load","e","console","Object","values","setUserPublicKey","async","let","_url","URL","INDEXED_ROUTE_MAP_URL","marketUrl","hostname","url","toString","getRemoteRouteMap","restrictIntermediateTokens","update","allTokenMints","useMemo","Array","from","keys","React","createElement","Provider","connection","cluster","routeCacheDuration","useJupiterRouteMap","context","useContext","Error","useJupiter","amount","inputMint","outputMint","slippage","debounceTime","swapMode","SwapMode","ExactIn","enforceSingleTx","loading","setLoading","routes","setRoutes","refreshCount","setRefreshCount","lastRefreshCount","useRef","debouncedAmount","debouncedInputMint","debouncedOutputMint","toBase58","lastRefreshTimestamp","lastQueryTimestamp","current","sort","join","Date","getTime","JSBI","greaterThan","BigInt","equal","lastUpdatedTime","computeRoutes","slippageBps","Math","ceil","forceFetch","then","routesInfos","cached","catch","finally","exchange","useCallback","wallet","routeInfo","onTransaction","restExchangeProps","execute","refresh"],"mappings":"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"}