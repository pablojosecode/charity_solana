"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReserveParams = exports.ReserveTokenInfo = exports.ReserveAssetInfo = exports.ReserveInfo = void 0;
/* eslint-disable new-cap */
const ReserveId_1 = require("./ReserveId");
const Asset_1 = require("./Asset");
const Share_1 = require("./Share");
const AssetExchangeRate_1 = require("./AssetExchangeRate");
const ReserveUtilizationRatio_1 = require("./ReserveUtilizationRatio");
const ReserveBorrowRate_1 = require("./ReserveBorrowRate");
const big_js_1 = __importDefault(require("big.js"));
const MintId_1 = require("./MintId");
const Apy_1 = require("./Apy");
const MarketId_1 = require("./MarketId");
const basic_1 = require("./basic");
const AssetPrice_1 = require("./AssetPrice");
const QuantityContext_1 = require("./QuantityContext");
const AssetValue_1 = require("./AssetValue");
const web3_js_1 = require("@solana/web3.js");
const instructions_1 = require("../instructions");
const structs_1 = require("../structs");
const constants_1 = require("../constants");
class ReserveInfo {
    constructor(reserveId, marketId, asset, share, params, stakingPoolId, proto) {
        this.reserveId = reserveId;
        this.marketId = marketId;
        this.asset = asset;
        this.share = share;
        this.params = params;
        this.stakingPoolId = stakingPoolId;
        this.proto = proto;
    }
    static fromRaw(raw) {
        const buffer = raw.account.data;
        const proto = structs_1.ReserveLayout.decode(buffer);
        const marketId = MarketId_1.MarketId.of(proto.lendingMarket);
        const asset = ReserveAssetInfo.fromRaw(proto.liquidity);
        const token = ReserveTokenInfo.fromRaw(proto.collateral);
        const params = ReserveParams.fromRaw(asset.getMintId(), proto.config);
        const stakingPoolId = proto.config.stakingPoolId;
        return new ReserveInfo(ReserveId_1.ReserveId.of(raw.pubkey), marketId, asset, token, params, stakingPoolId, proto);
    }
    getProto() {
        return this.proto;
    }
    getId() {
        return this.getReserveId();
    }
    getReserveId() {
        return this.reserveId;
    }
    getMarketId() {
        return this.marketId;
    }
    getAssetMintId() {
        return this.asset.getMintId();
    }
    getAssetBalanceId() {
        return this.asset.getSplAccountId();
    }
    getShareMintId() {
        return this.share.getMintId();
    }
    getShareBalanceId() {
        return this.share.getSplAccountId();
    }
    getOracleId() {
        return this.asset.getOracleId();
    }
    getFeeBalanceId() {
        return this.asset.getFeeAccountId();
    }
    // new input arg
    getMarketCap(price) {
        const asset = this.getTotalAsset();
        return new AssetValue_1.AssetValue(asset, asset.toValue(price !== null && price !== void 0 ? price : this.getMarkPrice(), this.getQuantityContext()));
    }
    getTotalAsset() {
        return this.getAvailableAsset().add(this.getBorrowedAsset());
    }
    // new input arg
    getAvailableAssetValue(price) {
        const asset = this.getAvailableAsset();
        return new AssetValue_1.AssetValue(asset, asset.toValue(price !== null && price !== void 0 ? price : this.getMarkPrice(), this.getQuantityContext()));
    }
    getAvailableAsset() {
        return this.asset.getAvailableAsset();
    }
    // new input arg
    getBorrowedAssetValue(price) {
        const asset = this.getBorrowedAsset();
        return new AssetValue_1.AssetValue(asset, asset.toValue(price !== null && price !== void 0 ? price : this.getMarkPrice(), this.getQuantityContext()));
    }
    getBorrowedAsset() {
        return this.asset.getBorrowedAsset();
    }
    getQuantityContext() {
        return this.asset.getQuantityContext();
    }
    getMarkPrice() {
        return this.asset.getMarkPrice();
    }
    getExchangeRatio() {
        const asset = this.getTotalAsset();
        const share = this.share.getIssuedShare();
        const assetMintId = asset.getMintId();
        const shareMintId = share.getMintId();
        if (asset.isZero()) {
            return new AssetExchangeRate_1.AssetExchangeRate(shareMintId, assetMintId);
        }
        const ratio = basic_1.Percentage.fromOneBased(share.getRaw().div(asset.getRaw()));
        return new AssetExchangeRate_1.AssetExchangeRate(shareMintId, assetMintId, ratio);
    }
    getUtilizationRatio() {
        const total = this.getTotalAsset();
        if (total.isZero()) {
            return ReserveUtilizationRatio_1.ReserveUtilizationRatio.na(total.getMintId());
        }
        const pct = basic_1.Percentage.fromOneBased(this.getBorrowedAsset().getRaw().div(total.getRaw()));
        return new ReserveUtilizationRatio_1.ReserveUtilizationRatio(total.getMintId(), pct);
    }
    getSupplyApy() {
        const utilizationRatio = this.getUtilizationRatio();
        const borrowApy = this.getBorrowApy();
        if (!utilizationRatio.isPresent() || !borrowApy.isPresent()) {
            return Apy_1.Apy.na();
        }
        const utilizationRatioRaw = utilizationRatio.getUnchecked();
        const borrowApyRaw = borrowApy.getUnchecked();
        return Apy_1.Apy.of(utilizationRatioRaw.mul(borrowApyRaw));
    }
    getBorrowApy() {
        const params = this.params;
        const utilizationRatio = this.getUtilizationRatio();
        const optimalUtilizationRatio = params.optimalUtilizationRatio;
        const optimalBorrowRate = params.optimalBorrowRate;
        if (!utilizationRatio.isPresent() ||
            !optimalUtilizationRatio.isPresent() ||
            !optimalBorrowRate.isPresent()) {
            return Apy_1.Apy.na();
        }
        const utilizationRatioRaw = utilizationRatio.getUnchecked();
        const optimalUtilizationRatioRaw = optimalUtilizationRatio.getUnchecked();
        const optimalBorrowRateRaw = optimalBorrowRate.getUnchecked();
        if (optimalUtilizationRatioRaw.eq(1) ||
            utilizationRatioRaw.lt(optimalUtilizationRatioRaw)) {
            const minBorrowRate = params.minBorrowRate;
            if (!minBorrowRate.isPresent()) {
                return Apy_1.Apy.na();
            }
            const minBorrowRateRaw = minBorrowRate.getUnchecked();
            const normalizedFactor = utilizationRatioRaw.div(optimalUtilizationRatioRaw);
            const borrowRateDiff = optimalBorrowRateRaw.sub(minBorrowRateRaw);
            return Apy_1.Apy.of(normalizedFactor.mul(borrowRateDiff).add(minBorrowRateRaw));
        }
        const maxBorrowRate = params.maxBorrowRate;
        if (!maxBorrowRate.isPresent()) {
            return Apy_1.Apy.na();
        }
        const maxBorrowRateRaw = maxBorrowRate.getUnchecked();
        const normalizedFactor = utilizationRatioRaw
            .sub(optimalUtilizationRatioRaw)
            .div(new big_js_1.default(1).sub(optimalUtilizationRatioRaw));
        const borrowRateDiff = maxBorrowRateRaw.sub(optimalBorrowRateRaw);
        return Apy_1.Apy.of(normalizedFactor.mul(borrowRateDiff).add(optimalBorrowRateRaw));
    }
    getStakingPoolId() {
        return this.stakingPoolId;
    }
    // add reserve instructions ,use in Sundial
    getMarketAuthority() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield web3_js_1.PublicKey.findProgramAddress([this.getMarketId().toBuffer()], constants_1.PORT_LENDING);
        });
    }
    depositReserve({ amount, userLiquidityWallet, destinationCollateralWallet, userTransferAuthority, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push((0, instructions_1.refreshReserveInstruction)(this.getReserveId(), (_a = this.getOracleId()) !== null && _a !== void 0 ? _a : null), (0, instructions_1.depositReserveLiquidityInstruction)(amount, userLiquidityWallet, destinationCollateralWallet, this.getReserveId(), this.getAssetBalanceId(), this.getShareMintId(), this.getMarketId(), authority, userTransferAuthority));
            return ixs;
        });
    }
    depositObligationCollateral({ amount, userCollateralWallet, obligation, obligationOwner, userTransferAuthority, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push((0, instructions_1.refreshReserveInstruction)(this.getReserveId(), (_a = this.getOracleId()) !== null && _a !== void 0 ? _a : null), (0, instructions_1.depositObligationCollateralInstruction)(amount, userCollateralWallet, this.getShareBalanceId(), this.getReserveId(), obligation, this.getMarketId(), authority, obligationOwner, userTransferAuthority));
            return ixs;
        });
    }
    borrowObligationLiquidity({ amount, userWallet, owner, obligation, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push((0, instructions_1.borrowObligationLiquidityInstruction)(amount, this.getAssetBalanceId(), userWallet, this.getReserveId(), this.getFeeBalanceId(), obligation, this.getMarketId(), authority, owner));
            return ixs;
        });
    }
    redeemCollateral({ amount, userCollateralWallet, destinationLiquidityWallet, userTransferAuthority, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push((0, instructions_1.redeemReserveCollateralInstruction)(amount, userCollateralWallet, destinationLiquidityWallet, this.getReserveId(), this.getShareMintId(), this.getAssetBalanceId(), this.getMarketId(), authority, userTransferAuthority));
            return ixs;
        });
    }
}
exports.ReserveInfo = ReserveInfo;
class ReserveAssetInfo {
    constructor(mintId, oracleId, feeBalanceId, supplyAccountId, available, borrowed, markPrice, cumulativeBorrowRate, quantityContext) {
        this.mintId = mintId;
        this.oracleId = oracleId;
        this.feeAccountId = feeBalanceId;
        this.supplyAccountId = supplyAccountId;
        this.available = available;
        this.borrowed = borrowed;
        this.markPrice = markPrice;
        this.cumulativeBorrowRate = cumulativeBorrowRate;
        this.quantityContext = quantityContext;
    }
    static fromRaw(raw) {
        const mintId = raw.mintPubkey;
        const oracleId = raw.oracleOption === 1 ? MintId_1.MintId.of(raw.oraclePubkey) : null;
        const feeAccountId = raw.feeReceiver;
        const supplyBalanceId = raw.supplyPubkey;
        const available = Asset_1.Asset.of(mintId, raw.availableAmount);
        const borrowed = Asset_1.Asset.of(mintId, raw.borrowedAmountWads);
        const markPrice = AssetPrice_1.AssetPrice.of(mintId, raw.marketPrice);
        const cumulativeBorrowRate = raw.cumulativeBorrowRateWads;
        const quantityContext = QuantityContext_1.QuantityContext.fromDecimals(raw.mintDecimals);
        return new ReserveAssetInfo(mintId, oracleId, feeAccountId, supplyBalanceId, available, borrowed, markPrice, cumulativeBorrowRate, quantityContext);
    }
    getMintId() {
        return this.mintId;
    }
    getOracleId() {
        return this.oracleId;
    }
    getFeeAccountId() {
        return this.feeAccountId;
    }
    getSplAccountId() {
        return this.supplyAccountId;
    }
    getAvailableAsset() {
        return this.available;
    }
    getBorrowedAsset() {
        return this.borrowed;
    }
    getMarkPrice() {
        return this.markPrice;
    }
    getCumulativeBorrowRate() {
        return this.cumulativeBorrowRate;
    }
    getQuantityContext() {
        return this.quantityContext;
    }
}
exports.ReserveAssetInfo = ReserveAssetInfo;
class ReserveTokenInfo {
    constructor(mintId, splAccount, issuedShare) {
        this.mintId = mintId;
        this.splAccountId = splAccount;
        this.issuedShare = issuedShare;
    }
    static fromRaw(raw) {
        const mintId = raw.mintPubkey;
        const splAccountId = raw.supplyPubkey;
        const issuedShare = Share_1.Share.of(mintId, raw.mintTotalSupply);
        return new ReserveTokenInfo(mintId, splAccountId, issuedShare);
    }
    getMintId() {
        return this.mintId;
    }
    getSplAccountId() {
        return this.splAccountId;
    }
    getIssuedShare() {
        return this.issuedShare;
    }
}
exports.ReserveTokenInfo = ReserveTokenInfo;
class ReserveParams {
    constructor(loanToValueRatio, optimalUtilizationRatio, optimalBorrowRate, minBorrowRate, maxBorrowRate, liquidationThreshold, liquidationPenalty, borrowFee) {
        this.loanToValueRatio = loanToValueRatio;
        this.optimalUtilizationRatio = optimalUtilizationRatio;
        this.optimalBorrowRate = optimalBorrowRate;
        this.minBorrowRate = minBorrowRate;
        this.maxBorrowRate = maxBorrowRate;
        this.liquidationThreshold = liquidationThreshold;
        this.liquidationPenalty = liquidationPenalty;
        this.borrowFee = borrowFee;
    }
    static fromRaw(mintId, config) {
        const loanToValueRatio = config.loanToValueRatio;
        const optimalUtilizationRatio = new ReserveUtilizationRatio_1.ReserveUtilizationRatio(mintId, config.optimalUtilizationRate);
        const optimalBorrowRate = new ReserveBorrowRate_1.ReserveBorrowRate(mintId, config.optimalBorrowRate);
        const minBorrowRate = new ReserveBorrowRate_1.ReserveBorrowRate(mintId, config.minBorrowRate);
        const maxBorrowRate = new ReserveBorrowRate_1.ReserveBorrowRate(mintId, config.maxBorrowRate);
        const liquidationThreshold = config.liquidationThreshold;
        const liquidationPenalty = config.liquidationBonus;
        const borrowFee = basic_1.Percentage.fromOneBased(config.fees.borrowFeeWad);
        return new ReserveParams(loanToValueRatio, optimalUtilizationRatio, optimalBorrowRate, minBorrowRate, maxBorrowRate, liquidationThreshold, liquidationPenalty, borrowFee);
    }
}
exports.ReserveParams = ReserveParams;
//# sourceMappingURL=ReserveInfo.js.map