"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakeAccountContext = void 0;
class StakeAccountContext {
    constructor(accounts, byStakeAccountId, byStakingPoolId) {
        this.accounts = accounts;
        this.byStakeAccountId = byStakeAccountId;
        this.byStakingPoolId = byStakingPoolId;
    }
    static empty() {
        return StakeAccountContext.STAKE_ACCOUNT_CONTEXT_EMPTY;
    }
    static index(accounts) {
        if (!accounts.length) {
            return StakeAccountContext.empty();
        }
        const byStakeAccountId = new Map();
        accounts.forEach((a) => byStakeAccountId.set(a.getStakeAccountId().toString(), a));
        const byStakingPoolId = new Map();
        accounts.forEach((a) => byStakingPoolId.set(a.getStakingPoolId().toString(), a));
        return new StakeAccountContext(accounts, byStakeAccountId, byStakingPoolId);
    }
    getAllStakeAccounts() {
        return this.accounts;
    }
    getStakeAccount(stakeAccountId) {
        const result = this.findStakeAccount(stakeAccountId);
        if (!result) {
            throw new Error(`No account for ${stakeAccountId}`);
        }
        return result;
    }
    getStakeAccountByStakingPoolId(stakingPoolId) {
        const result = this.findStakeAccountByStakingPoolId(stakingPoolId);
        if (!result) {
            throw new Error(`No account for staking pool ${stakingPoolId}`);
        }
        return result;
    }
    findStakeAccount(stakeAccountId) {
        const key = stakeAccountId.toString();
        return this.byStakeAccountId.get(key);
    }
    findStakeAccountByStakingPoolId(stakingPoolId) {
        const key = stakingPoolId.toString();
        return this.byStakingPoolId.get(key);
    }
}
exports.StakeAccountContext = StakeAccountContext;
StakeAccountContext.STAKE_ACCOUNT_CONTEXT_EMPTY = new StakeAccountContext([], new Map(), new Map());
//# sourceMappingURL=StakeAccountContext.js.map