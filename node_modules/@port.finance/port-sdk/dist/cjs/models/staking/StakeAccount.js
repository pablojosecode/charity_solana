"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakeAccount = void 0;
const StakeAccountId_1 = require("./StakeAccountId");
const ExchangeRate_1 = require("../ExchangeRate");
const basic_1 = require("../basic");
const structs_1 = require("../../structs");
class StakeAccount {
    constructor(stakeAccountId, stakingPoolId, startRate, depositedAmount, unclaimedReward) {
        this.stakeAccountId = stakeAccountId;
        this.stakingPoolId = stakingPoolId;
        this.startRate = startRate;
        this.depositedAmount = depositedAmount;
        this.unclaimedReward = unclaimedReward;
    }
    static newAccount(stakeAccountId, stakingPoolId) {
        return new StakeAccount(stakeAccountId, stakingPoolId, ExchangeRate_1.ExchangeRate.zero(), basic_1.Lamport.zero(), basic_1.Lamport.zero());
    }
    static fromRaw(raw) {
        const buffer = Buffer.from(raw.account.data);
        const proto = structs_1.StakeAccountLayout.decode(buffer);
        const stakeAccountId = StakeAccountId_1.StakeAccountId.of(raw.pubkey);
        return new StakeAccount(stakeAccountId, proto.poolPubkey, proto.startRate, proto.depositedAmount, proto.unclaimedRewardWads);
    }
    getId() {
        return this.getStakeAccountId();
    }
    getStakeAccountId() {
        return this.stakeAccountId;
    }
    getStakingPoolId() {
        return this.stakingPoolId;
    }
    getStartRate() {
        return this.startRate;
    }
    getDepositAmount() {
        return this.depositedAmount;
    }
    getUnclaimedReward() {
        return this.unclaimedReward;
    }
    getTotalClaimableReward(rate) {
        const rateDiff = rate.subtract(this.getStartRate());
        if (rateDiff.isNegative()) {
            throw new Error("Rate lower than start rate");
        }
        const extraClaimable = this.getDepositAmount().multiply(rateDiff.getRaw());
        return extraClaimable.add(this.getUnclaimedReward());
    }
}
exports.StakeAccount = StakeAccount;
//# sourceMappingURL=StakeAccount.js.map