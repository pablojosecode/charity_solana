"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakingPool = void 0;
const StakingPoolId_1 = require("./StakingPoolId");
const ExchangeRate_1 = require("../ExchangeRate");
const Apy_1 = require("../Apy");
const Share_1 = require("../Share");
const AssetPrice_1 = require("../AssetPrice");
const structs_1 = require("../../structs");
const __1 = require("..");
const SLOT_PER_SECOND = 2;
const SLOT_PER_YEAR = SLOT_PER_SECOND * 3600 * 24 * 365;
class StakingPool {
    constructor(stakingPoolId, rewardTokenPool, lastUpdate, endTime, earliestRewardClaimTime, duration, ratePerSlot, cumulativeRate, poolSize, ownerAuthority, adminAuthority, subRewardTokenPool, subRatePerSlot, subCumulativeRate) {
        this.stakingPoolId = stakingPoolId;
        this.rewardTokenPool = rewardTokenPool;
        this.lastUpdate = lastUpdate;
        this.endTime = endTime;
        this.earliestRewardClaimTime = earliestRewardClaimTime;
        this.duration = duration;
        this.ratePerSlot = ratePerSlot;
        this.cumulativeRate = cumulativeRate;
        this.poolSize = poolSize;
        this.ownerAuthority = ownerAuthority;
        this.adminAuthority = adminAuthority;
        this.subRewardTokenPool = subRewardTokenPool;
        this.subRatePerSlot = subRatePerSlot;
        this.subCumulativeRate = subCumulativeRate;
    }
    static fromRaw(raw) {
        const buffer = Buffer.from(raw.account.data);
        const info = structs_1.StakingPoolLayout.decode(buffer);
        return new StakingPool(StakingPoolId_1.StakingPoolId.of(raw.pubkey), info.rewardTokenPool, info.lastUpdate, info.endTime, info.earliestRewardClaimTime, info.duration, info.ratePerSlot, info.cumulativeRate, info.poolSize, info.ownerAuthority, info.adminAuthority, info.subRewardTokenPoolOption === 1 ? info.subRewardTokenPool : undefined, info.subRatePerSlotOption === 1 ? info.subRatePerSlot : undefined, info.subCumulativeRateOption === 1 ? info.subCumulativeRate : undefined);
    }
    getOwnerAuthorityId() {
        return this.ownerAuthority;
    }
    getAdminAuthorityId() {
        return this.adminAuthority;
    }
    getId() {
        return this.getStakingPoolId();
    }
    getStakingPoolId() {
        return this.stakingPoolId;
    }
    getRewardTokenPool() {
        return this.rewardTokenPool;
    }
    getSubRewardTokenPool() {
        return this.subRewardTokenPool;
    }
    getLastUpdate() {
        return this.lastUpdate;
    }
    getEndTime() {
        return this.endTime;
    }
    getEarliestRewardClaimTime() {
        return this.earliestRewardClaimTime;
    }
    getDuration() {
        return this.duration;
    }
    getRatePerSlot() {
        return this.ratePerSlot;
    }
    getSubRatePerSlot() {
        return this.subRatePerSlot;
    }
    getCumulativeRate() {
        return this.cumulativeRate;
    }
    getSubCumulativeRate() {
        return this.cumulativeRate;
    }
    getPoolSize() {
        return this.poolSize;
    }
    isPoolEnd(currentSlot) {
        return this.getEndTime().lt(currentSlot);
    }
    getEstimatedRate(currentSlot) {
        const poolSize = this.getPoolSize();
        if (poolSize.isZero()) {
            return ExchangeRate_1.ExchangeRate.zero();
        }
        currentSlot = currentSlot.min(this.getEndTime());
        const slotDiff = currentSlot.subtract(this.getLastUpdate());
        if (slotDiff.isNegative()) {
            throw new Error("Slot older than last update");
        }
        const rateDiff = this.getRatePerSlot()
            .multiply(slotDiff.getRaw())
            .divide(poolSize.getRaw());
        return this.getCumulativeRate().add(rateDiff);
    }
    getRewardApy(reserve, price, tokenInfo) {
        return this.getRewardApyInner(reserve, tokenInfo, price.getRaw(), this.getRatePerSlot());
    }
    getSubRewardApy(reserve, price, tokenInfo) {
        const subRatePerSlot = this.getSubRatePerSlot();
        if (!subRatePerSlot) {
            return Apy_1.Apy.na();
        }
        else if (price instanceof AssetPrice_1.AssetPrice) {
            return this.getRewardApyInner(reserve, tokenInfo, price.getRaw(), subRatePerSlot);
        }
        else {
            return this.getRewardApyInner(reserve, tokenInfo, price, subRatePerSlot);
        }
    }
    getRewardApyInner(reserve, tokenInfo, price, ratePerSlot) {
        const poolSize = this.getPoolSize();
        if (!poolSize.isPositive()) {
            return Apy_1.Apy.na();
        }
        const share = Share_1.Share.of(reserve.getShareMintId(), poolSize);
        const asset = share.toAsset(reserve.getExchangeRatio());
        const tvl = asset.toValue(reserve.getMarkPrice(), reserve.getQuantityContext());
        const qtyContext = __1.QuantityContext.fromDecimals(tokenInfo.decimals);
        const raw = ratePerSlot
            .getRaw()
            .mul(SLOT_PER_YEAR)
            .mul(price)
            .div(qtyContext.multiplier)
            .div(tvl.getRaw());
        return Apy_1.Apy.of(raw);
    }
}
exports.StakingPool = StakingPool;
//# sourceMappingURL=StakingPool.js.map