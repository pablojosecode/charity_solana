var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable new-cap */
import { ReserveId } from "./ReserveId";
import { Asset } from "./Asset";
import { Share } from "./Share";
import { AssetExchangeRate } from "./AssetExchangeRate";
import { ReserveUtilizationRatio } from "./ReserveUtilizationRatio";
import { ReserveBorrowRate } from "./ReserveBorrowRate";
import Big from "big.js";
import { MintId } from "./MintId";
import { Apy } from "./Apy";
import { MarketId } from "./MarketId";
import { Percentage } from "./basic";
import { AssetPrice } from "./AssetPrice";
import { QuantityContext } from "./QuantityContext";
import { AssetValue } from "./AssetValue";
import { PublicKey } from "@solana/web3.js";
import { borrowObligationLiquidityInstruction, depositObligationCollateralInstruction, depositReserveLiquidityInstruction, redeemReserveCollateralInstruction, refreshReserveInstruction, } from "../instructions";
import { ReserveLayout, } from "../structs";
import { PORT_LENDING } from "../constants";
export class ReserveInfo {
    constructor(reserveId, marketId, asset, share, params, stakingPoolId, proto) {
        this.reserveId = reserveId;
        this.marketId = marketId;
        this.asset = asset;
        this.share = share;
        this.params = params;
        this.stakingPoolId = stakingPoolId;
        this.proto = proto;
    }
    static fromRaw(raw) {
        const buffer = raw.account.data;
        const proto = ReserveLayout.decode(buffer);
        const marketId = MarketId.of(proto.lendingMarket);
        const asset = ReserveAssetInfo.fromRaw(proto.liquidity);
        const token = ReserveTokenInfo.fromRaw(proto.collateral);
        const params = ReserveParams.fromRaw(asset.getMintId(), proto.config);
        const stakingPoolId = proto.config.stakingPoolId;
        return new ReserveInfo(ReserveId.of(raw.pubkey), marketId, asset, token, params, stakingPoolId, proto);
    }
    getProto() {
        return this.proto;
    }
    getId() {
        return this.getReserveId();
    }
    getReserveId() {
        return this.reserveId;
    }
    getMarketId() {
        return this.marketId;
    }
    getAssetMintId() {
        return this.asset.getMintId();
    }
    getAssetBalanceId() {
        return this.asset.getSplAccountId();
    }
    getShareMintId() {
        return this.share.getMintId();
    }
    getShareBalanceId() {
        return this.share.getSplAccountId();
    }
    getOracleId() {
        return this.asset.getOracleId();
    }
    getFeeBalanceId() {
        return this.asset.getFeeAccountId();
    }
    // new input arg
    getMarketCap(price) {
        const asset = this.getTotalAsset();
        return new AssetValue(asset, asset.toValue(price !== null && price !== void 0 ? price : this.getMarkPrice(), this.getQuantityContext()));
    }
    getTotalAsset() {
        return this.getAvailableAsset().add(this.getBorrowedAsset());
    }
    // new input arg
    getAvailableAssetValue(price) {
        const asset = this.getAvailableAsset();
        return new AssetValue(asset, asset.toValue(price !== null && price !== void 0 ? price : this.getMarkPrice(), this.getQuantityContext()));
    }
    getAvailableAsset() {
        return this.asset.getAvailableAsset();
    }
    // new input arg
    getBorrowedAssetValue(price) {
        const asset = this.getBorrowedAsset();
        return new AssetValue(asset, asset.toValue(price !== null && price !== void 0 ? price : this.getMarkPrice(), this.getQuantityContext()));
    }
    getBorrowedAsset() {
        return this.asset.getBorrowedAsset();
    }
    getQuantityContext() {
        return this.asset.getQuantityContext();
    }
    getMarkPrice() {
        return this.asset.getMarkPrice();
    }
    getExchangeRatio() {
        const asset = this.getTotalAsset();
        const share = this.share.getIssuedShare();
        const assetMintId = asset.getMintId();
        const shareMintId = share.getMintId();
        if (asset.isZero()) {
            return new AssetExchangeRate(shareMintId, assetMintId);
        }
        const ratio = Percentage.fromOneBased(share.getRaw().div(asset.getRaw()));
        return new AssetExchangeRate(shareMintId, assetMintId, ratio);
    }
    getUtilizationRatio() {
        const total = this.getTotalAsset();
        if (total.isZero()) {
            return ReserveUtilizationRatio.na(total.getMintId());
        }
        const pct = Percentage.fromOneBased(this.getBorrowedAsset().getRaw().div(total.getRaw()));
        return new ReserveUtilizationRatio(total.getMintId(), pct);
    }
    getSupplyApy() {
        const utilizationRatio = this.getUtilizationRatio();
        const borrowApy = this.getBorrowApy();
        if (!utilizationRatio.isPresent() || !borrowApy.isPresent()) {
            return Apy.na();
        }
        const utilizationRatioRaw = utilizationRatio.getUnchecked();
        const borrowApyRaw = borrowApy.getUnchecked();
        return Apy.of(utilizationRatioRaw.mul(borrowApyRaw));
    }
    getBorrowApy() {
        const params = this.params;
        const utilizationRatio = this.getUtilizationRatio();
        const optimalUtilizationRatio = params.optimalUtilizationRatio;
        const optimalBorrowRate = params.optimalBorrowRate;
        if (!utilizationRatio.isPresent() ||
            !optimalUtilizationRatio.isPresent() ||
            !optimalBorrowRate.isPresent()) {
            return Apy.na();
        }
        const utilizationRatioRaw = utilizationRatio.getUnchecked();
        const optimalUtilizationRatioRaw = optimalUtilizationRatio.getUnchecked();
        const optimalBorrowRateRaw = optimalBorrowRate.getUnchecked();
        if (optimalUtilizationRatioRaw.eq(1) ||
            utilizationRatioRaw.lt(optimalUtilizationRatioRaw)) {
            const minBorrowRate = params.minBorrowRate;
            if (!minBorrowRate.isPresent()) {
                return Apy.na();
            }
            const minBorrowRateRaw = minBorrowRate.getUnchecked();
            const normalizedFactor = utilizationRatioRaw.div(optimalUtilizationRatioRaw);
            const borrowRateDiff = optimalBorrowRateRaw.sub(minBorrowRateRaw);
            return Apy.of(normalizedFactor.mul(borrowRateDiff).add(minBorrowRateRaw));
        }
        const maxBorrowRate = params.maxBorrowRate;
        if (!maxBorrowRate.isPresent()) {
            return Apy.na();
        }
        const maxBorrowRateRaw = maxBorrowRate.getUnchecked();
        const normalizedFactor = utilizationRatioRaw
            .sub(optimalUtilizationRatioRaw)
            .div(new Big(1).sub(optimalUtilizationRatioRaw));
        const borrowRateDiff = maxBorrowRateRaw.sub(optimalBorrowRateRaw);
        return Apy.of(normalizedFactor.mul(borrowRateDiff).add(optimalBorrowRateRaw));
    }
    getStakingPoolId() {
        return this.stakingPoolId;
    }
    // add reserve instructions ,use in Sundial
    getMarketAuthority() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield PublicKey.findProgramAddress([this.getMarketId().toBuffer()], PORT_LENDING);
        });
    }
    depositReserve({ amount, userLiquidityWallet, destinationCollateralWallet, userTransferAuthority, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push(refreshReserveInstruction(this.getReserveId(), (_a = this.getOracleId()) !== null && _a !== void 0 ? _a : null), depositReserveLiquidityInstruction(amount, userLiquidityWallet, destinationCollateralWallet, this.getReserveId(), this.getAssetBalanceId(), this.getShareMintId(), this.getMarketId(), authority, userTransferAuthority));
            return ixs;
        });
    }
    depositObligationCollateral({ amount, userCollateralWallet, obligation, obligationOwner, userTransferAuthority, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push(refreshReserveInstruction(this.getReserveId(), (_a = this.getOracleId()) !== null && _a !== void 0 ? _a : null), depositObligationCollateralInstruction(amount, userCollateralWallet, this.getShareBalanceId(), this.getReserveId(), obligation, this.getMarketId(), authority, obligationOwner, userTransferAuthority));
            return ixs;
        });
    }
    borrowObligationLiquidity({ amount, userWallet, owner, obligation, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push(borrowObligationLiquidityInstruction(amount, this.getAssetBalanceId(), userWallet, this.getReserveId(), this.getFeeBalanceId(), obligation, this.getMarketId(), authority, owner));
            return ixs;
        });
    }
    redeemCollateral({ amount, userCollateralWallet, destinationLiquidityWallet, userTransferAuthority, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [authority] = yield this.getMarketAuthority();
            const ixs = [];
            ixs.push(redeemReserveCollateralInstruction(amount, userCollateralWallet, destinationLiquidityWallet, this.getReserveId(), this.getShareMintId(), this.getAssetBalanceId(), this.getMarketId(), authority, userTransferAuthority));
            return ixs;
        });
    }
}
export class ReserveAssetInfo {
    constructor(mintId, oracleId, feeBalanceId, supplyAccountId, available, borrowed, markPrice, cumulativeBorrowRate, quantityContext) {
        this.mintId = mintId;
        this.oracleId = oracleId;
        this.feeAccountId = feeBalanceId;
        this.supplyAccountId = supplyAccountId;
        this.available = available;
        this.borrowed = borrowed;
        this.markPrice = markPrice;
        this.cumulativeBorrowRate = cumulativeBorrowRate;
        this.quantityContext = quantityContext;
    }
    static fromRaw(raw) {
        const mintId = raw.mintPubkey;
        const oracleId = raw.oracleOption === 1 ? MintId.of(raw.oraclePubkey) : null;
        const feeAccountId = raw.feeReceiver;
        const supplyBalanceId = raw.supplyPubkey;
        const available = Asset.of(mintId, raw.availableAmount);
        const borrowed = Asset.of(mintId, raw.borrowedAmountWads);
        const markPrice = AssetPrice.of(mintId, raw.marketPrice);
        const cumulativeBorrowRate = raw.cumulativeBorrowRateWads;
        const quantityContext = QuantityContext.fromDecimals(raw.mintDecimals);
        return new ReserveAssetInfo(mintId, oracleId, feeAccountId, supplyBalanceId, available, borrowed, markPrice, cumulativeBorrowRate, quantityContext);
    }
    getMintId() {
        return this.mintId;
    }
    getOracleId() {
        return this.oracleId;
    }
    getFeeAccountId() {
        return this.feeAccountId;
    }
    getSplAccountId() {
        return this.supplyAccountId;
    }
    getAvailableAsset() {
        return this.available;
    }
    getBorrowedAsset() {
        return this.borrowed;
    }
    getMarkPrice() {
        return this.markPrice;
    }
    getCumulativeBorrowRate() {
        return this.cumulativeBorrowRate;
    }
    getQuantityContext() {
        return this.quantityContext;
    }
}
export class ReserveTokenInfo {
    constructor(mintId, splAccount, issuedShare) {
        this.mintId = mintId;
        this.splAccountId = splAccount;
        this.issuedShare = issuedShare;
    }
    static fromRaw(raw) {
        const mintId = raw.mintPubkey;
        const splAccountId = raw.supplyPubkey;
        const issuedShare = Share.of(mintId, raw.mintTotalSupply);
        return new ReserveTokenInfo(mintId, splAccountId, issuedShare);
    }
    getMintId() {
        return this.mintId;
    }
    getSplAccountId() {
        return this.splAccountId;
    }
    getIssuedShare() {
        return this.issuedShare;
    }
}
export class ReserveParams {
    constructor(loanToValueRatio, optimalUtilizationRatio, optimalBorrowRate, minBorrowRate, maxBorrowRate, liquidationThreshold, liquidationPenalty, borrowFee) {
        this.loanToValueRatio = loanToValueRatio;
        this.optimalUtilizationRatio = optimalUtilizationRatio;
        this.optimalBorrowRate = optimalBorrowRate;
        this.minBorrowRate = minBorrowRate;
        this.maxBorrowRate = maxBorrowRate;
        this.liquidationThreshold = liquidationThreshold;
        this.liquidationPenalty = liquidationPenalty;
        this.borrowFee = borrowFee;
    }
    static fromRaw(mintId, config) {
        const loanToValueRatio = config.loanToValueRatio;
        const optimalUtilizationRatio = new ReserveUtilizationRatio(mintId, config.optimalUtilizationRate);
        const optimalBorrowRate = new ReserveBorrowRate(mintId, config.optimalBorrowRate);
        const minBorrowRate = new ReserveBorrowRate(mintId, config.minBorrowRate);
        const maxBorrowRate = new ReserveBorrowRate(mintId, config.maxBorrowRate);
        const liquidationThreshold = config.liquidationThreshold;
        const liquidationPenalty = config.liquidationBonus;
        const borrowFee = Percentage.fromOneBased(config.fees.borrowFeeWad);
        return new ReserveParams(loanToValueRatio, optimalUtilizationRatio, optimalBorrowRate, minBorrowRate, maxBorrowRate, liquidationThreshold, liquidationPenalty, borrowFee);
    }
}
//# sourceMappingURL=ReserveInfo.js.map