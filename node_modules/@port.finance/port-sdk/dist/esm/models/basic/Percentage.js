import Big from "big.js";
import { Decimal, DecimalField } from "./Decimal";
import { BigType } from "../../serialization/BigType";
export class Percentage extends Decimal {
    constructor(value) {
        super(value);
    }
    static zero() {
        return Percentage.PCT_ZERO;
    }
    static hundred() {
        return Percentage.PCT_HUNDRED;
    }
    static fromOneBased(oneBased) {
        return Percentage.fromRaw(oneBased, false);
    }
    static fromHundredBased(hundredBased) {
        return Percentage.fromRaw(hundredBased, true);
    }
    static fromRaw(raw, isHundredBased) {
        const big = new Big(raw);
        if (!isHundredBased) {
            return new Percentage(big);
        }
        return new Percentage(big.div(100));
    }
    static field(property) {
        return new PercentageField(true, property);
    }
    isTrivial() {
        return this.lt(Percentage.PCT_BIP);
    }
    isHundredPct() {
        return this.eq(Percentage.PCT_HUNDRED);
    }
    toOneBasedNumber(dp) {
        return this.raw.round(dp).toNumber();
    }
    toHundredBasedNumber(dp) {
        return this.raw.mul(100).round(dp, 0).toNumber();
    }
    print() {
        if (this.gt(Percentage.PCT_THOUSAND)) {
            return this.raw.round(1, 1).toString() + "x"; // RoundHalfUp
        }
        return this.raw.mul(100).round(2, 1).toString() + "%"; // RoundHalfUp
    }
    replaceWithValue(value) {
        return new Percentage(value);
    }
}
Percentage.PCT_BIP = new Percentage(0.0001);
Percentage.PCT_ZERO = new Percentage(0);
Percentage.PCT_HUNDRED = new Percentage(1);
Percentage.PCT_THOUSAND = new Percentage(10);
class PercentageField extends DecimalField {
    constructor(isHundredBased, property) {
        super(BigType.U8, property);
        this.isHundredBased = isHundredBased;
    }
    fromBig(big) {
        return Percentage.fromRaw(big, this.isHundredBased);
    }
}
//# sourceMappingURL=Percentage.js.map