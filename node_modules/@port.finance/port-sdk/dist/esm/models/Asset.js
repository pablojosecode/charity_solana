import Big from "big.js";
import { Token, Lamport } from "./basic";
import { QuoteValue } from "./QuoteValue";
import { Share } from "./Share";
import { MintId } from "./MintId";
export class Asset extends Token {
    constructor(mintId, lamport) {
        super(mintId, lamport);
    }
    static fromString(str, mintId, context) {
        const increment = context.multiplier;
        const lamport = Lamport.of(new Big(str).mul(increment).round(0, 0));
        return new Asset(mintId, lamport);
    }
    static zero(mintId) {
        return Asset.of(mintId);
    }
    static max(mintId) {
        return Asset.of(mintId, Lamport.max());
    }
    static native(lamport) {
        return Asset.of(MintId.native(), lamport);
    }
    static fromTokenAccount(account) {
        return Asset.of(account.getMintId(), account.getAmount());
    }
    static of(mintId, lamport) {
        return new Asset(mintId, lamport || Lamport.zero());
    }
    isNative() {
        return this.getMintId().isNative();
    }
    toValue(price, quantityContext) {
        console.assert(this.getMintId().equals(price.getMintId()), `asset id: ${this.getMintId()} price id: ${price.getMintId()}`);
        if (!price) {
            return QuoteValue.zero();
        }
        const increment = quantityContext.multiplier;
        const value = this.getRaw().div(increment).mul(price.getRaw());
        return QuoteValue.of(value);
    }
    toInterest(supplyApy) {
        if (!supplyApy.isPresent()) {
            return Asset.zero(this.getMintId());
        }
        const lamport = Lamport.of(this.getRaw().mul(supplyApy.getUnchecked()));
        return Asset.of(this.getMintId(), lamport);
    }
    toShare(exchangeRatio) {
        console.assert(this.getMintId().equals(exchangeRatio.getAssetMintId()));
        if (!exchangeRatio.isPresent()) {
            return Share.zero(exchangeRatio.getShareMintId());
        }
        const lamport = Lamport.of(this.getRaw().mul(exchangeRatio.getUnchecked()).round(0));
        return Share.of(exchangeRatio.getShareMintId(), lamport);
    }
    addFee(pct) {
        return this.multiply(new Big(1).add(pct.getRaw()));
    }
    toNumber(context) {
        const multiplier = context.multiplier;
        const decimals = context.decimals;
        return this.getRaw().div(multiplier).round(decimals, 0).toNumber();
    }
    plain(context) {
        return this.toLimitRoundNumber(context).toString();
    }
    toLimitRoundNumber(context) {
        const multiplier = context.multiplier;
        const decimals = context.decimals;
        return this.getRaw()
            .div(multiplier)
            .round(Math.min(decimals, 6), 0)
            .toNumber();
    }
    print(context, symbol) {
        if (!context) {
            return "--";
        }
        const num = this.toLimitRoundNumber(context);
        const formatted = num > Asset.LARGE_THRESHOLD
            ? Asset.FORMATTER_LARGE.format(num)
            : Asset.FORMATTER_NORMAL.format(num);
        if (!symbol) {
            return formatted;
        }
        return formatted + " " + symbol;
    }
    wrap(value) {
        return Asset.of(this.getMintId(), value);
    }
}
Asset.MIN_NATIVE_LAMPORT = Asset.native(Lamport.of(5000000));
Asset.SIGNIFICANT_DIGITS = 6;
Asset.LARGE_THRESHOLD = new Big(10).pow(6).toNumber();
Asset.FORMATTER_NORMAL = new Intl.NumberFormat("en-US", {
    style: "decimal",
    maximumSignificantDigits: Asset.SIGNIFICANT_DIGITS,
});
Asset.FORMATTER_LARGE = new Intl.NumberFormat("en-US", {
    style: "decimal",
    maximumFractionDigits: 0,
});
//# sourceMappingURL=Asset.js.map