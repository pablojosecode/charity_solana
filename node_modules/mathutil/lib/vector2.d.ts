import type { InputVector, Position } from './inputScalar';
export declare class Vector2 {
    pos: Position;
    /**
     * `x` and `y` refer to both direction and magnitude, they are stored in a
     * point array for performance
     * @constructs
     * @param x <Number>
     * @param y <Number>
     */
    constructor(x: number, y: number);
    static of(x: Vector2): Vector2;
    static of(x: number, y: number): Vector2;
    /**
     * Adds two vectors and returns a new instance
     * @param v1 <Vector2||Array||Number>
     * @param v2 <Vector2||Array||Number>
     * @returns <Vector2>
     */
    static add(v1: InputVector, v2: InputVector): Vector2;
    /**
     * Subtracts two vectors and returns a new instance
     * @param v1 <Vector2||Array||Number>
     * @param v2 <Vector2||Array||Number>
     * @returns <Vector2>
     */
    static sub(v1: InputVector, v2: InputVector): Vector2;
    /**
     * Multiplies two vectors and returns a new instance
     * @param v1 <Vector2||Array||Number>
     * @param v2 <Vector2||Array||Number>
     * @returns <Vector2>
     */
    static multiply(v1: InputVector, v2: InputVector): Vector2;
    /**
     * Divides two vectors and returns a new instance
     * @param v1 <Vector2||Array||Number>
     * @param v2 <Vector2||Array||Number>
     * @returns <Vector2>
     */
    static divide(v1: InputVector, v2: InputVector): Vector2;
    /**
     * Returns the dot product of two vectors
     * @param v1 <Vector2||Array||Number>
     * @param v2 <Vector2||Array||Number>
     * @returns <Float>
     */
    static dot(v1: InputVector, v2: InputVector): number;
    /**
     * Returns the cross product of two vectors
     * @param v1 <Vector2||Array||Number>
     * @param v2 <Vector2||Array||Number>
     * @returns <Float>
     */
    static cross(v1: InputVector, v2: InputVector): number;
    /**
     * Returns the length of a vector
     * @param vec <Vector2||Array||Number>
     * @returns <Float>
     */
    static len(vec: InputVector): number;
    /**
     * Returns the unit vector of a given vector
     * @param vec <Vector2||Array||Number>
     * @returns <Vector2>
     */
    static unit(vec: InputVector): Vector2;
    /**
     * Returns the normal vector of a given vector
     * @param vec <Vector2||Array||Number>
     * @returns <Vector2>
     */
    static normal(vec: InputVector): Vector2;
    /**
     * Returns the backface normal vector of a given vector
     * @param vec <Vector2||Array||Number>
     * @returns <Vector2>
     */
    static backfaceNormal(vec: InputVector): Vector2;
    /**
     * Generates a unit vector from an angle
     * @param angle <Float> in radians
     * @returns <Vector2>
     */
    static fromAngle(angle: number): Vector2;
    /**
     * Generates a new vector from the given vector and angle
     * @param vec <Vector2>
     * @param angle <Float> in radians
     * @returns <Vector2>
     */
    static rotate(vec: InputVector, angle: number): Vector2;
    /**
     * Getter for the x component of position
     * @returns <Float>
     */
    get x(): number;
    /**
     * Getter for the y component of position
     * @returns <Float>
     */
    get y(): number;
    /**
     * Getter for the length component of position i.e. the magnitude
     * @returns <Float>
     */
    get length(): number;
    /**
     * Adds a second vector
     * @param vec <Vector2||Array||Number>
     * @returns <this>
     */
    add(vec: InputVector): this;
    /**
     * Subtracts a second vector and returns a new vector
     * @param vec <Vector2||Array||Number>
     * @returns <this>
     */
    sub(vec: InputVector): this;
    /**
     * Multiplies a second vector and returns a new vector
     * @param vec <Vector2||Array||Number>
     * @returns <this>
     */
    multiply(vec: InputVector): this;
    /**
     * Divides a second vector and returns a new vector
     * @param vec <Vector2||Array||Number>
     * @returns <this>
     */
    divide(vec: InputVector): this;
    /**
     * Sets the vector to the specified length
     */
    magnitude(len: InputVector): this;
    /**
     * Returns the dot product of this vector and the supplied vector
     * @param vec <Vector2||Array||Number>
     * @returns <Float>
     */
    dot(vec: InputVector): number;
    /**
     * Returns the cross product of this vector and the supplied vector
     * @param vec <Vector2||Array||Number>
     * @returns <Float>
     */
    cross(vec: InputVector): number;
    /**
     * Returns the length of the vector
     * @returns <Float>
     */
    len(): number;
    /**
     * Slightly cheaper determinant of length, really only useful for length comparisons
     * @returns <Float>
     */
    sqrLen(): number;
    /**
     * Returns unit vector of this vector
     * @returns <Vector2>
     */
    unit(): Vector2;
    /**
     * Quick rotate 90 degrees to the left, where y is 'up' this is the normal vector
     * @returns <Vector2>
     */
    normal(): Vector2;
    /**
     * Quick rotate 90 deg right, where y is 'up' this grabs the normal of the backface
     * @returns <Vector2>
     */
    backfaceNormal(): Vector2;
    /**
     * Rotates the vector
     * @TODO specify angle as an integer and use pre-calc tables for sin & cos
     * @param angle <Float> in radians
     * @returns <Vector2>
     */
    rotate(angle: number): this;
    /**
     * Points the vector in a certain direction
     * @param angle <Float> in radians
     * @returns <Vector2>
     */
    turn(angle: number): this;
    /**
     * Returns the vector angle
     * @returns <Float> in radians
     */
    angle(): number;
    /**
     * Returns a new vector linearly interpolated along the length of
     * this vector
     * @param value <Float>
     * @returns <Vector2>
     */
    lerp(value: number): Vector2;
    /**
     * Calcs the distance between this vector and another one
     * @param vec <Vector2||Point>
     * @returns <Float>
     */
    distance(vec: InputVector): number;
    /**
     * Checks if the supplied vector is parallel to this vector
     * @param vec <Vector2>
     * @returns <Boolean>
     */
    isHeading(vec: Vector2): boolean;
    /**
     * Checks if the supplied vector is generally heading in the same direction
     * within `angle` degrees of accuracy
     * @param vec <Vector2>
     * @param angle <Float> in radians
     * @returns <Boolean>
     */
    isNearHeading(vec: Vector2, angle: number): boolean;
}
