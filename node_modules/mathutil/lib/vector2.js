"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _inputScalar=require("./inputScalar");class Vector2{static of(a,b){return a instanceof Vector2?new Vector2(a.pos[0],a.pos[1]):new Vector2(a,b)}static add(c,d){const e=_inputScalar.massageVectorInput(c),f=_inputScalar.massageVectorInput(d);return new Vector2(e[0]+f[0],e[1]+f[1])}static sub(g,h){const i=_inputScalar.massageVectorInput(g),j=_inputScalar.massageVectorInput(h);return new Vector2(i[0]-j[0],i[1]-j[1])}static multiply(k,l){const m=_inputScalar.massageVectorInput(k),n=_inputScalar.massageVectorInput(l);return new Vector2(m[0]*n[0],m[1]*n[1])}static divide(o,p){const q=_inputScalar.massageVectorInput(o),r=_inputScalar.massageVectorInput(p);return new Vector2(0===r[0]?0:q[0]/r[0],0===r[1]?0:q[1]/r[1])}static dot(s,t){const u=_inputScalar.massageVectorInput(s),v=_inputScalar.massageVectorInput(t);return u[0]*v[0]+u[1]*v[1]}static cross(w,x){const y=_inputScalar.massageVectorInput(w),z=_inputScalar.massageVectorInput(x);return y[0]*z[1]-y[1]*z[0]}static len(A){const B=_inputScalar.massageVectorInput(A);return Math.sqrt(Math.pow(B[0],2)+Math.pow(B[1],2))}static unit(C){const D=_inputScalar.massageVectorInput(C),E=Vector2.len(D);return Vector2.divide(D,[E,E])}static normal(F){const G=_inputScalar.massageVectorInput(F);return new Vector2(-G[1],G[0])}static backfaceNormal(H){const I=_inputScalar.massageVectorInput(H);return new Vector2(I[1],-I[0])}static fromAngle(J){return new Vector2(1,0).rotate(J)}static rotate(K,L){const M=_inputScalar.massageVectorInput(K),N=new Vector2(...M);return N.rotate(L),N}get x(){return this.pos[0]}get y(){return this.pos[1]}get length(){return this.len()}add(O){const P=_inputScalar.massageVectorInput(O);return this.pos=[this.pos[0]+P[0],this.pos[1]+P[1]],this}sub(Q){const R=_inputScalar.massageVectorInput(Q);return this.pos=[this.pos[0]-R[0],this.pos[1]-R[1]],this}multiply(S){const T=_inputScalar.massageVectorInput(S);return this.pos=[this.pos[0]*T[0],this.pos[1]*T[1]],this}divide(U){const V=_inputScalar.massageVectorInput(U);return this.pos=[0===V[0]?0:this.pos[0]/V[0],0===V[1]?0:this.pos[1]/V[1],],this}magnitude(W){const X=Vector2.multiply(this.unit(),W);return this.pos=X.pos,this}dot(Y){const Z=_inputScalar.massageVectorInput(Y);return this.pos[0]*Z[0]+this.pos[1]*Z[1]}cross($){const _=_inputScalar.massageVectorInput($);return this.pos[0]*_[1]-this.pos[1]*_[0]}len(){return Math.sqrt(Math.pow(this.pos[0],2)+Math.pow(this.pos[1],2))}sqrLen(){return Math.pow(this.pos[0],2)+Math.pow(this.pos[1],2)}unit(){const aa=this.len();return Vector2.divide(this,aa)}normal(){return new Vector2(-this.pos[1],this.pos[0])}backfaceNormal(){return new Vector2(this.pos[1],-this.pos[0])}rotate(ba){const[ca,da]=this.pos,ea=Math.sin(ba),fa=Math.cos(ba);return this.pos=[ca*fa-da*ea,ca*ea+da*fa],this}turn(ga){const ha=this.len(),ia=new Vector2(1,0).rotate(ga);return this.pos=[ia.pos[0]*ha,ia.pos[1]*ha],this}angle(){return Math.atan2(this.pos[1],this.pos[0])}lerp(ja){return Vector2.multiply(this,ja)}distance(ka){return Vector2.sub(this,ka).len()}isHeading(la){return 1===Vector2.dot(this.unit(),la.unit())}isNearHeading(ma,na){return Vector2.dot(this.unit(),ma.unit())>Math.cos(na)}constructor(oa,pa){return this.pos=[oa,pa],this}}exports.Vector2=Vector2
//# sourceMappingURL=vector2.js.map