"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _vector2=require("./vector2");function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}function _objectSpread(a){for(var c=1;c<arguments.length;c++){var d=null!=arguments[c]?arguments[c]:{},e=Object.keys(d);"function"==typeof Object.getOwnPropertySymbols&&(e=e.concat(Object.getOwnPropertySymbols(d).filter(function(a){return Object.getOwnPropertyDescriptor(d,a).enumerable}))),e.forEach(function(b){_defineProperty(a,b,d[b])})}return a}const castOpts={initial:!1,origin:[0,0],magnitude:0,step:1};class Ray{static of(a){return new Ray(a)}cast(b){b=_objectSpread({},castOpts,b);const c=new _vector2.Vector2(...this.dir.pos);let d=0;return function*(){for(b.initial&&(yield _vector2.Vector2.of(...b.origin));d<b.magnitude;)d+=b.step,c.magnitude(d),yield _vector2.Vector2.add(b.origin,c)}}project(e){e=_objectSpread({},castOpts,e);const f=new _vector2.Vector2(...this.dir.pos);let g=0;return a=>{for(;g<e.magnitude;)g+=e.step,f.magnitude(g),a(_vector2.Vector2.add(e.origin,f))}}constructor(h){if(!(h instanceof _vector2.Vector2))throw new Error("Ray should be instantiated with a direction vector");this.dir=h.unit()}}exports.Ray=Ray
//# sourceMappingURL=ray.js.map