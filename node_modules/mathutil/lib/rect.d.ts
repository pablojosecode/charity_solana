import type { Position, InputPoint } from './inputScalar';
import { Vector2 } from './vector2';
export declare class Rect {
    pos: [...Position, ...Position];
    /**
     * Creates new Rect instance
     * @constructs
     */
    constructor(x1: number, y1: number, x2: number, y2: number);
    static of(x1: Rect): Rect;
    static of(x1: number, y1: number, x2: number, y2: number): Rect;
    /**
     * Calculates the area of the given rectangle
     * @returns <Float>
     */
    static area(rect: Rect): number;
    /**
     * Translates the entire rectangle
     * @param x <Float>
     * @param y <Float>
     * @returns <Rect>
     */
    static translate(rect: Rect, x?: number, y?: number): Rect;
    /**
     * Scales the rect
     * @param s <Float> scalar
     * @returns <Rect>
     */
    static scale(rect: Rect, s: number): Rect;
    static constrict(rect: Rect, x: number, y?: number): Rect;
    get width(): number;
    get height(): number;
    get area(): number;
    get origin(): Position;
    get x(): number;
    get y(): number;
    get x1(): number;
    get y1(): number;
    get x2(): number;
    get y2(): number;
    setWidth(w: number): this;
    setHeight(h: number): this;
    floor(): this;
    ceil(): this;
    round(): this;
    equal(x1: Rect): boolean;
    equal(x1: number, y1: number, x2: number, y2: number): boolean;
    equals(x1: Rect): boolean;
    equals(x1: number, y1: number, x2: number, y2: number): boolean;
    /**
     * Translates the entire rectangle
     * @param x <Float>
     * @param y <Float>
     * @returns <this>
     */
    translate(x?: number, y?: number): this;
    scale(s: number): this;
    constrict(x: number, y?: number): this;
    private _containsRect;
    contains(x: Rect): boolean;
    contains(x: InputPoint): boolean;
    contains(x: number, y: number): boolean;
    /**
     * Returns a vector referencing the bottom-left, top-right diagonal
     * @returns <Vector2>
     */
    slope(): Vector2;
}
