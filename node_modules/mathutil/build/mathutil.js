function __swcpack_require__(mod){function interop(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}var cache;if(cache){return cache}var module={exports:{}};mod(module,module.exports);cache=interop(module.exports);return cache}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==="function"){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable}))}ownKeys.forEach(function(key){_defineProperty(target,key,source[key])})}return target}var load=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _inputScalar=load1();class Point{static of(a,b){if("number"==typeof a&&null!=b)return new Point(a,b);const c=_inputScalar.massageInputPoint(a);return new Point(c[0],c[1])}static translate(d,e){const f=_inputScalar.massageInputPoint(d),g=_inputScalar.massageInputPoint(e);return Point.of(f[0]+g[0],f[1]+g[1])}get x(){return this.pos[0]}get y(){return this.pos[1]}set x(h){this.pos[0]=h}set y(i){this.pos[1]=i}position(){return this.pos}equal(j,k){if("number"==typeof j&&null!=k)return this.x===j&&this.y===k;const l=_inputScalar.massageInputPoint(j);return this.equal(l[0],l[1])}equals(m,n){return this.equal(m,n)}translate(o,p){if("number"==typeof o&&null!=p)return this.x+=o,this.y+=p,this;const q=_inputScalar.massageInputPoint(o);return this.translate(q[0],q[1])}scale(r){return this.x*=r,this.y*=r,this}constructor(s,t){this.pos=[s,t]}}exports.Point=Point});var load1=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.massageInputPoint=massageInputPoint,exports.massageVectorInput=massageVectorInput;var _point1=load(),_vector21=load2();function massageInputPoint(a){return a instanceof _point1.Point?a.pos:"number"==typeof a?[a,a]:"x"in a&&"y"in a?[a.x,a.y]:a}function massageVectorInput(a){return a instanceof _vector21.Vector2?a.pos:"number"==typeof a?[a,a]:"x"in a&&"y"in a?[a.x,a.y]:a}});var load2=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _inputScalar=load1();class Vector2{static of(a,b){return a instanceof Vector2?new Vector2(a.pos[0],a.pos[1]):new Vector2(a,b)}static add(c,d){const e=_inputScalar.massageVectorInput(c),f=_inputScalar.massageVectorInput(d);return new Vector2(e[0]+f[0],e[1]+f[1])}static sub(g,h){const i=_inputScalar.massageVectorInput(g),j=_inputScalar.massageVectorInput(h);return new Vector2(i[0]-j[0],i[1]-j[1])}static multiply(k,l){const m=_inputScalar.massageVectorInput(k),n=_inputScalar.massageVectorInput(l);return new Vector2(m[0]*n[0],m[1]*n[1])}static divide(o,p){const q=_inputScalar.massageVectorInput(o),r=_inputScalar.massageVectorInput(p);return new Vector2(0===r[0]?0:q[0]/r[0],0===r[1]?0:q[1]/r[1])}static dot(s,t){const u=_inputScalar.massageVectorInput(s),v=_inputScalar.massageVectorInput(t);return u[0]*v[0]+u[1]*v[1]}static cross(w,x){const y=_inputScalar.massageVectorInput(w),z=_inputScalar.massageVectorInput(x);return y[0]*z[1]-y[1]*z[0]}static len(A){const B=_inputScalar.massageVectorInput(A);return Math.sqrt(Math.pow(B[0],2)+Math.pow(B[1],2))}static unit(C){const D=_inputScalar.massageVectorInput(C),E=Vector2.len(D);return Vector2.divide(D,[E,E])}static normal(F){const G=_inputScalar.massageVectorInput(F);return new Vector2(-G[1],G[0])}static backfaceNormal(H){const I=_inputScalar.massageVectorInput(H);return new Vector2(I[1],-I[0])}static fromAngle(J){return new Vector2(1,0).rotate(J)}static rotate(K,L){const M=_inputScalar.massageVectorInput(K),N=new Vector2(...M);return N.rotate(L),N}get x(){return this.pos[0]}get y(){return this.pos[1]}get length(){return this.len()}add(O){const P=_inputScalar.massageVectorInput(O);return this.pos=[this.pos[0]+P[0],this.pos[1]+P[1]],this}sub(Q){const R=_inputScalar.massageVectorInput(Q);return this.pos=[this.pos[0]-R[0],this.pos[1]-R[1]],this}multiply(S){const T=_inputScalar.massageVectorInput(S);return this.pos=[this.pos[0]*T[0],this.pos[1]*T[1]],this}divide(U){const V=_inputScalar.massageVectorInput(U);return this.pos=[0===V[0]?0:this.pos[0]/V[0],0===V[1]?0:this.pos[1]/V[1],],this}magnitude(W){const X=Vector2.multiply(this.unit(),W);return this.pos=X.pos,this}dot(Y){const Z=_inputScalar.massageVectorInput(Y);return this.pos[0]*Z[0]+this.pos[1]*Z[1]}cross($){const _=_inputScalar.massageVectorInput($);return this.pos[0]*_[1]-this.pos[1]*_[0]}len(){return Math.sqrt(Math.pow(this.pos[0],2)+Math.pow(this.pos[1],2))}sqrLen(){return Math.pow(this.pos[0],2)+Math.pow(this.pos[1],2)}unit(){const aa=this.len();return Vector2.divide(this,aa)}normal(){return new Vector2(-this.pos[1],this.pos[0])}backfaceNormal(){return new Vector2(this.pos[1],-this.pos[0])}rotate(ba){const[ca,da]=this.pos,ea=Math.sin(ba),fa=Math.cos(ba);return this.pos=[ca*fa-da*ea,ca*ea+da*fa],this}turn(ga){const ha=this.len(),ia=new Vector2(1,0).rotate(ga);return this.pos=[ia.pos[0]*ha,ia.pos[1]*ha],this}angle(){return Math.atan2(this.pos[1],this.pos[0])}lerp(ja){return Vector2.multiply(this,ja)}distance(ka){return Vector2.sub(this,ka).len()}isHeading(la){return 1===Vector2.dot(this.unit(),la.unit())}isNearHeading(ma,na){return Vector2.dot(this.unit(),ma.unit())>Math.cos(na)}constructor(oa,pa){return this.pos=[oa,pa],this}}exports.Vector2=Vector2});var load3=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _vector22=load2(),_inputScalar=load1();class Rect{static of(a,b,c,d){return a instanceof Rect?new Rect(a.pos[0],a.pos[1],a.pos[2],a.pos[3]):new Rect(a,b,c,d)}static area(e){if(!e||!(e instanceof Rect))throw new Error("Specify rect to translate");return(e.pos[2]-e.pos[0])*(e.pos[3]-e.pos[1])}static translate(f,g=0,h=0){if(!f||!(f instanceof Rect))throw new Error("Specify rect to translate");return new Rect(f.pos[0]+g,f.pos[1]+h,f.pos[2]+g,f.pos[3]+h)}static scale(i,j){if(!i||!(i instanceof Rect))throw new Error("Specify rect to translate");return new Rect(i.pos[0],i.pos[1],i.pos[0]+i.width*j,i.pos[1]+i.height*j)}static constrict(k,l,m){if(!k||!(k instanceof Rect))throw new Error("Specify rect to translate");return null==m&&(m=l),new Rect(k.pos[0]+l,k.pos[1]+m,k.pos[2]-l,k.pos[3]-m)}get width(){return this.pos[2]-this.pos[0]}get height(){return this.pos[3]-this.pos[1]}get area(){return this.width*this.height}get origin(){return[this.pos[0],this.pos[1]]}get x(){return this.pos[0]}get y(){return this.pos[1]}get x1(){return this.pos[0]}get y1(){return this.pos[1]}get x2(){return this.pos[2]}get y2(){return this.pos[3]}setWidth(n){return this.pos[2]=this.pos[0]+n,this}setHeight(o){return this.pos[3]=this.pos[1]+o,this}floor(){return this.pos=this.pos.map(Math.floor),this}ceil(){return this.pos=this.pos.map(Math.ceil),this}round(){return this.pos[0]=Math.floor(this.pos[0]),this.pos[1]=Math.floor(this.pos[1]),this.pos[2]=Math.ceil(this.pos[2]),this.pos[3]=Math.ceil(this.pos[3]),this}equal(p,q,r,s){return p instanceof Rect?this.equal(...p.pos):this.pos[0]===p&&this.pos[1]===q&&this.pos[2]===r&&this.pos[3]===s}equals(t,u,v,w){return t instanceof Rect?this.equal(...t.pos):this.equal(t,u,v,w)}translate(x=0,y=0){return this.pos=[this.pos[0]+x,this.pos[1]+y,this.pos[2]+x,this.pos[3]+y,],this}scale(z){return this.pos=[this.pos[0],this.pos[1],this.pos[0]+this.width*z,this.pos[1]+this.height*z,],this}constrict(A,B){return null==B&&(B=A),this.pos=[this.pos[0]+A,this.pos[1]+B,this.pos[2]-A,this.pos[3]-B,],this}_containsRect(C){const{pos:D}=this;return C.pos[0]>=D[0]&&C.pos[1]>=D[1]&&C.pos[2]<=D[2]&&C.pos[3]<=D[3]}contains(E,F){if(E instanceof Rect)return this._containsRect(E);if(null==F){const[G,H]=_inputScalar.massageInputPoint(E);return this.contains(G,H)}const{pos:I}=this;return E>=I[0]&&F>=I[1]&&E<=I[2]&&F<=I[3]}slope(){return new _vector22.Vector2(this.pos[2]-this.pos[0],this.pos[3]-this.pos[1])}constructor(J,K,L,M){this.pos=[J,K,L,M]}}exports.Rect=Rect});var load4=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _vector23=load2();const castOpts={initial:!1,origin:[0,0],magnitude:0,step:1};class Ray{static of(a){return new Ray(a)}cast(b){b=_objectSpread({},castOpts,b);const c=new _vector23.Vector2(...this.dir.pos);let d=0;return function*(){for(b.initial&&(yield _vector23.Vector2.of(...b.origin));d<b.magnitude;)d+=b.step,c.magnitude(d),yield _vector23.Vector2.add(b.origin,c)}}project(e){e=_objectSpread({},castOpts,e);const f=new _vector23.Vector2(...this.dir.pos);let g=0;return a=>{for(;g<e.magnitude;)g+=e.step,f.magnitude(g),a(_vector23.Vector2.add(e.origin,f))}}constructor(h){if(!(h instanceof _vector23.Vector2))throw new Error("Ray should be instantiated with a direction vector");this.dir=h.unit()}}exports.Ray=Ray});var load5=__swcpack_require__.bind(void 0,function(module,exports){"use strict";function _performLerp(a,b,c){return b+a*(c-b)}function _curryLerp(a,b){return function(c){return _performLerp(c,a,b)}}function lerp(a,b,c){return void 0===c?_curryLerp(a,b):_performLerp(c,a,b)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.lerp=lerp});var load6=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.toDegrees=toDegrees;var scalar=180/Math.PI;function toDegrees(a){return a*scalar}});var load7=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.toRadians=toRadians;var scalar=Math.PI/180;function toRadians(a){return a*scalar}});var load8=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.min=min;const reduceMin=(a,b)=>b<a?b:a;function min(a){let b=Number.MAX_SAFE_INTEGER;for(const c of a)b=reduceMin(b,c);return b}});var load9=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.max=max;const reduceMax=(a,b)=>b>a?b:a;function max(a){let b=Number.MIN_SAFE_INTEGER;for(const c of a)b=reduceMax(b,c);return b}});var load10=__swcpack_require__.bind(void 0,function(module,exports){"use strict";function _performClamp(a,b,c){return a<b?b:a>c?c:a}function _curryClamp(a,b){return function(c){return _performClamp(c,a,b)}}function clamp(a,b,c){return void 0===c?_curryClamp(a,b):_performClamp(c,a,b)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.clamp=clamp});var load11=__swcpack_require__.bind(void 0,function(module,exports){"use strict";function _performWrap(a,b,c){const d=c-b;if(d<=0)return 0;let e=(a-b)%d;return e<0&&(e+=d),e+b}function _curryWrap(a,b){return function(c){return _performWrap(c,a,b)}}function wrap(a,b,c){return void 0===c?_curryWrap(a,b):_performWrap(c,a,b)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.wrap=wrap});var load12=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.euclidean=euclidean;var _inputScalar=load1();function euclidean(a,b){const c=_inputScalar.massageInputPoint(a),d=_inputScalar.massageInputPoint(b);return Math.sqrt(Math.pow(c[0]-d[0],2)+Math.pow(c[1]-d[1],2))}});var load13=__swcpack_require__.bind(void 0,function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.manhattan=manhattan;var _inputScalar=load1();function manhattan(a,b){const c=_inputScalar.massageInputPoint(a),d=_inputScalar.massageInputPoint(b);return Math.abs(c[0]-d[0])+Math.abs(c[1]-d[1])}});"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"Point",{enumerable:!0,get:function(){return _point.Point}}),Object.defineProperty(exports,"Rect",{enumerable:!0,get:function(){return _rect.Rect}}),Object.defineProperty(exports,"Vector2",{enumerable:!0,get:function(){return _vector2.Vector2}}),Object.defineProperty(exports,"Ray",{enumerable:!0,get:function(){return _ray.Ray}}),Object.defineProperty(exports,"lerp",{enumerable:!0,get:function(){return _lerp.lerp}}),Object.defineProperty(exports,"toDegrees",{enumerable:!0,get:function(){return _toDegrees.toDegrees}}),Object.defineProperty(exports,"toRadians",{enumerable:!0,get:function(){return _toRadians.toRadians}}),Object.defineProperty(exports,"min",{enumerable:!0,get:function(){return _min.min}}),Object.defineProperty(exports,"max",{enumerable:!0,get:function(){return _max.max}}),Object.defineProperty(exports,"clamp",{enumerable:!0,get:function(){return _clamp.clamp}}),Object.defineProperty(exports,"wrap",{enumerable:!0,get:function(){return _wrap.wrap}}),Object.defineProperty(exports,"euclidean",{enumerable:!0,get:function(){return _euclidean.euclidean}}),Object.defineProperty(exports,"manhattan",{enumerable:!0,get:function(){return _manhattan.manhattan}});var _point=load(),_rect=load3(),_vector2=load2(),_ray=load4(),_lerp=load5(),_toDegrees=load6(),_toRadians=load7(),_min=load8(),_max=load9(),_clamp=load10(),_wrap=load11(),_euclidean=load12(),_manhattan=load13()