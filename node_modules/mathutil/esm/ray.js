import{Vector2 as a}from"./vector2";function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}function _objectSpread(a){for(var c=1;c<arguments.length;c++){var d=null!=arguments[c]?arguments[c]:{},e=Object.keys(d);"function"==typeof Object.getOwnPropertySymbols&&(e=e.concat(Object.getOwnPropertySymbols(d).filter(function(a){return Object.getOwnPropertyDescriptor(d,a).enumerable}))),e.forEach(function(b){_defineProperty(a,b,d[b])})}return a}const castOpts={initial:!1,origin:[0,0],magnitude:0,step:1};export class Ray{static of(b){return new Ray(b)}cast(c){c=_objectSpread({},castOpts,c);const d=new a(...this.dir.pos);let e=0;return function*(){for(c.initial&&(yield a.of(...c.origin));e<c.magnitude;)e+=c.step,d.magnitude(e),yield a.add(c.origin,d)}}project(f){f=_objectSpread({},castOpts,f);const g=new a(...this.dir.pos);let h=0;return b=>{for(;h<f.magnitude;)h+=f.step,g.magnitude(h),b(a.add(f.origin,g))}}constructor(i){if(!(i instanceof a))throw new Error("Ray should be instantiated with a direction vector");this.dir=i.unit()}}
//# sourceMappingURL=ray.js.map