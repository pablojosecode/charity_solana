import{Vector2 as a}from"./vector2";import{massageInputPoint as b}from"./inputScalar";export class Rect{static of(c,d,e,f){return c instanceof Rect?new Rect(c.pos[0],c.pos[1],c.pos[2],c.pos[3]):new Rect(c,d,e,f)}static area(g){if(!g||!(g instanceof Rect))throw new Error("Specify rect to translate");return(g.pos[2]-g.pos[0])*(g.pos[3]-g.pos[1])}static translate(h,i=0,j=0){if(!h||!(h instanceof Rect))throw new Error("Specify rect to translate");return new Rect(h.pos[0]+i,h.pos[1]+j,h.pos[2]+i,h.pos[3]+j)}static scale(k,l){if(!k||!(k instanceof Rect))throw new Error("Specify rect to translate");return new Rect(k.pos[0],k.pos[1],k.pos[0]+k.width*l,k.pos[1]+k.height*l)}static constrict(m,n,o){if(!m||!(m instanceof Rect))throw new Error("Specify rect to translate");return null==o&&(o=n),new Rect(m.pos[0]+n,m.pos[1]+o,m.pos[2]-n,m.pos[3]-o)}get width(){return this.pos[2]-this.pos[0]}get height(){return this.pos[3]-this.pos[1]}get area(){return this.width*this.height}get origin(){return[this.pos[0],this.pos[1]]}get x(){return this.pos[0]}get y(){return this.pos[1]}get x1(){return this.pos[0]}get y1(){return this.pos[1]}get x2(){return this.pos[2]}get y2(){return this.pos[3]}setWidth(p){return this.pos[2]=this.pos[0]+p,this}setHeight(q){return this.pos[3]=this.pos[1]+q,this}floor(){return this.pos=this.pos.map(Math.floor),this}ceil(){return this.pos=this.pos.map(Math.ceil),this}round(){return this.pos[0]=Math.floor(this.pos[0]),this.pos[1]=Math.floor(this.pos[1]),this.pos[2]=Math.ceil(this.pos[2]),this.pos[3]=Math.ceil(this.pos[3]),this}equal(r,s,t,u){return r instanceof Rect?this.equal(...r.pos):this.pos[0]===r&&this.pos[1]===s&&this.pos[2]===t&&this.pos[3]===u}equals(v,w,x,y){return v instanceof Rect?this.equal(...v.pos):this.equal(v,w,x,y)}translate(z=0,A=0){return this.pos=[this.pos[0]+z,this.pos[1]+A,this.pos[2]+z,this.pos[3]+A,],this}scale(B){return this.pos=[this.pos[0],this.pos[1],this.pos[0]+this.width*B,this.pos[1]+this.height*B,],this}constrict(C,D){return null==D&&(D=C),this.pos=[this.pos[0]+C,this.pos[1]+D,this.pos[2]-C,this.pos[3]-D,],this}_containsRect(E){const{pos:F}=this;return E.pos[0]>=F[0]&&E.pos[1]>=F[1]&&E.pos[2]<=F[2]&&E.pos[3]<=F[3]}contains(G,H){if(G instanceof Rect)return this._containsRect(G);if(null==H){const[I,J]=b(G);return this.contains(I,J)}const{pos:K}=this;return G>=K[0]&&H>=K[1]&&G<=K[2]&&H<=K[3]}slope(){return new a(this.pos[2]-this.pos[0],this.pos[3]-this.pos[1])}constructor(L,M,N,O){this.pos=[L,M,N,O]}}
//# sourceMappingURL=rect.js.map