import{massageVectorInput as a}from"./inputScalar";export class Vector2{static of(b,c){return b instanceof Vector2?new Vector2(b.pos[0],b.pos[1]):new Vector2(b,c)}static add(d,e){const f=a(d),g=a(e);return new Vector2(f[0]+g[0],f[1]+g[1])}static sub(h,i){const j=a(h),k=a(i);return new Vector2(j[0]-k[0],j[1]-k[1])}static multiply(l,m){const n=a(l),o=a(m);return new Vector2(n[0]*o[0],n[1]*o[1])}static divide(p,q){const r=a(p),s=a(q);return new Vector2(0===s[0]?0:r[0]/s[0],0===s[1]?0:r[1]/s[1])}static dot(t,u){const v=a(t),w=a(u);return v[0]*w[0]+v[1]*w[1]}static cross(x,y){const z=a(x),A=a(y);return z[0]*A[1]-z[1]*A[0]}static len(B){const C=a(B);return Math.sqrt(Math.pow(C[0],2)+Math.pow(C[1],2))}static unit(D){const E=a(D),F=Vector2.len(E);return Vector2.divide(E,[F,F])}static normal(G){const H=a(G);return new Vector2(-H[1],H[0])}static backfaceNormal(I){const J=a(I);return new Vector2(J[1],-J[0])}static fromAngle(K){return new Vector2(1,0).rotate(K)}static rotate(L,M){const N=a(L),O=new Vector2(...N);return O.rotate(M),O}get x(){return this.pos[0]}get y(){return this.pos[1]}get length(){return this.len()}add(P){const Q=a(P);return this.pos=[this.pos[0]+Q[0],this.pos[1]+Q[1]],this}sub(R){const S=a(R);return this.pos=[this.pos[0]-S[0],this.pos[1]-S[1]],this}multiply(T){const U=a(T);return this.pos=[this.pos[0]*U[0],this.pos[1]*U[1]],this}divide(V){const W=a(V);return this.pos=[0===W[0]?0:this.pos[0]/W[0],0===W[1]?0:this.pos[1]/W[1],],this}magnitude(X){const Y=Vector2.multiply(this.unit(),X);return this.pos=Y.pos,this}dot(Z){const $=a(Z);return this.pos[0]*$[0]+this.pos[1]*$[1]}cross(_){const aa=a(_);return this.pos[0]*aa[1]-this.pos[1]*aa[0]}len(){return Math.sqrt(Math.pow(this.pos[0],2)+Math.pow(this.pos[1],2))}sqrLen(){return Math.pow(this.pos[0],2)+Math.pow(this.pos[1],2)}unit(){const ba=this.len();return Vector2.divide(this,ba)}normal(){return new Vector2(-this.pos[1],this.pos[0])}backfaceNormal(){return new Vector2(this.pos[1],-this.pos[0])}rotate(ca){const[da,ea]=this.pos,fa=Math.sin(ca),ga=Math.cos(ca);return this.pos=[da*ga-ea*fa,da*fa+ea*ga],this}turn(ha){const ia=this.len(),ja=new Vector2(1,0).rotate(ha);return this.pos=[ja.pos[0]*ia,ja.pos[1]*ia],this}angle(){return Math.atan2(this.pos[1],this.pos[0])}lerp(ka){return Vector2.multiply(this,ka)}distance(la){return Vector2.sub(this,la).len()}isHeading(ma){return 1===Vector2.dot(this.unit(),ma.unit())}isNearHeading(na,oa){return Vector2.dot(this.unit(),na.unit())>Math.cos(oa)}constructor(pa,qa){return this.pos=[pa,qa],this}}
//# sourceMappingURL=vector2.js.map