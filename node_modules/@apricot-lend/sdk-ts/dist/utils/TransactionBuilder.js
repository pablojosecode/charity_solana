"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
var spl_token_1 = require("@solana/spl-token");
var web3_js_1 = require("@solana/web3.js");
var tiny_invariant_1 = __importDefault(require("tiny-invariant"));
var commands_1 = require("../constants/commands");
var configs_1 = require("../constants/configs");
var AccountParser_1 = require("./AccountParser");
var sysvarInstructionsKey = new web3_js_1.PublicKey('Sysvar1nstructions1111111111111111111111111');
var TransactionBuilder = /** @class */ (function () {
    function TransactionBuilder(addresses) {
        this.addresses = addresses;
    }
    TransactionBuilder.prototype.mintKeyStrToPoolIdArray = function (mintKeyStr) {
        return [this.addresses.mintKeyStrToPoolId(mintKeyStr)];
    };
    TransactionBuilder.prototype.mintKeyStrToPoolId = function (mintKeyStr) {
        return this.addresses.mintKeyStrToPoolId(mintKeyStr);
    };
    TransactionBuilder.prototype.refreshUser = function (userWalletKey) {
        return __awaiter(this, void 0, void 0, function () {
            var userInfoKey, poolSummariesKey, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 1:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 2:
                        poolSummariesKey = _a.sent();
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: [
                                { pubkey: userWalletKey, isSigner: false, isWritable: false },
                                { pubkey: userInfoKey, isSigner: false, isWritable: true },
                                { pubkey: poolSummariesKey, isSigner: false, isWritable: false }, // PoolSummaries
                            ],
                            data: Buffer.from([commands_1.CMD_REFRESH_USER]),
                        });
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.updateUserConfig = function (walletAccount, assistMode, selfDeleverageFactor, postDeleverageFactor) {
        return __awaiter(this, void 0, void 0, function () {
            var walletKey, userInfoKey, buffer, payload, data, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        walletKey = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserInfoKey(walletKey)];
                    case 1:
                        userInfoKey = _a.sent();
                        buffer = new ArrayBuffer(16);
                        AccountParser_1.AccountParser.setFloat64(buffer, 0, selfDeleverageFactor);
                        AccountParser_1.AccountParser.setFloat64(buffer, 8, postDeleverageFactor);
                        payload = Array.from(new Uint8Array(buffer));
                        data = [commands_1.CMD_UPDATE_USER_CONFIG, assistMode].concat(payload);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: [
                                { pubkey: walletKey, isSigner: true, isWritable: false },
                                { pubkey: userInfoKey, isSigner: false, isWritable: true }, // userInfo
                            ],
                            data: Buffer.from(data),
                        });
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.addUserAndDeposit = function (pageId, walletAccount, userSplKey, mintKeyStr, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var basePda, walletKey, userPagesStatsKey, usersPageKey, userInfoKey, assetPoolKey, assetPoolSplKey, poolSummariesKey, priceSummariesKey, buffer, view, payload, poolIdArray, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        walletKey = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserPagesStatsKey()];
                    case 2:
                        userPagesStatsKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getUsersPageKey(basePda, pageId)];
                    case 3:
                        usersPageKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getUserInfoKey(walletKey)];
                    case 4:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, mintKeyStr)];
                    case 5:
                        assetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, mintKeyStr)];
                    case 6:
                        assetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 7:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(basePda)];
                    case 8:
                        priceSummariesKey = _a.sent();
                        buffer = new ArrayBuffer(10);
                        view = new DataView(buffer);
                        view.setUint16(0, pageId, true);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 2, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        poolIdArray = this.mintKeyStrToPoolIdArray(mintKeyStr);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: [
                                { pubkey: walletKey, isSigner: true, isWritable: true },
                                { pubkey: userSplKey, isSigner: false, isWritable: true },
                                { pubkey: userPagesStatsKey, isSigner: false, isWritable: true },
                                { pubkey: usersPageKey, isSigner: false, isWritable: true },
                                { pubkey: userInfoKey, isSigner: false, isWritable: true },
                                { pubkey: assetPoolKey, isSigner: false, isWritable: true },
                                { pubkey: assetPoolSplKey, isSigner: false, isWritable: true },
                                { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                                { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                                { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
                                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                            ],
                            data: Buffer.from([commands_1.CMD_ADD_USER_AND_DEPOSIT].concat(payload).concat(poolIdArray)),
                        });
                        // signer: walletAccount
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.deposit = function (walletAccount, userSplKey, mintKeyStr, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var basePda, userWalletKey, userInfoKey, assetPoolKey, assetPoolSplKey, poolSummariesKey, priceSummariesKey, buffer, payload, poolIdArray, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        userWalletKey = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, mintKeyStr)];
                    case 3:
                        assetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, mintKeyStr)];
                    case 4:
                        assetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 5:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(basePda)];
                    case 6:
                        priceSummariesKey = _a.sent();
                        buffer = new ArrayBuffer(8);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        poolIdArray = this.mintKeyStrToPoolIdArray(mintKeyStr);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: [
                                { pubkey: userWalletKey, isSigner: true, isWritable: true },
                                { pubkey: userSplKey, isSigner: false, isWritable: true },
                                { pubkey: userInfoKey, isSigner: false, isWritable: true },
                                { pubkey: assetPoolKey, isSigner: false, isWritable: true },
                                { pubkey: assetPoolSplKey, isSigner: false, isWritable: true },
                                { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                                { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                            ],
                            data: Buffer.from([commands_1.CMD_DEPOSIT].concat(payload).concat(poolIdArray)),
                        });
                        // signer: walletAccount
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.withdrawAndRemoveUser = function (walletAccount, userSplKey, mintKeyStr, withdrawAll, amount, userInfo) {
        return __awaiter(this, void 0, void 0, function () {
            var pageId, basePda, userWalletKey, userPagesStatsKey, usersPageKey, userInfoKey, assetPoolKey, assetPoolSplKey, poolSummariesKey, priceSummariesKey, keys, buffer, payload, poolIdArray, data, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pageId = userInfo.page_id;
                        if (pageId > 10000) {
                            console.log('User not added to backend yet.');
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        userWalletKey = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserPagesStatsKey()];
                    case 2:
                        userPagesStatsKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getUsersPageKey(basePda, pageId)];
                    case 3:
                        usersPageKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 4:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, mintKeyStr)];
                    case 5:
                        assetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, mintKeyStr)];
                    case 6:
                        assetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 7:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(basePda)];
                    case 8:
                        priceSummariesKey = _a.sent();
                        keys = [
                            { pubkey: userWalletKey, isSigner: true, isWritable: true },
                            { pubkey: userSplKey, isSigner: false, isWritable: true },
                            { pubkey: userPagesStatsKey, isSigner: false, isWritable: true },
                            { pubkey: usersPageKey, isSigner: false, isWritable: true },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: basePda, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                        ];
                        buffer = new ArrayBuffer(9);
                        AccountParser_1.AccountParser.setUint8(buffer, 0, withdrawAll ? 1 : 0);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 1, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        poolIdArray = this.mintKeyStrToPoolIdArray(mintKeyStr);
                        data = [commands_1.CMD_WITHDRAW_AND_REMOVE_USER].concat(payload).concat(poolIdArray);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from(data),
                        });
                        // signer: walletAccount
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.withdraw = function (walletAccount, userSplKey, mintKeyStr, withdraw_all, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var basePda, userWalletKey, userInfoKey, assetPoolKey, assetPoolSplKey, poolSummariesKey, priceSummariesKey, keys, buffer, payload, poolIdArray, data, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        userWalletKey = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, mintKeyStr)];
                    case 3:
                        assetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, mintKeyStr)];
                    case 4:
                        assetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 5:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(basePda)];
                    case 6:
                        priceSummariesKey = _a.sent();
                        keys = [
                            { pubkey: userWalletKey, isSigner: true, isWritable: true },
                            { pubkey: userSplKey, isSigner: false, isWritable: true },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: basePda, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                        ];
                        buffer = new ArrayBuffer(9);
                        AccountParser_1.AccountParser.setUint8(buffer, 0, withdraw_all ? 1 : 0);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 1, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        poolIdArray = this.mintKeyStrToPoolIdArray(mintKeyStr);
                        data = [commands_1.CMD_WITHDRAW].concat(payload).concat(poolIdArray);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from(data),
                        });
                        // signer: walletAccount
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.borrow = function (walletAccount, userSplKey, mintKeyStr, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var basePda, userWalletKey, userInfoKey, assetPoolKey, assetPoolSplKey, poolSummariesKey, priceSummariesKey, keys, buffer, payload, poolIdArray, data, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        userWalletKey = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, mintKeyStr)];
                    case 3:
                        assetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, mintKeyStr)];
                    case 4:
                        assetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 5:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(basePda)];
                    case 6:
                        priceSummariesKey = _a.sent();
                        keys = [
                            { pubkey: userWalletKey, isSigner: true, isWritable: true },
                            { pubkey: userSplKey, isSigner: false, isWritable: true },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: basePda, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                        ];
                        buffer = new ArrayBuffer(8);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        poolIdArray = this.mintKeyStrToPoolIdArray(mintKeyStr);
                        data = [commands_1.CMD_BORROW].concat(payload).concat(poolIdArray);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from(data),
                        });
                        // signer: walletAccount
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.repay = function (walletAccount, userSplKey, mintKeyStr, repay_all, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var basePda, userWalletKey, userInfoKey, assetPoolKey, assetPoolSplKey, poolSummariesKey, keys, buffer, payload, poolIdArray, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        userWalletKey = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, mintKeyStr)];
                    case 3:
                        assetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, mintKeyStr)];
                    case 4:
                        assetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 5:
                        poolSummariesKey = _a.sent();
                        keys = [
                            { pubkey: userWalletKey, isSigner: true, isWritable: true },
                            { pubkey: userSplKey, isSigner: false, isWritable: true },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: assetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                        ];
                        buffer = new ArrayBuffer(9);
                        AccountParser_1.AccountParser.setUint8(buffer, 0, repay_all ? 1 : 0);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 1, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        poolIdArray = this.mintKeyStrToPoolIdArray(mintKeyStr);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from([commands_1.CMD_REPAY].concat(payload).concat(poolIdArray)),
                        });
                        // signer: walletAccount
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.externalLiquidate = function (liquidatorWalletAccount, liquidatedWalletKey, liquidatorCollateralSpl, liquidatorBorrowedSpl, collateralMintStr, borrowedMintStr, minCollateralAmount, repaidBorrowAmount) {
        return __awaiter(this, void 0, void 0, function () {
            var basePda, liquidatorWalletKey, userInfoKey, collateralPoolKey, collateralPoolSpl, borrowedPoolKey, borrowedPoolSpl, poolSummariesKey, priceSummariesKey, keys, buffer, payload, collateralPoolIdArray, borrowedPoolIdArray, data, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        liquidatorWalletKey = liquidatorWalletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserInfoKey(liquidatedWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, collateralMintStr)];
                    case 3:
                        collateralPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, collateralMintStr)];
                    case 4:
                        collateralPoolSpl = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(basePda, borrowedMintStr)];
                    case 5:
                        borrowedPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(basePda, borrowedMintStr)];
                    case 6:
                        borrowedPoolSpl = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 7:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(basePda)];
                    case 8:
                        priceSummariesKey = _a.sent();
                        keys = [
                            { pubkey: liquidatedWalletKey, isSigner: false, isWritable: false },
                            { pubkey: liquidatorWalletKey, isSigner: true, isWritable: false },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: basePda, isSigner: false, isWritable: false },
                            { pubkey: liquidatorCollateralSpl, isSigner: false, isWritable: true },
                            { pubkey: liquidatorBorrowedSpl, isSigner: false, isWritable: true },
                            { pubkey: collateralPoolKey, isSigner: false, isWritable: true },
                            { pubkey: collateralPoolSpl, isSigner: false, isWritable: true },
                            { pubkey: borrowedPoolKey, isSigner: false, isWritable: true },
                            { pubkey: borrowedPoolSpl, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                        ];
                        buffer = new ArrayBuffer(8 + 8);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, minCollateralAmount);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 8, repaidBorrowAmount);
                        payload = Array.from(new Uint8Array(buffer));
                        collateralPoolIdArray = this.mintKeyStrToPoolIdArray(collateralMintStr);
                        borrowedPoolIdArray = this.mintKeyStrToPoolIdArray(borrowedMintStr);
                        data = [commands_1.CMD_EXTERN_LIQUIDATE]
                            .concat(payload)
                            .concat(collateralPoolIdArray)
                            .concat(borrowedPoolIdArray);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from(data),
                        });
                        // signer: liquidator_wallet_account
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpOpCheckIx = function (userWalletKey, leftMintStr, leftAmount, rightMintStr, rightAmount, lpMintStr, minLpAmount, targetSwap, isCreate, isSigned) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, userInfoKey, leftAssetPoolKey, leftAssetPoolSplKey, rightAssetPoolKey, rightAssetPoolSplKey, lpAssetPoolKey, poolSummariesKey, priceSummariesKey, keys, buffer, leftPoolId, rightPoolId, lpPoolId, payload, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, leftMintStr)];
                    case 3:
                        leftAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, leftMintStr)];
                    case 4:
                        leftAssetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, rightMintStr)];
                    case 5:
                        rightAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, rightMintStr)];
                    case 6:
                        rightAssetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, lpMintStr)];
                    case 7:
                        lpAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 8:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(base_pda)];
                    case 9:
                        priceSummariesKey = _a.sent();
                        keys = [
                            { pubkey: userWalletKey, isSigner: isSigned, isWritable: false },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: leftAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: leftAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: rightAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: rightAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: sysvarInstructionsKey, isSigner: false, isWritable: false },
                        ];
                        buffer = new ArrayBuffer(29);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, leftAmount);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 8, rightAmount);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 16, minLpAmount);
                        leftPoolId = this.mintKeyStrToPoolId(leftMintStr);
                        AccountParser_1.AccountParser.setUint8(buffer, 24, leftPoolId);
                        rightPoolId = this.mintKeyStrToPoolId(rightMintStr);
                        AccountParser_1.AccountParser.setUint8(buffer, 25, rightPoolId);
                        lpPoolId = this.mintKeyStrToPoolId(lpMintStr);
                        AccountParser_1.AccountParser.setUint8(buffer, 26, lpPoolId);
                        AccountParser_1.AccountParser.setUint8(buffer, 27, targetSwap);
                        AccountParser_1.AccountParser.setUint8(buffer, 28, isCreate ? 1 : 0);
                        payload = Array.from(new Uint8Array(buffer));
                        data = [commands_1.CMD_LP_OP_CHECK].concat(payload);
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from(data),
                            })];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpOpEndcheckIx = function (_userWalletKey) {
        return __awaiter(this, void 0, void 0, function () {
            var poolSummariesKey, keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 1:
                        poolSummariesKey = _a.sent();
                        keys = [
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true }, // PoolSummaries
                        ];
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from([commands_1.CMD_LP_OP_ENDCHECK]),
                            })];
                }
            });
        });
    };
    TransactionBuilder.prototype.marginLpCreate = function (walletAccount, leftMintStr, leftAmount, rightMintStr, rightAmount, lpMintStr, min_lpAmount, targetSwap, swap_account_keys, stakeKeys) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, user_wallet_key, userInfoKey, leftAssetPoolKey, leftAssetPoolSplKey, rightAssetPoolKey, rightAssetPoolSplKey, lpAssetPoolKey, lpAssetPoolSplKey, poolSummariesKey, priceSummariesKey, keys, lpPoolId, poolConfig, stakeTableKey, buffer, leftPoolId, rightPoolId, payload, data, inst, tx, _a, _b, stake_ix, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_e.sent())[0];
                        user_wallet_key = walletAccount.publicKey;
                        return [4 /*yield*/, this.addresses.getUserInfoKey(user_wallet_key)];
                    case 2:
                        userInfoKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, leftMintStr)];
                    case 3:
                        leftAssetPoolKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, leftMintStr)];
                    case 4:
                        leftAssetPoolSplKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, rightMintStr)];
                    case 5:
                        rightAssetPoolKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, rightMintStr)];
                    case 6:
                        rightAssetPoolSplKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, lpMintStr)];
                    case 7:
                        lpAssetPoolKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 8:
                        lpAssetPoolSplKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 9:
                        poolSummariesKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(base_pda)];
                    case 10:
                        priceSummariesKey = _e.sent();
                        keys = [
                            { pubkey: user_wallet_key, isSigner: true, isWritable: false },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                            { pubkey: leftAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: leftAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: rightAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: rightAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                        ].concat(swap_account_keys);
                        lpPoolId = this.mintKeyStrToPoolId(lpMintStr);
                        poolConfig = this.addresses.config.getPoolConfigByPoolId(lpPoolId);
                        (0, tiny_invariant_1.default)(poolConfig);
                        if (!poolConfig.lpNeedSndStake) return [3 /*break*/, 12];
                        return [4 /*yield*/, this.addresses.getAssetPoolStakeTableKey(poolConfig.mint.toString())];
                    case 11:
                        stakeTableKey = _e.sent();
                        keys.push({ pubkey: stakeTableKey, isSigner: false, isWritable: true });
                        _e.label = 12;
                    case 12:
                        buffer = new ArrayBuffer(28);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, leftAmount);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 8, rightAmount);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 16, min_lpAmount);
                        leftPoolId = this.mintKeyStrToPoolId(leftMintStr);
                        AccountParser_1.AccountParser.setUint8(buffer, 24, leftPoolId);
                        rightPoolId = this.mintKeyStrToPoolId(rightMintStr);
                        AccountParser_1.AccountParser.setUint8(buffer, 25, rightPoolId);
                        AccountParser_1.AccountParser.setUint8(buffer, 26, lpPoolId);
                        AccountParser_1.AccountParser.setUint8(buffer, 27, targetSwap);
                        payload = Array.from(new Uint8Array(buffer));
                        data = [commands_1.CMD_LP_CREATE].concat(payload);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from(data),
                        });
                        _b = (_a = new web3_js_1.Transaction())
                            .add;
                        return [4 /*yield*/, this.buildLpOpCheckIx(walletAccount.publicKey, leftMintStr, leftAmount, rightMintStr, rightAmount, lpMintStr, min_lpAmount, targetSwap, true, true)];
                    case 13:
                        tx = _b.apply(_a, [_e.sent()])
                            .add(inst);
                        if (!(stakeKeys.length > 0)) return [3 /*break*/, 15];
                        return [4 /*yield*/, this.buildLpStakeIx(lpMintStr, targetSwap, stakeKeys)];
                    case 14:
                        stake_ix = _e.sent();
                        tx.add(stake_ix);
                        _e.label = 15;
                    case 15:
                        _d = (_c = tx).add;
                        return [4 /*yield*/, this.buildLpOpEndcheckIx(walletAccount.publicKey)];
                    case 16: return [2 /*return*/, _d.apply(_c, [_e.sent()])];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildMarginLpRedeemParam = function (leftMintStr, minLeftAmount, rightMintStr, min_rightAmount, lpMintStr, lpAmount, targetSwap) {
        var buffer = new ArrayBuffer(28);
        AccountParser_1.AccountParser.setBigUint64(buffer, 0, minLeftAmount);
        AccountParser_1.AccountParser.setBigUint64(buffer, 8, min_rightAmount);
        AccountParser_1.AccountParser.setBigUint64(buffer, 16, lpAmount);
        var leftPoolId = this.mintKeyStrToPoolId(leftMintStr);
        AccountParser_1.AccountParser.setUint8(buffer, 24, leftPoolId);
        var rightPoolId = this.mintKeyStrToPoolId(rightMintStr);
        AccountParser_1.AccountParser.setUint8(buffer, 25, rightPoolId);
        var lpPoolId = this.mintKeyStrToPoolId(lpMintStr);
        AccountParser_1.AccountParser.setUint8(buffer, 26, lpPoolId);
        AccountParser_1.AccountParser.setUint8(buffer, 27, targetSwap);
        var payload = Array.from(new Uint8Array(buffer));
        return [commands_1.CMD_LP_REDEEM].concat(payload);
    };
    TransactionBuilder.prototype.marginLpRedeem = function (walletKey, leftMintStr, minLeftAmount, rightMintStr, min_rightAmount, lpMintStr, lpAmount, targetSwap, swap_account_keys, unstakeKeys, is_signed) {
        if (is_signed === void 0) { is_signed = true; }
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, userInfoKey, leftAssetPoolKey, leftAssetPoolSplKey, rightAssetPoolKey, rightAssetPoolSplKey, lpAssetPoolKey, lpAssetPoolSplKey, poolSummariesKey, priceSummariesKey, keys, poolId, poolConfig, stakeTableKey, data, inst, tx, _a, _b, unstake_ix, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_e.sent())[0];
                        return [4 /*yield*/, this.addresses.getUserInfoKey(walletKey)];
                    case 2:
                        userInfoKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, leftMintStr)];
                    case 3:
                        leftAssetPoolKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, leftMintStr)];
                    case 4:
                        leftAssetPoolSplKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, rightMintStr)];
                    case 5:
                        rightAssetPoolKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, rightMintStr)];
                    case 6:
                        rightAssetPoolSplKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, lpMintStr)];
                    case 7:
                        lpAssetPoolKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 8:
                        lpAssetPoolSplKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 9:
                        poolSummariesKey = _e.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(base_pda)];
                    case 10:
                        priceSummariesKey = _e.sent();
                        keys = [
                            { pubkey: walletKey, isSigner: is_signed, isWritable: true },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                            { pubkey: leftAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: leftAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: rightAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: rightAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                        ].concat(swap_account_keys);
                        poolId = this.mintKeyStrToPoolId(lpMintStr);
                        poolConfig = this.addresses.config.getPoolConfigByPoolId(poolId);
                        if (!poolConfig.lpNeedSndStake) return [3 /*break*/, 12];
                        return [4 /*yield*/, this.addresses.getAssetPoolStakeTableKey(poolConfig.mint.toString())];
                    case 11:
                        stakeTableKey = _e.sent();
                        keys.push({ pubkey: stakeTableKey, isSigner: false, isWritable: true });
                        _e.label = 12;
                    case 12:
                        data = this.buildMarginLpRedeemParam(leftMintStr, minLeftAmount, rightMintStr, min_rightAmount, lpMintStr, lpAmount, targetSwap);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from(data),
                        });
                        tx = new web3_js_1.Transaction();
                        if (!(targetSwap !== commands_1.SWAP_RAYDIUM)) return [3 /*break*/, 14];
                        _b = (_a = tx).add;
                        return [4 /*yield*/, this.buildLpOpCheckIx(walletKey, leftMintStr, minLeftAmount, rightMintStr, min_rightAmount, lpMintStr, lpAmount, targetSwap, false, is_signed)];
                    case 13:
                        _b.apply(_a, [_e.sent()]);
                        _e.label = 14;
                    case 14:
                        if (!(unstakeKeys.length > 0)) return [3 /*break*/, 16];
                        return [4 /*yield*/, this.buildLpUnstakeIx(lpMintStr, targetSwap, lpAmount, unstakeKeys)];
                    case 15:
                        unstake_ix = _e.sent();
                        tx.add(unstake_ix);
                        _e.label = 16;
                    case 16:
                        tx.add(inst);
                        if (!(targetSwap !== commands_1.SWAP_RAYDIUM)) return [3 /*break*/, 18];
                        _d = (_c = tx).add;
                        return [4 /*yield*/, this.buildLpOpEndcheckIx(walletKey)];
                    case 17:
                        _d.apply(_c, [_e.sent()]);
                        _e.label = 18;
                    case 18: return [2 /*return*/, tx];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpStakeIx = function (lpMintStr, targetSwap, stakeKeys) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, poolSummariesKey, lpAssetPoolSplKey, keys, buffer, payload, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 2:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 3:
                        lpAssetPoolSplKey = _a.sent();
                        keys = [
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                        ].concat(stakeKeys);
                        buffer = new ArrayBuffer(8);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, 0);
                        payload = Array.from(new Uint8Array(buffer));
                        data = [commands_1.CMD_LP_STAKE]
                            .concat(payload)
                            .concat([targetSwap])
                            .concat(this.mintKeyStrToPoolIdArray(lpMintStr));
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from(data),
                            })];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpStake2ndStepIxForOrca = function (lpMintStr, stakeTableKey, floatingLpSplKey, firstStakeKeys, secondStakeKeys) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, adminPubkey, lpAssetPoolKey, lpAssetPoolSplKey, keys, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        adminPubkey = this.addresses.config.refresherKey;
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, lpMintStr)];
                    case 2:
                        lpAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 3:
                        lpAssetPoolSplKey = _a.sent();
                        keys = [
                            { pubkey: adminPubkey, isSigner: true, isWritable: false },
                            { pubkey: lpAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: stakeTableKey, isSigner: false, isWritable: true },
                            { pubkey: floatingLpSplKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                        ]
                            .concat(firstStakeKeys)
                            .concat(secondStakeKeys);
                        data = [commands_1.CMD_LP_STAKE_SECOND];
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from(data),
                            })];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpStake2ndStepIxForRaydium = function (lpMintStr, stakeTableKey, stakeKeys) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, lpAssetPoolKey, lpAssetPoolSplKey, keys, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, lpMintStr)];
                    case 2:
                        lpAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 3:
                        lpAssetPoolSplKey = _a.sent();
                        keys = [
                            { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
                            { pubkey: lpAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: stakeTableKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                        ].concat(stakeKeys);
                        data = [commands_1.CMD_LP_STAKE_SECOND];
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from(data),
                            })];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpUnstake2ndStepIxForOrca = function (unstakeIdentity, userWalletKey, lpMintStr, stakeTableKey, floatingLpSplKey, firstStakeKeys, secondStakeKeys, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, userInfoKey, lpAssetPoolKey, lpAssetPoolSplKey, keys, buffer, payload, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, lpMintStr)];
                    case 3:
                        lpAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 4:
                        lpAssetPoolSplKey = _a.sent();
                        keys = [
                            { pubkey: unstakeIdentity, isSigner: true, isWritable: false },
                            { pubkey: userWalletKey, isSigner: false, isWritable: false },
                            { pubkey: userInfoKey, isSigner: false, isWritable: false },
                            { pubkey: lpAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: stakeTableKey, isSigner: false, isWritable: true },
                            { pubkey: floatingLpSplKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                        ]
                            .concat(secondStakeKeys)
                            .concat(firstStakeKeys);
                        buffer = new ArrayBuffer(8);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        data = [commands_1.CMD_LP_UNSTAKE_SECOND].concat(payload);
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from(data),
                            })];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpUnstake2ndStepIxForRaydium = function (unstakeIdentity, userWalletKey, lpMintStr, stakeTableKey, stakeKeys, amount, leftMintStr, rightMintStr) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, userInfoKey, lpAssetPoolKey, lpAssetPoolSplKey, leftAssetPoolKey, rightAssetPoolKey, poolSummariesKey, keys, buffer, payload, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, lpMintStr)];
                    case 3:
                        lpAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 4:
                        lpAssetPoolSplKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, leftMintStr)];
                    case 5:
                        leftAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, rightMintStr)];
                    case 6:
                        rightAssetPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 7:
                        poolSummariesKey = _a.sent();
                        keys = [
                            { pubkey: unstakeIdentity, isSigner: true, isWritable: false },
                            { pubkey: userWalletKey, isSigner: false, isWritable: false },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: stakeTableKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                            { pubkey: leftAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: rightAssetPoolKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                        ].concat(stakeKeys);
                        buffer = new ArrayBuffer(8);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        data = [commands_1.CMD_LP_UNSTAKE_SECOND].concat(payload);
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from(data),
                            })];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildLpUnstakeIx = function (lpMintStr, targetSwap, amount, stakeKeys) {
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, poolSummariesKey, lpAssetPoolSplKey, keys, buffer, payload, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 2:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, lpMintStr)];
                    case 3:
                        lpAssetPoolSplKey = _a.sent();
                        keys = [
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: lpAssetPoolSplKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                        ].concat(stakeKeys);
                        buffer = new ArrayBuffer(8);
                        AccountParser_1.AccountParser.setBigUint64(buffer, 0, amount);
                        payload = Array.from(new Uint8Array(buffer));
                        data = [commands_1.CMD_LP_UNSTAKE]
                            .concat(payload)
                            .concat([targetSwap])
                            .concat(this.mintKeyStrToPoolIdArray(lpMintStr));
                        return [2 /*return*/, new web3_js_1.TransactionInstruction({
                                programId: this.addresses.getProgramKey(),
                                keys: keys,
                                data: Buffer.from(data),
                            })];
                }
            });
        });
    };
    // simplified interface for marginLpCreate and marginLpRedeem
    TransactionBuilder.prototype.simpleLpCreate = function (walletAccount, lpTokenId, leftAmount, rightAmount, minLpAmount) {
        return __awaiter(this, void 0, void 0, function () {
            var lr, leftId, rightId, lpMint, leftMint, rightMint, poolConfig, stakeKeys, _a, tx, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        lr = configs_1.LP_TO_LR[lpTokenId];
                        (0, tiny_invariant_1.default)(lr);
                        leftId = lr[0], rightId = lr[1];
                        lpMint = configs_1.MINTS[lpTokenId];
                        leftMint = configs_1.MINTS[leftId];
                        rightMint = configs_1.MINTS[rightId];
                        poolConfig = this.addresses.config.poolConfigs[lpTokenId];
                        (0, tiny_invariant_1.default)(poolConfig, 'invalid lp token id for pool config');
                        if (!poolConfig.lpNeedSndStake) return [3 /*break*/, 1];
                        _a = [];
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.addresses.getLpStakeKeys(lpTokenId)];
                    case 2:
                        _a = _d.sent();
                        _d.label = 3;
                    case 3:
                        stakeKeys = _a;
                        _b = this.marginLpCreate;
                        _c = [walletAccount,
                            leftMint.toString(),
                            leftAmount,
                            rightMint.toString(),
                            rightAmount,
                            lpMint.toString(),
                            minLpAmount,
                            this.addresses.getLpTargetSwap(lpTokenId)];
                        return [4 /*yield*/, this.addresses.getLpDepositKeys(lpTokenId)];
                    case 4: return [4 /*yield*/, _b.apply(this, _c.concat([_d.sent(), stakeKeys]))];
                    case 5:
                        tx = _d.sent();
                        return [2 /*return*/, tx];
                }
            });
        });
    };
    TransactionBuilder.prototype.lpStake2nd = function (lpTokenId) {
        return __awaiter(this, void 0, void 0, function () {
            var tx, lpMint, stakeTableKey, targetSwap, floatingLpSplKey, ix, _a, _b, ix, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        tx = new web3_js_1.Transaction();
                        lpMint = configs_1.MINTS[lpTokenId];
                        return [4 /*yield*/, this.addresses.getAssetPoolStakeTableKey(lpMint.toString())];
                    case 1:
                        stakeTableKey = _e.sent();
                        targetSwap = this.addresses.getLpTargetSwap(lpTokenId);
                        if (!(targetSwap === commands_1.SWAP_ORCA)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.addresses.getFloatingLpTokenAccount(lpTokenId)];
                    case 2:
                        floatingLpSplKey = _e.sent();
                        _a = this.buildLpStake2ndStepIxForOrca;
                        _b = [lpMint.toString(),
                            stakeTableKey,
                            floatingLpSplKey];
                        // orca needs to stake both LP1 and LP2
                        return [4 /*yield*/, this.addresses.getLpFirstStakeKeys(lpTokenId)];
                    case 3:
                        _b = _b.concat([
                            // orca needs to stake both LP1 and LP2
                            _e.sent()]);
                        return [4 /*yield*/, this.addresses.getLpSecondStakeKeys(lpTokenId)];
                    case 4: return [4 /*yield*/, _a.apply(this, _b.concat([_e.sent()]))];
                    case 5:
                        ix = _e.sent();
                        tx.add(ix);
                        return [3 /*break*/, 10];
                    case 6:
                        if (!(targetSwap === commands_1.SWAP_RAYDIUM)) return [3 /*break*/, 9];
                        _c = this.buildLpStake2ndStepIxForRaydium;
                        _d = [lpMint.toString(),
                            stakeTableKey];
                        return [4 /*yield*/, this.addresses.getLpStakeKeys(lpTokenId)];
                    case 7: return [4 /*yield*/, _c.apply(this, _d.concat([_e.sent()]))];
                    case 8:
                        ix = _e.sent();
                        tx.add(ix);
                        return [3 /*break*/, 10];
                    case 9: throw new Error("invalid target swap for lp stake 2nd");
                    case 10: return [2 /*return*/, tx];
                }
            });
        });
    };
    TransactionBuilder.prototype.lpUnstake2nd = function (unstakeIdentity, walletKey, lpTokenId, lpAmount) {
        return __awaiter(this, void 0, void 0, function () {
            var lr, leftId, rightId, leftMint, rightMint, tx, lpMint, stakeTableKey, targetSwap, floatingLpSplKey, ix, _a, _b, ix, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        lr = configs_1.LP_TO_LR[lpTokenId];
                        (0, tiny_invariant_1.default)(lr);
                        leftId = lr[0], rightId = lr[1];
                        leftMint = configs_1.MINTS[leftId];
                        rightMint = configs_1.MINTS[rightId];
                        tx = new web3_js_1.Transaction();
                        lpMint = configs_1.MINTS[lpTokenId];
                        return [4 /*yield*/, this.addresses.getAssetPoolStakeTableKey(lpMint.toString())];
                    case 1:
                        stakeTableKey = _e.sent();
                        targetSwap = this.addresses.getLpTargetSwap(lpTokenId);
                        if (!(targetSwap === commands_1.SWAP_ORCA)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.addresses.getFloatingLpTokenAccount(lpTokenId)];
                    case 2:
                        floatingLpSplKey = _e.sent();
                        _a = this.buildLpUnstake2ndStepIxForOrca;
                        _b = [unstakeIdentity,
                            walletKey,
                            lpMint.toString(),
                            stakeTableKey,
                            floatingLpSplKey];
                        // orca needs to unstake both LP2 and LP3
                        return [4 /*yield*/, this.addresses.getLpFirstStakeKeys(lpTokenId)];
                    case 3:
                        _b = _b.concat([
                            // orca needs to unstake both LP2 and LP3
                            _e.sent()]);
                        return [4 /*yield*/, this.addresses.getLpSecondStakeKeys(lpTokenId)];
                    case 4: return [4 /*yield*/, _a.apply(this, _b.concat([_e.sent(), lpAmount]))];
                    case 5:
                        ix = _e.sent();
                        tx.add(ix);
                        return [3 /*break*/, 10];
                    case 6:
                        if (!(targetSwap === commands_1.SWAP_RAYDIUM)) return [3 /*break*/, 9];
                        _c = this.buildLpUnstake2ndStepIxForRaydium;
                        _d = [unstakeIdentity,
                            walletKey,
                            lpMint.toString(),
                            stakeTableKey];
                        return [4 /*yield*/, this.addresses.getLpStakeKeys(lpTokenId)];
                    case 7: return [4 /*yield*/, _c.apply(this, _d.concat([_e.sent(), lpAmount,
                            leftMint.toString(),
                            rightMint.toString()]))];
                    case 8:
                        ix = _e.sent();
                        tx.add(ix);
                        return [3 /*break*/, 10];
                    case 9: throw new Error("invalid target swap for lp unstake 2nd");
                    case 10: return [2 /*return*/, tx];
                }
            });
        });
    };
    TransactionBuilder.prototype.simpleLpRedeem = function (walletKey, lpTokenId, minLeftAmount, minRightAmount, lpAmount, isSigned) {
        return __awaiter(this, void 0, void 0, function () {
            var lr, leftId, rightId, lpMint, leftMint, rightMint, poolConfig, stakeKeys, _a, tx, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        lr = configs_1.LP_TO_LR[lpTokenId];
                        (0, tiny_invariant_1.default)(lr);
                        leftId = lr[0], rightId = lr[1];
                        lpMint = configs_1.MINTS[lpTokenId];
                        leftMint = configs_1.MINTS[leftId];
                        rightMint = configs_1.MINTS[rightId];
                        poolConfig = this.addresses.config.poolConfigs[lpTokenId];
                        (0, tiny_invariant_1.default)(poolConfig, 'invalid lp token id for pool config');
                        if (!poolConfig.lpNeedSndStake) return [3 /*break*/, 1];
                        _a = [];
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.addresses.getLpStakeKeys(lpTokenId)];
                    case 2:
                        _a = _d.sent();
                        _d.label = 3;
                    case 3:
                        stakeKeys = _a;
                        _b = this.marginLpRedeem;
                        _c = [walletKey,
                            leftMint.toString(),
                            minLeftAmount,
                            rightMint.toString(),
                            minRightAmount,
                            lpMint.toString(),
                            lpAmount,
                            this.addresses.getLpTargetSwap(lpTokenId)];
                        return [4 /*yield*/, this.addresses.getLpWithdrawKeys(lpTokenId)];
                    case 4: return [4 /*yield*/, _b.apply(this, _c.concat([_d.sent(), stakeKeys,
                            isSigned]))];
                    case 5:
                        tx = _d.sent();
                        return [2 /*return*/, tx];
                }
            });
        });
    };
    TransactionBuilder.prototype.buildMarginSwapParam = function (target_swap, is_buy, sell_mint_str, sell_amount, buy_mint_str, buy_amount, is_swap_all_deposit) {
        var buffer = new ArrayBuffer(1 + 8 + 8);
        AccountParser_1.AccountParser.setUint8(buffer, 0, is_buy ? 1 : 0);
        AccountParser_1.AccountParser.setBigUint64(buffer, 1, sell_amount);
        AccountParser_1.AccountParser.setBigUint64(buffer, 9, buy_amount);
        var payload = Array.from(new Uint8Array(buffer));
        var sellPoolIdArray = this.mintKeyStrToPoolIdArray(sell_mint_str);
        var buyPoolIdArray = this.mintKeyStrToPoolIdArray(buy_mint_str);
        return [commands_1.CMD_MARGIN_SWAP]
            .concat(payload)
            .concat(sellPoolIdArray)
            .concat(buyPoolIdArray)
            .concat([target_swap])
            .concat([is_swap_all_deposit ? 1 : 0]);
    };
    TransactionBuilder.prototype.canSwap = function (sellTokenId, buyTokenId) {
        var isBuy = buyTokenId in configs_1.DIRECT_SWAP_META && sellTokenId in configs_1.DIRECT_SWAP_META[buyTokenId];
        var isSell = sellTokenId in configs_1.DIRECT_SWAP_META && buyTokenId in configs_1.DIRECT_SWAP_META[sellTokenId];
        return isBuy || isSell;
    };
    TransactionBuilder.prototype.marginSwap = function (userWalletKey, targetSwap, isBuy, sellMintStr, sellAmount, buyMintStr, buyAmount, swapKeys, isSigned, isSwapAllDeposit) {
        if (isSwapAllDeposit === void 0) { isSwapAllDeposit = false; }
        return __awaiter(this, void 0, void 0, function () {
            var base_pda, userInfoKey, collateralPoolKey, collateralPoolSpl, borrowedPoolKey, borrowedPoolSpl, poolSummariesKey, priceSummariesKey, keys, data, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        base_pda = (_a.sent())[0];
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, sellMintStr)];
                    case 3:
                        collateralPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, sellMintStr)];
                    case 4:
                        collateralPoolSpl = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolKey(base_pda, buyMintStr)];
                    case 5:
                        borrowedPoolKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getAssetPoolSplKey(base_pda, buyMintStr)];
                    case 6:
                        borrowedPoolSpl = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 7:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(base_pda)];
                    case 8:
                        priceSummariesKey = _a.sent();
                        keys = [
                            { pubkey: userWalletKey, isSigner: isSigned, isWritable: false },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: base_pda, isSigner: false, isWritable: false },
                            { pubkey: collateralPoolKey, isSigner: false, isWritable: true },
                            { pubkey: collateralPoolSpl, isSigner: false, isWritable: true },
                            { pubkey: borrowedPoolKey, isSigner: false, isWritable: true },
                            { pubkey: borrowedPoolSpl, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // spl-token program account
                        ].concat(swapKeys);
                        data = this.buildMarginSwapParam(targetSwap, isBuy, sellMintStr, sellAmount, buyMintStr, buyAmount, isSwapAllDeposit);
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from(data),
                        });
                        return [2 /*return*/, new web3_js_1.Transaction().add(inst)];
                }
            });
        });
    };
    TransactionBuilder.prototype.simpleSwap = function (userWalletKey, sellTokenId, buyTokenId, sellAmount, minBuyAmount, isSigned, isSwapAllDeposit) {
        if (isSwapAllDeposit === void 0) { isSwapAllDeposit = false; }
        return __awaiter(this, void 0, void 0, function () {
            var sellMint, buyMint, isBuy, swapInfo, swapKeys;
            return __generator(this, function (_a) {
                sellMint = configs_1.MINTS[sellTokenId];
                buyMint = configs_1.MINTS[buyTokenId];
                (0, tiny_invariant_1.default)(this.canSwap(sellTokenId, buyTokenId));
                isBuy = buyTokenId in configs_1.DIRECT_SWAP_META && sellTokenId in configs_1.DIRECT_SWAP_META[buyTokenId];
                swapInfo = isBuy
                    ? configs_1.DIRECT_SWAP_META[buyTokenId][sellTokenId]
                    : configs_1.DIRECT_SWAP_META[sellTokenId][buyTokenId];
                swapKeys = isBuy ? swapInfo.getSwapKeys(true) : swapInfo.getSwapKeys(false);
                return [2 /*return*/, this.marginSwap(userWalletKey, swapInfo.targetSwap, isBuy, sellMint.toString(), sellAmount, buyMint.toString(), minBuyAmount, swapKeys, isSigned, isSwapAllDeposit)];
            });
        });
    };
    TransactionBuilder.prototype.makeLmRewardClaimable = function (userWallet) {
        return __awaiter(this, void 0, void 0, function () {
            var userInfoKey, poolSummariesKey, tx, keys, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getUserInfoKey(userWallet)];
                    case 1:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 2:
                        poolSummariesKey = _a.sent();
                        tx = new web3_js_1.Transaction();
                        keys = [
                            { pubkey: userWallet, isSigner: true, isWritable: false },
                            { pubkey: userWallet, isSigner: false, isWritable: false },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                        ];
                        inst = new web3_js_1.TransactionInstruction({
                            programId: this.addresses.getProgramKey(),
                            keys: keys,
                            data: Buffer.from([commands_1.CMD_MAKE_LM_REWARD_AVAILABLE]),
                        });
                        tx.add(inst);
                        return [2 /*return*/, tx];
                }
            });
        });
    };
    TransactionBuilder.prototype.claimAPTLMReward = function (userWalletKey, userAptSpl) {
        return __awaiter(this, void 0, void 0, function () {
            var basePda, programId, userInfoKey, APTRewardVaultKey, poolSummariesKey, priceSummariesKey, keys, txn, inst;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addresses.getBasePda()];
                    case 1:
                        basePda = (_a.sent())[0];
                        programId = this.addresses.getProgramKey();
                        return [4 /*yield*/, this.addresses.getUserInfoKey(userWalletKey)];
                    case 2:
                        userInfoKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getLmAptVault()];
                    case 3:
                        APTRewardVaultKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPoolSummariesKey()];
                    case 4:
                        poolSummariesKey = _a.sent();
                        return [4 /*yield*/, this.addresses.getPriceSummariesKey(basePda)];
                    case 5:
                        priceSummariesKey = _a.sent();
                        keys = [
                            { pubkey: basePda, isSigner: false, isWritable: false },
                            { pubkey: userWalletKey, isSigner: true, isWritable: true },
                            { pubkey: userInfoKey, isSigner: false, isWritable: true },
                            { pubkey: userAptSpl, isSigner: false, isWritable: true },
                            { pubkey: APTRewardVaultKey, isSigner: false, isWritable: true },
                            { pubkey: poolSummariesKey, isSigner: false, isWritable: true },
                            { pubkey: priceSummariesKey, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                        ];
                        txn = new web3_js_1.Transaction();
                        inst = new web3_js_1.TransactionInstruction({
                            programId: programId,
                            keys: keys,
                            data: Buffer.from([commands_1.CMD_CLAIM_APT_LM_REWARD]),
                        });
                        txn.add(inst);
                        return [2 /*return*/, txn];
                }
            });
        });
    };
    return TransactionBuilder;
}());
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=TransactionBuilder.js.map