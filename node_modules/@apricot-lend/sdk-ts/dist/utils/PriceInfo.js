"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriceInfo = void 0;
var spl_token_1 = require("@solana/spl-token");
var switchboard = __importStar(require("@switchboard-xyz/switchboard-api"));
var tiny_invariant_1 = __importDefault(require("tiny-invariant"));
var constants_1 = require("../constants");
var types_1 = require("../types");
var decimal_js_1 = __importDefault(require("decimal.js"));
var serum_1 = require("@project-serum/serum");
var __1 = require("..");
var axios_1 = __importDefault(require("axios"));
var rax = __importStar(require("retry-axios"));
var Layouts_1 = require("./Layouts");
var client_1 = require("@pythnetwork/client");
var buffer_1 = require("buffer");
var coingecko_api_1 = __importDefault(require("coingecko-api"));
rax.attach();
var checkIsValidNumber = function (n) {
    return (0, tiny_invariant_1.default)(typeof n === 'number' && !(isNaN(n) || n === Infinity || n === -Infinity) && Number.isFinite(n), 'Invalid number');
};
var bufferToHexStr = function (buffer) { return spl_token_1.u64.fromBuffer(buffer).toString(); };
var PriceInfo = /** @class */ (function () {
    function PriceInfo(config) {
        this.config = config;
        this.cachedRaydiumContent = null;
        this.raydiumCacheTime = 0;
        this.coinGecko = new coingecko_api_1.default();
    }
    PriceInfo.prototype.fetchPrice = function (tokId, connection, isForcePriceByChain) {
        if (isForcePriceByChain === void 0) { isForcePriceByChain = false; }
        return __awaiter(this, void 0, void 0, function () {
            var poolConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(tokId in this.config.switchboardPriceKeys)) return [3 /*break*/, 1];
                        return [2 /*return*/, this.fetchViaSwitchboard(tokId, connection)];
                    case 1:
                        (0, tiny_invariant_1.default)(tokId in this.config.poolConfigs);
                        poolConfig = this.config.poolConfigs[tokId];
                        (0, tiny_invariant_1.default)(poolConfig.isLp(), 'volatile/stable tokens should be priced through switchboard');
                        if (!isForcePriceByChain) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.computeLpPriceOnChain(tokId, poolConfig, connection)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        if (poolConfig.lpDex === __1.Dex.Raydium) {
                            return [2 /*return*/, this.getRaydiumLpPrice(poolConfig, connection)];
                        }
                        else {
                            return [2 /*return*/, this.computeLpPrice(tokId, poolConfig, connection)];
                        }
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    PriceInfo.prototype.fetchViaSwitchboard = function (tokId, connection) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var key, data, price;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        key = this.config.switchboardPriceKeys[tokId];
                        (0, tiny_invariant_1.default)(key, tokId + " not available through switchboard");
                        return [4 /*yield*/, switchboard.parseAggregatorAccountData(connection, key)];
                    case 1:
                        data = _c.sent();
                        price = (_a = data.currentRoundResult) === null || _a === void 0 ? void 0 : _a.result;
                        if (!price) {
                            price = (_b = data.lastRoundResult) === null || _b === void 0 ? void 0 : _b.result;
                        }
                        (0, tiny_invariant_1.default)(price);
                        return [2 /*return*/, price];
                }
            });
        });
    };
    PriceInfo.prototype.fetchViaPyth = function (tokId, connection) {
        return __awaiter(this, void 0, void 0, function () {
            var key, accountInfo, parsedData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        key = this.config.pythPriceKeys[tokId];
                        (0, tiny_invariant_1.default)(key, tokId + " not available through pyth");
                        return [4 /*yield*/, connection.getAccountInfo(key, 'confirmed')];
                    case 1:
                        accountInfo = _a.sent();
                        (0, tiny_invariant_1.default)(accountInfo, tokId + " PriceData not available through pyth");
                        parsedData = (0, client_1.parsePriceData)(accountInfo.data);
                        (0, tiny_invariant_1.default)(parsedData.price, tokId + " returned invalid price from pyth");
                        return [2 /*return*/, parsedData.price];
                }
            });
        });
    };
    PriceInfo.prototype.checkRaydiumCache = function (requestTimeout, retries) {
        if (requestTimeout === void 0) { requestTimeout = 8000; }
        if (retries === void 0) { retries = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var now, response, content, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        now = Date.now();
                        if (!(now - this.raydiumCacheTime > 30 * 1000)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, axios_1.default.get('https://api.raydium.io/pairs', {
                                timeout: requestTimeout,
                                raxConfig: {
                                    retry: retries,
                                    noResponseRetries: retries,
                                    backoffType: 'exponential',
                                    statusCodesToRetry: [
                                        [100, 199],
                                        [400, 429],
                                        [500, 599],
                                    ],
                                    onRetryAttempt: function (err) {
                                        var cfg = rax.getConfig(err);
                                        console.log("Raydium pairs request retry attempt #" + (cfg === null || cfg === void 0 ? void 0 : cfg.currentRetryAttempt));
                                    },
                                },
                            })];
                    case 2:
                        response = _a.sent();
                        content = response.data;
                        this.cachedRaydiumContent = content;
                        this.raydiumCacheTime = Date.now();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        if (axios_1.default.isAxiosError(error_1)) {
                            console.log("Request raydium failed: " + error_1.message);
                        }
                        else {
                            console.log(error_1);
                        }
                        throw error_1;
                    case 4:
                        (0, tiny_invariant_1.default)(this.cachedRaydiumContent);
                        return [2 /*return*/, this.cachedRaydiumContent];
                }
            });
        });
    };
    PriceInfo.prototype.getRaydiumLpPrice = function (poolConfig, connection) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, leftTokId, rightTokId, leftPrice, rightPrice, mintStr, raydiumContent, filtered, entry, price;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = poolConfig.lpLeftRightTokenId, leftTokId = _a[0], rightTokId = _a[1];
                        return [4 /*yield*/, this.fetchPrice(leftTokId, connection)];
                    case 1:
                        leftPrice = _b.sent();
                        return [4 /*yield*/, this.fetchPrice(rightTokId, connection)];
                    case 2:
                        rightPrice = _b.sent();
                        mintStr = poolConfig.mint.toString();
                        return [4 /*yield*/, this.checkRaydiumCache()];
                    case 3:
                        raydiumContent = _b.sent();
                        filtered = raydiumContent.filter(function (entry) { return entry.lp_mint === mintStr; });
                        entry = filtered[0];
                        price = (leftPrice * entry.token_amount_coin + rightPrice * entry.token_amount_pc) /
                            entry.token_amount_lp;
                        checkIsValidNumber(price);
                        return [2 /*return*/, price];
                }
            });
        });
    };
    PriceInfo.prototype.computeLpPriceOnChain = function (lpTokId, poolConfig, connection) {
        return __awaiter(this, void 0, void 0, function () {
            var lpMint, _a, leftTokId, rightTokId, _b, leftVault, rightVault, accountKeys, raydiumPoolMeta, leftAmount, rightAmount, lpAmount, infosRaw, infos, leftPrice, rightPrice, price, priNum;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        (0, tiny_invariant_1.default)(poolConfig.isLp());
                        (0, tiny_invariant_1.default)(poolConfig.tokenId === lpTokId);
                        lpMint = poolConfig.mint;
                        _a = poolConfig.lpLeftRightTokenId, leftTokId = _a[0], rightTokId = _a[1];
                        (0, tiny_invariant_1.default)(lpMint);
                        (0, tiny_invariant_1.default)(leftTokId);
                        (0, tiny_invariant_1.default)(rightTokId);
                        (0, tiny_invariant_1.default)(lpTokId in constants_1.LP_SWAP_METAS);
                        _b = constants_1.LP_SWAP_METAS[lpTokId].getLRVaults(), leftVault = _b[0], rightVault = _b[1];
                        accountKeys = [leftVault, rightVault, lpMint];
                        if (poolConfig.lpDex === __1.Dex.Raydium) {
                            raydiumPoolMeta = constants_1.RAYDIUM_LP_METAS[lpTokId];
                            (0, tiny_invariant_1.default)(raydiumPoolMeta);
                            accountKeys.push(raydiumPoolMeta.ammOpenOrdersPubkey, raydiumPoolMeta.ammIdPubkey);
                        }
                        leftAmount = new decimal_js_1.default(0);
                        rightAmount = new decimal_js_1.default(0);
                        lpAmount = new decimal_js_1.default(0);
                        // console.log(`keys: `, accountKeys.map(k => k.toBase58()));
                        console.log("Is calculating price via getMultipleAccountsInfo ...");
                        return [4 /*yield*/, connection.getMultipleAccountsInfo(accountKeys, 'confirmed')];
                    case 1:
                        infosRaw = _c.sent();
                        infos = infosRaw;
                        infos.forEach(function (info, i) {
                            (0, tiny_invariant_1.default)(info, "Fetch multiple account info failed at " + i);
                            if (i <= 1) {
                                (0, tiny_invariant_1.default)(info.data.length === spl_token_1.AccountLayout.span, 'Invalid token account info data length');
                                var account = spl_token_1.AccountLayout.decode(info.data);
                                if (i === 0)
                                    leftAmount = leftAmount.plus(bufferToHexStr(account.amount));
                                if (i === 1)
                                    rightAmount = rightAmount.plus(bufferToHexStr(account.amount));
                            }
                            else if (i === 2) {
                                (0, tiny_invariant_1.default)(info.data.length === spl_token_1.MintLayout.span, 'Invalid mint account info data length');
                                var account = spl_token_1.MintLayout.decode(info.data);
                                lpAmount = lpAmount.plus(bufferToHexStr(account.supply));
                            }
                            else if (poolConfig.lpDex === __1.Dex.Raydium) {
                                if (i === 3) {
                                    var raydiumPoolMeta = constants_1.RAYDIUM_LP_METAS[lpTokId];
                                    (0, tiny_invariant_1.default)(raydiumPoolMeta);
                                    var LAYOUT = serum_1.OpenOrders.getLayout(raydiumPoolMeta.serumProgramId);
                                    (0, tiny_invariant_1.default)(info.data.length === LAYOUT.span, 'Invalid raydium open orders account info data length');
                                    var parsedOpenOrders = LAYOUT.decode(info.data);
                                    var baseTokenTotal = parsedOpenOrders.baseTokenTotal, quoteTokenTotal = parsedOpenOrders.quoteTokenTotal;
                                    leftAmount = leftAmount.plus(baseTokenTotal.toString()); // BN
                                    rightAmount = rightAmount.plus(quoteTokenTotal.toString()); // BN
                                }
                                else if (i === 4) {
                                    (0, tiny_invariant_1.default)(info.data.length === Layouts_1.AMM_INFO_LAYOUT_V4.span, 'invalid raydium amm ID account data length');
                                    var _a = Layouts_1.AMM_INFO_LAYOUT_V4.decode(info.data), needTakePnlCoin = _a.needTakePnlCoin, needTakePnlPc = _a.needTakePnlPc;
                                    leftAmount = leftAmount.minus(needTakePnlCoin.toString());
                                    rightAmount = rightAmount.minus(needTakePnlPc.toString());
                                }
                                else {
                                    throw new Error('Invalid multiple accounts info index');
                                }
                            }
                            else {
                                throw new Error('Invalid multiple accounts info index');
                            }
                            // console.log(`l:r:lp`, leftAmount.toString(), rightAmount.toString(), lpAmount.toString());
                        });
                        return [4 /*yield*/, this.fetchPrice(leftTokId, connection)];
                    case 2:
                        leftPrice = _c.sent();
                        return [4 /*yield*/, this.fetchPrice(rightTokId, connection)];
                    case 3:
                        rightPrice = _c.sent();
                        price = leftAmount
                            .div(constants_1.DECIMAL_MULT[leftTokId])
                            .mul(leftPrice)
                            .plus(rightAmount.div(constants_1.DECIMAL_MULT[rightTokId]).mul(rightPrice))
                            .div(lpAmount.div(constants_1.DECIMAL_MULT[lpTokId]));
                        priNum = price.toNumber();
                        checkIsValidNumber(priNum);
                        return [2 /*return*/, priNum];
                }
            });
        });
    };
    PriceInfo.prototype.computeLpPrice = function (lpTokId, poolConfig, connection) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var lpMint, _c, leftTokId, rightTokId, _d, leftVault, rightVault, leftBalance, rightBalance, lpMintData, lpBalanceStr, decimalMult, lpBalance, _e, additionalLeftNative, additionalRightNative, additionalLeftBalance, additionalRightBalance, leftPrice, rightPrice, price;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        (0, tiny_invariant_1.default)(poolConfig.isLp());
                        (0, tiny_invariant_1.default)(poolConfig.tokenId === lpTokId);
                        lpMint = poolConfig.mint;
                        _c = poolConfig.lpLeftRightTokenId, leftTokId = _c[0], rightTokId = _c[1];
                        (0, tiny_invariant_1.default)(lpMint);
                        (0, tiny_invariant_1.default)(leftTokId);
                        (0, tiny_invariant_1.default)(rightTokId);
                        (0, tiny_invariant_1.default)(lpTokId in constants_1.LP_SWAP_METAS);
                        _d = constants_1.LP_SWAP_METAS[lpTokId].getLRVaults(), leftVault = _d[0], rightVault = _d[1];
                        return [4 /*yield*/, connection.getTokenAccountBalance(leftVault)];
                    case 1:
                        leftBalance = (_f.sent()).value.uiAmount;
                        return [4 /*yield*/, connection.getTokenAccountBalance(rightVault)];
                    case 2:
                        rightBalance = (_f.sent()).value.uiAmount;
                        return [4 /*yield*/, connection.getParsedAccountInfo(lpMint)];
                    case 3:
                        lpMintData = (_a = (_f.sent()).value) === null || _a === void 0 ? void 0 : _a.data;
                        lpBalanceStr = (_b = lpMintData.parsed) === null || _b === void 0 ? void 0 : _b.info.supply;
                        decimalMult = constants_1.DECIMAL_MULT[lpTokId];
                        lpBalance = new decimal_js_1.default(lpBalanceStr).div(decimalMult).toNumber();
                        if (!(poolConfig.lpDex === __1.Dex.Raydium)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.getRaydiumAdditionalBalance(lpTokId, connection)];
                    case 4:
                        _e = _f.sent(), additionalLeftNative = _e[0], additionalRightNative = _e[1];
                        additionalLeftBalance = additionalLeftNative / constants_1.DECIMAL_MULT[leftTokId];
                        additionalRightBalance = additionalRightNative / constants_1.DECIMAL_MULT[rightTokId];
                        leftBalance += additionalLeftBalance;
                        rightBalance += additionalRightBalance;
                        _f.label = 5;
                    case 5: return [4 /*yield*/, this.fetchPrice(leftTokId, connection)];
                    case 6:
                        leftPrice = _f.sent();
                        return [4 /*yield*/, this.fetchPrice(rightTokId, connection)];
                    case 7:
                        rightPrice = _f.sent();
                        price = (leftPrice * leftBalance + rightPrice * rightBalance) / lpBalance;
                        checkIsValidNumber(price);
                        return [2 /*return*/, price];
                }
            });
        });
    };
    PriceInfo.prototype.fetchLRStats = function (lpTokId, connection, isValue) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, leftBalance, rightBalance, poolConfig, _b, leftTokId, rightTokId, leftPrice, rightPrice;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.fetchLRLpAmounts(lpTokId, connection)];
                    case 1:
                        _a = _c.sent(), leftBalance = _a[0], rightBalance = _a[1];
                        if (!isValue) {
                            return [2 /*return*/, [leftBalance, rightBalance]];
                        }
                        poolConfig = this.config.poolConfigs[lpTokId];
                        (0, tiny_invariant_1.default)(poolConfig.isLp());
                        (0, tiny_invariant_1.default)(poolConfig.tokenId === lpTokId);
                        _b = poolConfig.lpLeftRightTokenId, leftTokId = _b[0], rightTokId = _b[1];
                        (0, tiny_invariant_1.default)(leftTokId);
                        (0, tiny_invariant_1.default)(rightTokId);
                        return [4 /*yield*/, this.fetchPrice(leftTokId, connection)];
                    case 2:
                        leftPrice = _c.sent();
                        return [4 /*yield*/, this.fetchPrice(rightTokId, connection)];
                    case 3:
                        rightPrice = _c.sent();
                        return [2 /*return*/, [leftBalance * leftPrice, rightBalance * rightPrice]];
                }
            });
        });
    };
    PriceInfo.prototype.fetchLRAmounts = function (lpTokId, connection) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.fetchLRStats(lpTokId, connection, false)];
            });
        });
    };
    PriceInfo.prototype.fetchLRValuets = function (lpTokId, connection) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.fetchLRStats(lpTokId, connection, true)];
            });
        });
    };
    PriceInfo.prototype.fetchLRLpAmounts = function (lpTokId, connection) {
        return __awaiter(this, void 0, void 0, function () {
            var poolConfig, lpMint, _a, leftTokId, rightTokId, _b, leftVault, rightVault, accountKeys, raydiumPoolMeta, leftAmount, rightAmount, lpAmount, infosRaw, infos, leftAmt, rightAmt, lpAmt;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        poolConfig = this.config.poolConfigs[lpTokId];
                        (0, tiny_invariant_1.default)(poolConfig.isLp());
                        (0, tiny_invariant_1.default)(poolConfig.tokenId === lpTokId);
                        lpMint = poolConfig.mint;
                        _a = poolConfig.lpLeftRightTokenId, leftTokId = _a[0], rightTokId = _a[1];
                        (0, tiny_invariant_1.default)(lpMint);
                        (0, tiny_invariant_1.default)(leftTokId);
                        (0, tiny_invariant_1.default)(rightTokId);
                        (0, tiny_invariant_1.default)(lpTokId in constants_1.LP_SWAP_METAS);
                        _b = constants_1.LP_SWAP_METAS[lpTokId].getLRVaults(), leftVault = _b[0], rightVault = _b[1];
                        accountKeys = [leftVault, rightVault, lpMint];
                        if (poolConfig.lpDex === __1.Dex.Raydium) {
                            raydiumPoolMeta = constants_1.RAYDIUM_LP_METAS[lpTokId];
                            (0, tiny_invariant_1.default)(raydiumPoolMeta);
                            accountKeys.push(raydiumPoolMeta.ammOpenOrdersPubkey, raydiumPoolMeta.ammIdPubkey);
                        }
                        leftAmount = new decimal_js_1.default(0);
                        rightAmount = new decimal_js_1.default(0);
                        lpAmount = new decimal_js_1.default(0);
                        return [4 /*yield*/, connection.getMultipleAccountsInfo(accountKeys, 'confirmed')];
                    case 1:
                        infosRaw = _c.sent();
                        infos = infosRaw;
                        infos.forEach(function (info, i) {
                            (0, tiny_invariant_1.default)(info, "Fetch multiple account info failed at " + i);
                            if (i <= 1) {
                                (0, tiny_invariant_1.default)(info.data.length === spl_token_1.AccountLayout.span, 'Invalid token account info data length');
                                var account = spl_token_1.AccountLayout.decode(info.data);
                                if (i === 0)
                                    leftAmount = leftAmount.plus(bufferToHexStr(account.amount));
                                if (i === 1)
                                    rightAmount = rightAmount.plus(bufferToHexStr(account.amount));
                            }
                            else if (i === 2) {
                                (0, tiny_invariant_1.default)(info.data.length === spl_token_1.MintLayout.span, 'Invalid mint account info data length');
                                var account = spl_token_1.MintLayout.decode(info.data);
                                lpAmount = lpAmount.plus(bufferToHexStr(account.supply));
                            }
                            else if (poolConfig.lpDex === __1.Dex.Raydium) {
                                if (i === 3) {
                                    var raydiumPoolMeta = constants_1.RAYDIUM_LP_METAS[lpTokId];
                                    (0, tiny_invariant_1.default)(raydiumPoolMeta);
                                    var LAYOUT = serum_1.OpenOrders.getLayout(raydiumPoolMeta.serumProgramId);
                                    (0, tiny_invariant_1.default)(info.data.length === LAYOUT.span, 'Invalid raydium open orders account info data length');
                                    var parsedOpenOrders = LAYOUT.decode(info.data);
                                    var baseTokenTotal = parsedOpenOrders.baseTokenTotal, quoteTokenTotal = parsedOpenOrders.quoteTokenTotal;
                                    leftAmount = leftAmount.plus(baseTokenTotal.toString()); // BN
                                    rightAmount = rightAmount.plus(quoteTokenTotal.toString()); // BN
                                }
                                else if (i === 4) {
                                    (0, tiny_invariant_1.default)(info.data.length === Layouts_1.AMM_INFO_LAYOUT_V4.span, 'invalid raydium amm ID account data length');
                                    var _a = Layouts_1.AMM_INFO_LAYOUT_V4.decode(info.data), needTakePnlCoin = _a.needTakePnlCoin, needTakePnlPc = _a.needTakePnlPc;
                                    leftAmount = leftAmount.minus(needTakePnlCoin.toString());
                                    rightAmount = rightAmount.minus(needTakePnlPc.toString());
                                }
                                else {
                                    throw new Error('Invalid multiple accounts info index');
                                }
                            }
                            else {
                                throw new Error('Invalid multiple accounts info index');
                            }
                        });
                        leftAmt = leftAmount.div(constants_1.DECIMAL_MULT[leftTokId]).toNumber();
                        checkIsValidNumber(leftAmt);
                        rightAmt = rightAmount.div(constants_1.DECIMAL_MULT[rightTokId]).toNumber();
                        checkIsValidNumber(rightAmt);
                        lpAmt = lpAmount.div(constants_1.DECIMAL_MULT[lpTokId]).toNumber();
                        checkIsValidNumber(lpAmt);
                        return [2 /*return*/, [leftAmt, rightAmt, lpAmt]];
                }
            });
        });
    };
    PriceInfo.prototype.getRaydiumAdditionalBalance = function (lpTokId, connection) {
        return __awaiter(this, void 0, void 0, function () {
            var raydiumPoolMeta, response, responseDataBuffer, LAYOUT, parsedOpenOrders, baseTokenTotal, quoteTokenTotal;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        raydiumPoolMeta = constants_1.RAYDIUM_LP_METAS[lpTokId];
                        (0, tiny_invariant_1.default)(raydiumPoolMeta);
                        return [4 /*yield*/, connection.getAccountInfo(raydiumPoolMeta.ammOpenOrdersPubkey)];
                    case 1:
                        response = (_a.sent());
                        (0, tiny_invariant_1.default)(response, "failed to fetch ammOpenOrders for " + lpTokId);
                        responseDataBuffer = buffer_1.Buffer.from(response.data);
                        LAYOUT = serum_1.OpenOrders.getLayout(raydiumPoolMeta.serumProgramId);
                        parsedOpenOrders = LAYOUT.decode(responseDataBuffer);
                        baseTokenTotal = parsedOpenOrders.baseTokenTotal, quoteTokenTotal = parsedOpenOrders.quoteTokenTotal;
                        return [2 /*return*/, [baseTokenTotal, quoteTokenTotal]];
                }
            });
        });
    };
    // Deprecated: Raydium added CloudFlare to block us
    PriceInfo.prototype.fetchRaydiumPrice = function (tokenId, timeout, retries) {
        if (timeout === void 0) { timeout = 3000; }
        if (retries === void 0) { retries = 3; }
        return __awaiter(this, void 0, void 0, function () {
            var response, error_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, axios_1.default.get('https://api.raydium.io/coin/price', {
                                timeout: timeout,
                                raxConfig: {
                                    retry: retries,
                                    noResponseRetries: retries,
                                    backoffType: 'exponential',
                                    statusCodesToRetry: [
                                        [100, 199],
                                        [400, 429],
                                        [500, 599],
                                    ],
                                    onRetryAttempt: function (err) {
                                        var cfg = rax.getConfig(err);
                                        console.log("Raydium price request retry attempt #" + (cfg === null || cfg === void 0 ? void 0 : cfg.currentRetryAttempt));
                                    },
                                },
                            })];
                    case 1:
                        response = _a.sent();
                        if (tokenId in response.data) {
                            return [2 /*return*/, response.data[tokenId]];
                        }
                        throw new Error(tokenId + " Price is not available at Raydium");
                    case 2:
                        error_2 = _a.sent();
                        if (axios_1.default.isAxiosError(error_2)) {
                            console.log("Request raydium price failed: " + error_2.message);
                        }
                        else {
                            console.log(error_2);
                        }
                        throw error_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    PriceInfo.prototype.fetchCoinGeckoPrice = function (tokenId) {
        return __awaiter(this, void 0, void 0, function () {
            var coinId, vsCcy, priceData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        coinId = constants_1.COINGECKO_PRICE_ID[tokenId];
                        vsCcy = 'usd';
                        if (coinId === undefined) {
                            console.error("Fetching price of " + tokenId + " from CoinGecko is not supported yet.");
                            return [2 /*return*/, 0];
                        }
                        if (tokenId === types_1.TokenID.SOCN) {
                            console.warn('Temporarily assume unlaunched SOCN price to be 0.06.');
                            return [2 /*return*/, 0.06];
                        }
                        return [4 /*yield*/, this.coinGecko.simple.price({ ids: coinId, vs_currencies: vsCcy })];
                    case 1:
                        priceData = _a.sent();
                        if (!priceData.success) {
                            console.error("Failed to fetch price of " + tokenId + " from CoinGecko.");
                            return [2 /*return*/, 0];
                        }
                        return [2 /*return*/, priceData.data[coinId][vsCcy]];
                }
            });
        });
    };
    return PriceInfo;
}());
exports.PriceInfo = PriceInfo;
//# sourceMappingURL=PriceInfo.js.map