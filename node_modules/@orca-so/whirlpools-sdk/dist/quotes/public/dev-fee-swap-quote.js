"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.swapQuoteByInputTokenWithDevFees = void 0;
const errors_1 = require("../../errors/errors");
const swap_quote_1 = require("./swap-quote");
/**
 * Get an estimated swap quote using input token amount while collecting dev fees.
 *
 * @category Quotes
 * @param whirlpool - Whirlpool to perform the swap on
 * @param inputTokenMint - PublicKey for the input token mint to swap with
 * @param tokenAmount - The amount of input token to swap from
 * @param slippageTolerance - The amount of slippage to account for in this quote
 * @param programId - PublicKey for the Whirlpool ProgramId
 * @param fetcher - AccountFetcher object to fetch solana accounts
 * @param refresh - If true, fetcher would default to fetching the latest accounts
 * @param devFeePercentage - The percentage amount to send to developer wallet prior to the swap. Percentage num/dem values has to match token decimal.
 * @returns a SwapQuote object with slippage adjusted SwapInput parameters & estimates on token amounts, fee & end whirlpool states.
 */
function swapQuoteByInputTokenWithDevFees(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, devFeePercentage, refresh) {
    return __awaiter(this, void 0, void 0, function* () {
        if (devFeePercentage.toDecimal().greaterThanOrEqualTo(1)) {
            throw new errors_1.WhirlpoolsError("Provided devFeePercentage must be less than 100%", errors_1.SwapErrorCode.InvalidDevFeePercentage);
        }
        const devFeeAmount = tokenAmount
            .mul(devFeePercentage.numerator)
            .div(devFeePercentage.denominator);
        const slippageAdjustedQuote = yield (0, swap_quote_1.swapQuoteByInputToken)(whirlpool, inputTokenMint, tokenAmount.sub(devFeeAmount), slippageTolerance, programId, fetcher, refresh);
        const devFeeAdjustedQuote = Object.assign(Object.assign({}, slippageAdjustedQuote), { amountSpecifiedIsInput: true, estimatedAmountIn: slippageAdjustedQuote.estimatedAmountIn.add(devFeeAmount), estimatedFeeAmount: slippageAdjustedQuote.estimatedFeeAmount.add(devFeeAmount), estimatedSwapFeeAmount: slippageAdjustedQuote.estimatedFeeAmount, devFeeAmount });
        return devFeeAdjustedQuote;
    });
}
exports.swapQuoteByInputTokenWithDevFees = swapQuoteByInputTokenWithDevFees;
