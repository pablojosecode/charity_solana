import { Percentage, TransactionBuilder } from "@orca-so/common-sdk";
import { Address } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";
import { WhirlpoolContext } from "../context";
import { DevFeeSwapInput, IncreaseLiquidityInput, SwapInput } from "../instructions";
import { AccountFetcher } from "../network/public";
import { TokenAccountInfo, TokenInfo, WhirlpoolData, WhirlpoolRewardInfo } from "../types/public";
import { Whirlpool } from "../whirlpool-client";
export declare class WhirlpoolImpl implements Whirlpool {
    readonly ctx: WhirlpoolContext;
    readonly fetcher: AccountFetcher;
    readonly address: PublicKey;
    readonly tokenAInfo: TokenInfo;
    readonly tokenBInfo: TokenInfo;
    private tokenVaultAInfo;
    private tokenVaultBInfo;
    private rewardInfos;
    private data;
    constructor(ctx: WhirlpoolContext, fetcher: AccountFetcher, address: PublicKey, tokenAInfo: TokenInfo, tokenBInfo: TokenInfo, tokenVaultAInfo: TokenAccountInfo, tokenVaultBInfo: TokenAccountInfo, rewardInfos: WhirlpoolRewardInfo[], data: WhirlpoolData);
    getAddress(): PublicKey;
    getData(): WhirlpoolData;
    getTokenAInfo(): TokenInfo;
    getTokenBInfo(): TokenInfo;
    getTokenVaultAInfo(): TokenAccountInfo;
    getTokenVaultBInfo(): TokenAccountInfo;
    getRewardInfos(): WhirlpoolRewardInfo[];
    refreshData(): Promise<WhirlpoolData>;
    openPosition(tickLower: number, tickUpper: number, liquidityInput: IncreaseLiquidityInput, wallet?: Address, funder?: Address): Promise<{
        positionMint: PublicKey;
        tx: TransactionBuilder;
    }>;
    openPositionWithMetadata(tickLower: number, tickUpper: number, liquidityInput: IncreaseLiquidityInput, sourceWallet?: Address, positionWallet?: Address, funder?: Address): Promise<{
        positionMint: PublicKey;
        tx: TransactionBuilder;
    }>;
    initTickArrayForTicks(ticks: number[], funder?: Address, refresh?: boolean): Promise<TransactionBuilder | null>;
    closePosition(positionAddress: Address, slippageTolerance: Percentage, destinationWallet?: Address, positionWallet?: Address, payer?: Address): Promise<TransactionBuilder>;
    swap(quote: SwapInput, sourceWallet?: Address): Promise<TransactionBuilder>;
    swapWithDevFees(quote: DevFeeSwapInput, devFeeWallet: PublicKey, wallet?: PublicKey | undefined, payer?: PublicKey | undefined): Promise<TransactionBuilder>;
    /**
     * Construct a transaction for opening an new position with optional metadata
     */
    getOpenPositionWithOptMetadataTx(tickLower: number, tickUpper: number, liquidityInput: IncreaseLiquidityInput, wallet: PublicKey, funder: PublicKey, withMetadata?: boolean): Promise<{
        positionMint: PublicKey;
        tx: TransactionBuilder;
    }>;
    getClosePositionIx(positionAddress: PublicKey, slippageTolerance: Percentage, destinationWallet: PublicKey, positionWallet: PublicKey, payerKey: PublicKey): Promise<TransactionBuilder>;
    private getSwapTx;
    private refresh;
}
